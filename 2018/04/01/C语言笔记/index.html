<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="Kerwin" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="C 常量#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！   反斜杠(\) 开头是叫转义序列(Escape Sequence)。\ooo 是对用三位八进制数">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言笔记">
<meta property="og:url" content="http://yoursite.com/2018/04/01/C语言笔记/index.html">
<meta property="og:site_name" content="Kerwin">
<meta property="og:description" content="C 常量#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！   反斜杠(\) 开头是叫转义序列(Escape Sequence)。\ooo 是对用三位八进制数">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-01T02:02:20.838Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C语言笔记">
<meta name="twitter:description" content="C 常量#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！   反斜杠(\) 开头是叫转义序列(Escape Sequence)。\ooo 是对用三位八进制数">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/01/C语言笔记/"/>





  <title> C语言笔记 | Kerwin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?931533eabc03369078b34713fefd96d2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kerwin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/C语言笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kerwin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oui2ar2u7.bkt.clouddn.com/Roronoa_Zoro.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kerwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C语言笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T09:55:05+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/04/01/C语言笔记/" class="leancloud_visitors" data-flag-title="C语言笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="C-常量"><a href="#C-常量" class="headerlink" title="C 常量"></a>C 常量</h4><p><code>#define</code> 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！  </p>
<p>反斜杠(<code>\</code>) 开头是叫转义序列(Escape Sequence)。<br><code>\ooo</code> 是对用三位八进制数转义表示任意字符的形象化描述。<br>比如 <code>char ch = &#39;\101&#39;</code>; 等价于 <code>char ch = 0101</code>; (以0开头的表示八进制）。<br><code>\xhh</code> 里面是 <code>x</code> 是固定的，表示十六进制(hexadecimal)，<code>h</code> 也表示十六进制。<br>举例，<code>char ch = &#39;\x41&#39;</code>; 就是用十六进制来表示，它与前面的 <code>\101</code> 是等价的。<br>可用如下代码证明它们等价：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">  </div><div class="line">int main()&#123;</div><div class="line">    printf(&quot;%c,%c,%c,%c&quot;, 0101, &apos;\101&apos;, &apos;\x41&apos;, &apos;A&apos;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h4><p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h5 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h5><p>auto存储类是所有局部变量默认的存储类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	int mount;</div><div class="line">	auto int month;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p>
<h5 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h5><p>register存储类用于定义存储在寄存器中而不是RAM中的局部变量。这意味着变量的最大尺寸等于寄存器的大小(通常是一个词)，且不能对它应用一元的‘&amp;’运算符(因为它没有内存位置)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	register int miles;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义‘register’并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，着取决于硬件和实现的限制。</p>
<h5 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h5><p>static存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要再每次它进入和离开作用域时进行创建和销毁。因此，使用static修饰局部变量可以在函数调用之间保持局部变量的值。<br>static修饰符也可以应用于全局变量。当static修饰全局变量时，会使变量的作用域限制在声明它的文件内。<br>static是全局变量的默认存储类，以下两个变量(count和road)都有一个static存储类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static int count;</div><div class="line">int road;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	printf(&quot;%d\n&quot;,count);</div><div class="line">	printf(&quot;%d\n&quot;,road);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下实例演示了 static 修饰全局变量和局部变量的应用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">/* 函数声明 */</div><div class="line">void func1(void);</div><div class="line"></div><div class="line">static int count = 10;     /* 全局变量 - static 是默认的 */</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    while (count --) &#123;</div><div class="line">        func1();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void func1(void)</div><div class="line">&#123;</div><div class="line">    /* &apos;thingy&apos; 是 &apos;func1&apos; 的局部变量 - 只初始化一次</div><div class="line">     * 每次调用函数 &apos;func1&apos; &apos;thingy&apos; 值不会被重置。</div><div class="line">     */</div><div class="line">    static int thingy = 5;</div><div class="line">    thingy ++;</div><div class="line">    printf(&quot;thingy 为 %d, count 为 %d\n&quot;,thingy,count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实例中count作为全局变量可以在函数内使用，thingy使用static修饰后，不会每次调用时重置（初始化）。运行结果如下  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">thingy 为 6, count 为 9</div><div class="line">thingy 为 7, count 为 8</div><div class="line">thingy 为 8, count 为 7</div><div class="line">thingy 为 9, count 为 6</div><div class="line">thingy 为 10, count 为 5</div><div class="line">thingy 为 11, count 为 4</div><div class="line">thingy 为 12, count 为 3</div><div class="line">thingy 为 13, count 为 2</div><div class="line">thingy 为 14, count 为 1</div><div class="line">thingy 为 15, count 为 0</div></pre></td></tr></table></figure>
<h5 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h5><p>extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。使用<code>extern</code>时,对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。<br>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern来得到已定义的变量或函数的引用。可以这么理解，<code>extern</code>是用来在另一文件中声明一个全局变量或函数。<br>extern修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示  </p>
<p>第一个文件：main.c  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"> </div><div class="line">int count ;</div><div class="line">extern void write_extern();</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   count = 5;</div><div class="line">   write_extern();</div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">第二个文件：support.c</div></pre></td></tr></table></figure>
<p>#include <stdio.h></stdio.h></p>
<p>extern int count;</p>
<p>void write_extern(void)<br>{<br>   printf(“count is %d\n”, count);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。</div><div class="line"></div><div class="line">#### C 运算符</div><div class="line">##### 算术运算符</div><div class="line"></div><div class="line">* `+` : 把两个操作数相加</div><div class="line">* `-` : 从第一个操作数中减去第二个操作数</div><div class="line">* `*` : 把两个操作数相乘</div><div class="line">* `/` : 分子除于分母</div><div class="line">* `%` : 取模运算符，整除后的余数</div><div class="line">* `++` : 自增运算符，整数值增加1</div><div class="line">* `--` : 自减运算符，整数值减少1</div><div class="line"></div><div class="line">##### 关系运算符</div><div class="line"></div><div class="line">* `==` : 检查两个操作数的值是否相等，如果相等则条件为真</div><div class="line">* `!=` : 检查两个操作数的值是否相等，如果不相等则条件为真</div><div class="line">* `&gt;` : 检查左操作数的值是否大于右操作数的值，如果是则条件为真</div><div class="line">* `&lt;` : 检查做操作数的值是否小于右操作数的值，如果是则条件为真</div><div class="line">* `&gt;=` : 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真</div><div class="line">* `&lt;=` : 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真</div><div class="line"></div><div class="line">##### 逻辑运算符</div><div class="line"></div><div class="line">* `&amp;&amp;` : 称为逻辑与运算符。如果两个操作数都非0，则条件为真</div><div class="line">* `||` : 称为逻辑或运算符。如果两个操作数中有任意一个非0，则条件为真</div><div class="line">* `!` : 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假</div><div class="line"></div><div class="line">##### 位运算符</div><div class="line"></div><div class="line">* `&amp;` : 称为位与运算符。如果两个操作数同一位都为1，则结果为1，否则为0</div><div class="line">* `|` : 称为位或运算符。如果两个操作数同一位任意一个为1，则结果为1，否则为0</div><div class="line">* `^` : 称为位异或运算符。如果两个操作数同一位相同，则结果为0，否则为1</div><div class="line">* `~` : 称为补码运算符。具有&quot;翻转&quot;位效果，即0变成1，1变成0</div><div class="line">* `&lt;&lt;` : 左移运算符。左操作数的值向左移动右操作数指定的位数</div><div class="line">* `&gt;&gt;` : 右移运算符。左操作数的值向右移动右操作数指定的位数</div><div class="line"></div><div class="line">##### 赋值运算符</div><div class="line"></div><div class="line">* `=` : 简单的赋值运算符，把右边操作数的值赋给左边操作数</div><div class="line">* `+=` : 加且赋值运算符，把右边操作数加上左边操作的结果赋值给左边操作数</div><div class="line">* `-=` : 减且赋值运算符，把左边操作数减去右边操作数的结果赋给左边操作数</div><div class="line">* `*=` : 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋给左边操作数</div><div class="line">* `/=` : 除且赋值运算符，把左边操作数除以右边操作数的结果赋给左边操作数</div><div class="line">* `%=` : 取模且赋值运算符，把左边操作数对右边操作数取模的结果赋给左边操作数</div><div class="line">* `&lt;&lt;=` : 左移且赋值运算符</div><div class="line">* `&gt;&gt;=` : 右移且赋值运算符</div><div class="line">* `&amp;=` : 按位与且赋值运算符</div><div class="line">* `|=` : 按位或且赋值运算符</div><div class="line">* `^=` : 按位异或且赋值运算符</div><div class="line"></div><div class="line">##### 杂项运算符</div><div class="line"></div><div class="line">* `sizeof()` : 返回变量的大小</div><div class="line">* `&amp;` : 返回变量的地址。`&amp;a` 将给出变量的实际地址。</div><div class="line">* `*` : 指向一个变量。 `*a`将指向一个变量</div><div class="line">* `?=` : 三元条件表达式。如果条件为真 ? 则值为 X : 否则值为 Y</div><div class="line"></div><div class="line">##### C 中的运算符优先级(高-&gt;低)</div><div class="line">1. 后缀：`() [] -&gt; . ++ --` `结合性：从左到右`</div><div class="line">2. 一元：`+ - ! ++ -- (type) * &amp; sizeof` `结合性：从右到左`</div><div class="line">3. 乘除：`* / %` `结合性：从左到右`</div><div class="line">4. 加减：`+ -` `结合性：从左到右`</div><div class="line">5. 移位：`&lt;&lt; &gt;&gt;` `结合性：从左到右`</div><div class="line">6. 关系：`&lt; &lt;= &gt; &gt;=` `结合性：从左到右`</div><div class="line">7. 相等：`== !=` `结合性：从左到右`</div><div class="line">8. 位与AND：`&amp;` `结合性：从左到右`</div><div class="line">9. 位异或XOR：`^` `结合性：从左到右`</div><div class="line">10. 位或OR：`|` `结合性：从左到右`</div><div class="line">11. 逻辑与AND：`&amp;&amp;` `结合性：从左到右`</div><div class="line">12. 逻辑或OR：`||` `结合性：从左到右`</div><div class="line">13. 条件：`?:` `结合性：从右到左`</div><div class="line">14. 赋值：`= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= |=` `结合性：从右到左`</div><div class="line">15. 逗号：`,` `结合性：从左到右`</div><div class="line"></div><div class="line">##### 利用异或`^`来交换两个数的值，而且不引入其他变量。</div></pre></td></tr></table></figure></p>
<p>unsigned int a=60;  //0011 1100<br>unsigned int b=13;  //0000 1101<br>a=a^b;              //a=a^b=0011 0001<br>b=a^b;              //b=a^b=0011 1100  相当于b1=(a^b)^b<br>a=a^b;              //a=a^b=0000 1101  相当于a1=(a^b)^((a^b)^b)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### C 判断</div><div class="line">##### 判断语句</div><div class="line"></div><div class="line">* [if 语句](http://www.runoob.com/cprogramming/c-if.html): 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。</div><div class="line">* [if...else 语句](http://www.runoob.com/cprogramming/c-if-else.html): 一个 **if语句** 后可跟一个可选的 **else** 语句，**else** 语句在布尔表达式为假时执行。</div><div class="line">* [嵌套 if 语句](http://www.runoob.com/cprogramming/c-nested-if.html): 可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。</div><div class="line">* [switch 语句](http://www.runoob.com/cprogramming/c-switch.html): 一个 **switch** 语句允许测试一个变量等于多个值时的情况。</div><div class="line">* [嵌套 switch 语句](http://www.runoob.com/cprogramming/c-nested-switch.html) : 可以在一个 **switch** 语句内使用另一个 **switch** 语句。</div><div class="line"></div><div class="line">##### ? : 运算符(三元运算符)</div><div class="line">条件运算符 ? :，可以用来替代 if...else 语句。</div></pre></td></tr></table></figure></p>
<p>Exp1 ? Exp2 : Exp3;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</div><div class="line">? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</div><div class="line"></div><div class="line">#### C 循环</div><div class="line">##### 循环类型</div><div class="line"></div><div class="line">* [while循环](http://www.runoob.com/cprogramming/c-while-loop.html): 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</div><div class="line">* [for 循环](http://www.runoob.com/cprogramming/c-for-loop.html): 多次执行一个语句序列，简化管理循环变量的代码。</div><div class="line">* [do...while 循环](http://www.runoob.com/cprogramming/c-do-while-loop.html): 当给定条件为真时，重复语句或语句组，至少会执行一次循环体</div><div class="line">* [嵌套循环](http://www.runoob.com/cprogramming/c-nested-loops.html): 可以在 while、for 或 do..while 循环内使用一个或多个循环。</div><div class="line"></div><div class="line">##### 循环控制语句</div><div class="line"></div><div class="line">* [break 语句](http://www.runoob.com/cprogramming/c-break-statement.html): 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</div><div class="line">* [continue 语句](http://www.runoob.com/cprogramming/c-continue-statement.html): 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</div><div class="line">* [goto 语句](http://www.runoob.com/cprogramming/c-goto-statement.html): 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</div><div class="line"></div><div class="line">#### C 函数</div><div class="line">&gt;函数是一组一起执行一个任务的语句。每个C程序都至少有一个函数，即主函数main()，所有简单的程序都可以定义其他额外的函数。  </div><div class="line">根据每个函数执行一个特定的任务代码进行划分。  </div><div class="line">函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。  </div><div class="line">C标准库提供了大量的程序可以调用的内置函数。例如，函数`strcat()`用来连接两个字符串，函数`memcpy()`用来复制内存到另一个位置。  </div><div class="line">函数还有很多叫法，比如方法、子例程等等。</div><div class="line"></div><div class="line">##### 定义函数</div><div class="line">一般形式如下：</div></pre></td></tr></table></figure></p>
<p>return_type function_name(parameter list)<br>{<br>    body of the function<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">在C语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：  </div><div class="line"></div><div class="line">* `返回类型`：一个函数可以返回一个值。**return_type** 是函数返回值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。  </div><div class="line">* `函数名称`：函数的实际名称。函数名和参数列表一起构成了函数签名。</div><div class="line">* `参数`：参数就像是占位符。当函数被调用时，向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</div><div class="line">* `函数主体`：函数主题包含一组定义函数执行任务的语句。</div><div class="line"></div><div class="line">##### 函数声明</div><div class="line">函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。  </div><div class="line">函数声明包括以下几个部分</div></pre></td></tr></table></figure></p>
<p>return_type function_name(parameter list);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如：</div></pre></td></tr></table></figure></p>
<p>int max(int num1, int num2);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在函数声明中，参数的名称并不重要，只有参数的类型是必须的，因此下面也是有效的声明：</div></pre></td></tr></table></figure></p>
<p>int max(int, int);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">如果想在一个源文件中调用另一个文件中定义的函数，函数的声明是必须，应该在调用函数文件的顶部声明函数。  </div><div class="line"></div><div class="line">##### 调用函数</div><div class="line">当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。  </div><div class="line">调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。  </div><div class="line"></div><div class="line">##### 函数参数</div><div class="line">如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。  </div><div class="line">形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。  </div><div class="line">当调用函数时，有两种向函数传递参数的方式：</div><div class="line"></div><div class="line">* [传值调用](http://www.runoob.com/cprogramming/c-function-call-by-value.html): 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。  </div><div class="line">* [引用调用](http://www.runoob.com/cprogramming/c-function-call-by-pointer.html): 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</div><div class="line"></div><div class="line">##### 笔记</div><div class="line">根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。</div><div class="line">###### 内部函数</div><div class="line">如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即</div></pre></td></tr></table></figure></p>
<p>static 类型名 函数名 （形参表）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">内部函数又称静态函数。使用内部函数，可以使函数的作用域只局限于所在文件。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。</div><div class="line">###### 外部函数</div><div class="line">如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。  </div><div class="line">如函数首部可以为</div></pre></td></tr></table></figure></p>
<p>extern 类型名 函数名 （形参表）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。</div><div class="line">在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。</div><div class="line">  </div><div class="line">###### 实例</div><div class="line">file1.c(文件1)</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>static void delete_string(char str[],char ch);<br>int main()<br>{<br>    extern void enter(char str[]); // 对函数的声明<br>    extern void print(char str[]); // 对函数的声明<br>    char c,str[100];<br>    enter(str);<br>    scanf(“%c”,&amp;c);<br>    delete_string(str,c);<br>    print(str);<br>    return 0;<br>}</p>
<p>static void delete_string(char str[],char ch)//内部函数<br>{<br>    int i,j;<br>    for(i=j=0;str[i]!=’\0’;i++)<br>    if(str[i]!=ch)<br>    str[j++]=str[i];<br>    str[j]=’\0’;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file2.c(文件2)</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>void enter(char str[100]) // 定义外部函数 enter<br>{<br>    fgets(str, 100, stdin); // 向字符数组输入字符串<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file3.c(文件3)</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>void print(char str[]) // 定义外部函数 print<br>{<br>    printf(“%s\n”,str);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###### 内联函数</div><div class="line">内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。  </div><div class="line">内联扩展是用来消除函数调用时的时间开销。它通常用于频繁执行的函数，对于小内存空间的函数非常受益。     </div><div class="line">使用内联函数的时候要注意：  </div><div class="line"></div><div class="line">* 递归函数不能定义为内联函数</div><div class="line">* 内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。</div><div class="line">* 内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。</div><div class="line">* 对内联函数不能进行异常的接口声明。</div><div class="line"></div><div class="line">一个简单的交换函数</div></pre></td></tr></table></figure></p>
<p>inline void swap(int <em>a, int </em>b)<br>{<br>    int t = <em>a;
    </em>a = <em>b;
    </em>b = t;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#### C 作用域规则</div><div class="line">任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：  </div><div class="line"></div><div class="line">* 在函数或块内部的局部变量</div><div class="line">* 在所有函数外部的全局变量</div><div class="line">* 在形式参数的函数参数定义中</div><div class="line"></div><div class="line">##### 局部变量</div><div class="line">在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。</div><div class="line"></div><div class="line">##### 全局变量</div><div class="line">全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序的生命周期内都是有效的，在任意的函数内部能访问全局变量。     </div><div class="line">全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序都是可用的。    </div><div class="line">在程序中，局部变量和全局变量的名称可以相同的，但是在函数内，局部变量的值会覆盖全局变量的值。</div><div class="line"></div><div class="line">##### 形式参数</div><div class="line">函数的参数，形式参数，被当做该函数内的局部变量，它们会优先覆盖同名的全局变量。  </div><div class="line"></div><div class="line">##### 初始化局部变量和全局变量</div><div class="line">当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</div><div class="line"></div><div class="line">* int 初始化默认值： 0</div><div class="line">* char 初始化默认值： &apos;\0&apos;</div><div class="line">* float 初始化默认值： 0</div><div class="line">* double 初始化默认值： 0</div><div class="line">* pointer 初始化默认值： NULL</div><div class="line">正确地初始化变量时一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</div><div class="line"></div><div class="line">#### C 数组</div><div class="line">C 语言支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组的特定元素可以通过索引访问。  </div><div class="line">所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</div><div class="line"></div><div class="line">##### 声明数组</div><div class="line">在C中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</div></pre></td></tr></table></figure></p>
<p>type arrayName[arraySize];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这叫做一维数组。arraySize必须是一个大于零的常数常量，type可以是任意有效的C数据类型。</div><div class="line"></div><div class="line">##### 初始化数组</div><div class="line">在C中，可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</div></pre></td></tr></table></figure></p>
<p>double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">大括号&#123;&#125;之间的值的数目不能大于我们在数组声明时在方括号[]中指定的元素数目。  </div><div class="line">如果省略了数组的大小，数组的大小则为初始化时元素的个数。</div><div class="line"></div><div class="line">##### 访问数组元素</div><div class="line">数组元素可以通过数组名加索引进行访问，元素的索引是放在方括号内，跟在数组名后边。</div><div class="line"></div><div class="line">##### C 中数组详解</div><div class="line">与数组相关的重要概念：  </div><div class="line"></div><div class="line">* [多维数组](http://www.runoob.com/cprogramming/c-multi-dimensional-arrays.html): C 支持多维数组。多维数组最简单的形式是二维数组。</div><div class="line">* [传递数组给函数](http://www.runoob.com/cprogramming/c-passing-arrays-to-functions.html): 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</div><div class="line">* [从函数返回数组](http://www.runoob.com/cprogramming/c-return-arrays-from-function.html): C 允许从函数返回数组。</div><div class="line">* [指向数组的指针](http://www.runoob.com/cprogramming/c-pointer-to-an-array.html): 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</div><div class="line"></div><div class="line">##### 笔记</div><div class="line">###### srand((unsigned)time(NULL))是初始化随机函数种子： </div><div class="line">   </div><div class="line">* 是拿当前系统时间作为种子，由于时间是变化的，种子变化，可以产生不相同的随机数。计算机中的随机数实际上都不是真正的随机数，如果两次给的种子一样，是会生成同样的随机序列的。 所以，一般都会以当前的时间作为种子来生成随机数，这样更加的随机。</div><div class="line">* 使用时，参数可以是unsigned型的任意数据，比如srand（10）；</div><div class="line">* 如果不使用srand，用rand（）产生的随机数，在多次运行，结果是一样的。</div><div class="line"></div><div class="line">参考如下：</div></pre></td></tr></table></figure></p>
<p>void test_rand(void)<br>{<br>    unsigned long n;<br>    srand((unsigned)time(NULL));<br>    for(int i = 0; i &lt; 100; i++)<br>    {<br>        n = rand();<br>        printf(“%d\n”, n);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###### 一个小知识点：</div><div class="line">在我们没有明确数组的元素个数时，在程序中想知道数组单元个数可以使用 `sizeof(a)/sizeof(a[0])`, `sizeof(a)` 是得到数组 `a` 的大小，`sizeof(a[0])` 是得到数组 `a` 中单个元素的大小（因此可以不必要是a[0],a[i]都行），eg:</div></pre></td></tr></table></figure></p>
<p>#include<stdio.h></stdio.h></p>
<p>int main(int argc,char *grgv[])<br>{<br>    int a[]={1,2,3,4,5};<br>    int b;<br>    b=sizeof(a)/sizeof(a[0]);<br>    printf(“数组元素个数为：%d”,b);<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### C 指针</div><div class="line">每个变量都有一个内存位置，每一个内存位置都定义了可使用连字号(&amp;)运算符访问的地址，它表示内存中的一个地址。  </div><div class="line"></div><div class="line">##### 什么是指针？</div><div class="line">`指针`是一个变量，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</div></pre></td></tr></table></figure></p>
<p>type *var-name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`type`是指针的基类型，它必须是一个有效的C数据类型，var-name是指针变量名称。用来声明指针的星号`*`是用来指定一个变量是指针。一下是有效的指针声明：</div></pre></td></tr></table></figure></p>
<p>int <em>ip;  //一个整型的指针<br>double </em>dp; //一个double型的指针<br>float <em>fp; //一个浮点型的指针<br>char </em>ch; //一个字符型的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其它的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指箱的变量或常量的数据类型不同。</div><div class="line"></div><div class="line">##### 如何使用指针？</div><div class="line">使用指针有以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符`*`来返回位于操作数所指定地址的变量的值。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main()<br>{<br>    int var = 20; //实际变量的声明<br>    int *ip;      //指针变量的声明</p>
<pre><code>ip = &amp;var;    //在指针变量中存储var的地址

printf(&quot;Address of var variable: %p\n&quot;,&amp;var);

//在指针变量中存储的地址
printf(&quot;Address stored in ip variable: %p\n&quot;,ip);

//使用指针访问值
printf(&quot;Value of *ip variable : %d\n&quot;, *ip);

return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### C中的NULL指针</div><div class="line">在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。  </div><div class="line">NULL 指针是一个定义在标准库中的值为零的常量。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main()<br>{<br>    int *ptr = NULL;</p>
<pre><code>printf(&quot;ptr的值是 %p\n&quot;, ptr);//ptr的值是 0

return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在大多数的操作系统上，程序不允许访问地址为0的内存，因为该内存是操作系统保留的。然而，内存地址0有特别重要的意义，它表明该指针不指向一个可以访问的内存位置。按照惯例，如果指针包含空值(零值)，则假定它不指向任何东西。  </div><div class="line">如果检查一个空指针，可以使用if语句</div></pre></td></tr></table></figure></p>
<p>if(ptr)  //如果ptr非空，则成立<br>if(!ptr) //如果ptr为空，则成立<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### C 指针详解</div><div class="line">与指针相关的重要概念：  </div><div class="line"></div><div class="line">* [指针的算术运算](http://www.runoob.com/cprogramming/c-pointer-arithmetic.html): 可以对指针进行四种算术运算：`++ -- + -`，按照元素的size加减</div><div class="line">* [指针数组](http://www.runoob.com/cprogramming/c-array-of-pointers.html): 可以定义用来存储指针的数组。</div><div class="line">* [指向指针的指针](http://www.runoob.com/cprogramming/c-pointer-to-pointer.html): C 允许指向指针的指针。</div><div class="line">* [传递指针给函数](http://www.runoob.com/cprogramming/c-passing-pointers-to-functions.html): 通过引用或地址传递参数，使传递的参数在调用函数中被改变。</div><div class="line">* [从函数返回指针](http://www.runoob.com/cprogramming/c-return-pointer-from-functions.html): C 允许函数返回指针到局部变量、静态变量和动态内存分配。</div><div class="line"></div><div class="line">##### C 指向指针的指针</div><div class="line">指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。  </div><div class="line">一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</div></pre></td></tr></table></figure></p>
<p>int **var;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main ()<br>{<br>   int  var;<br>   int  <em>ptr;<br>   int  *</em>pptr;</p>
<p>   var = 3000;</p>
<p>   /<em> 获取 var 的地址 </em>/<br>   ptr = &var;</p>
<p>   /<em> 使用运算符 &amp; 获取 ptr 的地址 </em>/<br>   pptr = &ptr;</p>
<p>   /<em> 使用 pptr 获取值 </em>/<br>   printf(“Value of var = %d\n”, var );  //结果：Value of var = 3000<br>   printf(“Value available at <em>ptr = %d\n”, </em>ptr ); //结果：Value available at <em>ptr = 3000<br>   printf(“Value available at <strong>pptr = %d\n”, </strong>pptr); //结果：Value available at *</em>pptr = 3000</p>
<p>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 函数指针</div><div class="line">函数指针是指向函数的指针变量。函数指针可以像一般函数一样，用于调用函数、传递参数。  </div><div class="line">函数指针变量的声明：</div></pre></td></tr></table></figure></p>
<p>typedef int (*fun_ptr)(int, int);//声明一个指向整型参数、整型返回值的函数指针类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int max(int x, int y)<br>{<br>    return x &gt; y ? x : y;<br>}</p>
<p>int main(int argc, const char * argv[]) {</p>
<pre><code>//p 是函数指针
int (*p)(int, int) = &amp;max; //&amp;可以省略
int a, b, c, d;

printf(&quot;请输入三个数字:&quot;);
scanf(&quot;%d %d %d&quot;,&amp;a, &amp;b, &amp;c);

//与直接调用函数等价，d = max(max(a, b), c);
d = p(p(a, b), c);

printf(&quot;最大的数字是: %d\n&quot;,d);

return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 回调函数</div><div class="line">###### 函数指针作为某个函数的参数</div><div class="line">函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。  </div><div class="line">简单讲：回调函数是由别人的函数执行时调用你实现的函数。  </div><div class="line">实例</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>//回调函数<br>void populate_array(int <em>array, size_t arraySize, int (</em>getNextValue)(void))<br>{<br>    for (size_t i = 0; i &lt; arraySize; i ++) {<br>        array[i] = getNextValue();<br>    }<br>}</p>
<p>//获取随机值<br>int getNextRadomValue(void)<br>{<br>    return rand();<br>}</p>
<p>int main(int argc, const char * argv[]) {</p>
<pre><code>int myarray[10];
populate_array(myarray, 10, getNextRadomValue);
for (int i = 0; i &lt; 10; i ++) {
    printf(&quot;%d\n&quot;,myarray[i]);
}
printf(&quot;\n&quot;);

return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 笔记  </div><div class="line">`size_t` 类型在C语言标准库函数原型使用的很多，数值范围一般是要大于int和unsigned.</div><div class="line">但凡不涉及负值范围的表示size取值的，都可以用`size_t`；比如`array[size_t]`。  </div><div class="line">`size_t` 在stddef.h头文件中定义。  </div><div class="line">在其他常见的宏定义以及函数中常用到有：  </div><div class="line">1、`sizeof`运算符返回的结果是`size_t`类型；  </div><div class="line">2、`void *malloc(size_t size)...  `</div><div class="line"></div><div class="line">#### C 字符串</div><div class="line">在C语言中，字符串实际上是使用null字符&apos;\0&apos;终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。  </div><div class="line">##### C 中有大量操作字符串的函数：</div><div class="line"></div><div class="line">* `strcpy(s1, s2);` : 复制字符串s2到字符串s1。</div><div class="line">* `strcat(s1, s2);` : 连接字符串s2到字符串s1的末尾。</div><div class="line">* `strlen(s1);` : 返回字符串s1的长度</div><div class="line">* `strcmp(s1, s2);` : 如果s1和s2是相同的，则返回0；如果s1&lt;s2则返回小于0；如果s1&gt;s2则返回大于0</div><div class="line">* `strchr(s1, ch);` : 返回一个指针，指向字符串s1中字符ch第一出现的位置</div><div class="line">* `strstr(s1, s2);` : 返回一个指针，指向字符串s1中字符串s2第一次出现的位置  </div><div class="line"></div><div class="line">#### C 结构体</div><div class="line">C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</div><div class="line"></div><div class="line">##### 定义结构体</div><div class="line">为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</div></pre></td></tr></table></figure></p>
<p>struct [structure tag]<br>{<br>    member definition;<br>    member definition;<br>    …<br>    member definition;<br>} [one or more structure variables];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">structure tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明 Book 结构的方式：</div></pre></td></tr></table></figure></p>
<p>struct Books<br>{<br>    char title[50];<br>    char author[50];<br>    char subject[100];<br>    int book_id;<br>} book;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">##### 访问结构成员</div><div class="line">为了访问结构体的成员，我们使用**成员访问运算符(.)**。成员访问运算符是结构变量名称和我们要访问的结构体成员之间的一个点。可以使用struct关键字来定义结构体类型的变量。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>struct Books {<br>    char title[50];<br>    char author[50];<br>    char subject[100];<br>    int book_id;<br>};</p>
<p>int main(int argc, const char * argv[]) {</p>
<pre><code>struct Books book1;  //声明book1，类型为Books
struct Books book2;  //声明book2，类型为Books

//book1详述
strcpy(book1.title, &quot;C Programming&quot;);
strcpy(book1.author, &quot;Nuha Ali&quot;);
strcpy(book1.subject, &quot;C Programming Tutorial&quot;);
book1.book_id = 6595407;

//book2详述
strcpy(book2.title, &quot;Telecom Billing&quot;);
strcpy(book2.author, &quot;Zara Ali&quot;);
strcpy(book2.subject, &quot;Telecom Billing Tutorial&quot;);
book2.book_id = 6495700;

/* 输出 Book1 信息 */
printf( &quot;book 1 title : %s\n&quot;, book1.title);
printf( &quot;book 1 author : %s\n&quot;, book1.author);
printf( &quot;book 1 subject : %s\n&quot;, book1.subject);
printf( &quot;book 1 book_id : %d\n&quot;, book1.book_id);

/* 输出 Book2 信息 */
printf( &quot;book 2 title : %s\n&quot;, book2.title);
printf( &quot;book 2 author : %s\n&quot;, book2.author);
printf( &quot;book 2 subject : %s\n&quot;, book2.subject);
printf( &quot;book 2 book_id : %d\n&quot;, book2.book_id);

return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 结构体作为函数参数</div><div class="line">您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>struct Books {<br>    char title[50];<br>    char author[50];<br>    char subject[100];<br>    int book_id;<br>};</p>
<p>//函数声明<br>void printBook(struct Books book);</p>
<p>int main(int argc, const char * argv[]) {</p>
<pre><code>struct Books book1;  //声明book1，类型为Books
struct Books book2;  //声明book2，类型为Books

//book1详述
strcpy(book1.title, &quot;C Programming&quot;);
strcpy(book1.author, &quot;Nuha Ali&quot;);
strcpy(book1.subject, &quot;C Programming Tutorial&quot;);
book1.book_id = 6595407;

//book2详述
strcpy(book2.title, &quot;Telecom Billing&quot;);
strcpy(book2.author, &quot;Zara Ali&quot;);
strcpy(book2.subject, &quot;Telecom Billing Tutorial&quot;);
book2.book_id = 6495700;

/* 输出 Book1 信息 */
printBook(book1);

/* 输出 Book2 信息 */
printBook(book2);

return 0;
</code></pre><p>}</p>
<p>void printBook(struct Books book)<br>{<br>    printf( “book  title : %s\n”, book.title);<br>    printf( “book  author : %s\n”, book.author);<br>    printf( “book  subject : %s\n”, book.subject);<br>    printf( “book  book_id : %d\n”, book.book_id);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">##### 指向结构的指针</div><div class="line">您可以定义指向结构的指针，方式如下所示：</div></pre></td></tr></table></figure></p>
<p>struct Books *struct_pointer;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</div></pre></td></tr></table></figure></p>
<p>struct_pointer-&gt;title;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>struct Books {<br>    char title[50];<br>    char author[50];<br>    char subject[100];<br>    int book_id;<br>};</p>
<p>//函数声明<br>void printBook(struct Books *book);</p>
<p>int main(int argc, const char * argv[]) {</p>
<pre><code>struct Books book1;  //声明book1，类型为Books
struct Books book2;  //声明book2，类型为Books

//book1详述
strcpy(book1.title, &quot;C Programming&quot;);
strcpy(book1.author, &quot;Nuha Ali&quot;);
strcpy(book1.subject, &quot;C Programming Tutorial&quot;);
book1.book_id = 6595407;

//book2详述
strcpy(book2.title, &quot;Telecom Billing&quot;);
strcpy(book2.author, &quot;Zara Ali&quot;);
strcpy(book2.subject, &quot;Telecom Billing Tutorial&quot;);
book2.book_id = 6495700;

/* 输出 Book1 信息 */
printBook(&amp;book1);

/* 输出 Book2 信息 */
printBook(&amp;book2);

return 0;
</code></pre><p>}</p>
<p>void printBook(struct Books *book)<br>{<br>    printf( “book  title : %s\n”, book-&gt;title);<br>    printf( “book  author : %s\n”, book-&gt;author);<br>    printf( “book  subject : %s\n”, book-&gt;subject);<br>    printf( “book  book_id : %d\n”, book-&gt;book_id);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 位域</div><div class="line">有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用1位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。  </div><div class="line">所谓的位域就是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。  </div><div class="line">典型的实例：</div><div class="line">  </div><div class="line">* 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</div><div class="line">* 读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</div><div class="line"></div><div class="line">##### 位域的定义和位域变量的说明</div><div class="line">位域定义与结构体定义相仿，其形式为：</div></pre></td></tr></table></figure>
<p>struct 位域结构名<br>{<br>    位域列表<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中位域列表的形式为：</div></pre></td></tr></table></figure></p>
<p>类型说明符 位域名: 位域长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如：</div></pre></td></tr></table></figure></p>
<p>struct bs{<br>    int a:8;<br>    int b:2;<br>    int c:6;<br>}data;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位</div><div class="line"></div><div class="line">###### 对于位域的定义尚有以下几点说明：</div><div class="line"></div><div class="line">* 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下单元开始。例如：</div></pre></td></tr></table></figure></p>
<p>struct bs {<br>    unsigned a:4;<br>    unsigned  :4; //空域<br>    unsigned b:4; //从下一单元开始存放<br>    unsigned c:4;<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 位域可以是无名位域，这时它只是用来做填充或调整位置。无名的位域是不能使用的。例如：</div></pre></td></tr></table></figure></p>
<p>struct k{<br>    int a:1;<br>    int  :2;    /<em> 该 2 位不能使用 </em>/<br>    int b:3;<br>    int c:2;<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</div><div class="line"></div><div class="line">##### 位域的使用</div><div class="line">位域的使用和结构成员的使用相同，其一般形式为：</div></pre></td></tr></table></figure></p>
<p>位域变量名.位域名<br>位域变量名-&gt;位域名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">位域允许用各种格式输出。</div></pre></td></tr></table></figure></p>
<p>main(){<br>    struct bs{<br>        unsigned a:1;<br>        unsigned b:3;<br>        unsigned c:4;<br>    } bit,<em>pbit;<br>    bit.a=1;    /</em> 给位域赋值（应注意赋值不能超过该位域的允许范围） <em>/<br>    bit.b=7;    /</em> 给位域赋值（应注意赋值不能超过该位域的允许范围） <em>/<br>    bit.c=15;    /</em> 给位域赋值（应注意赋值不能超过该位域的允许范围） <em>/<br>    printf(“%d,%d,%d\n”,bit.a,bit.b,bit.c);    /</em> 以整型量格式输出三个域的内容 <em>/<br>    pbit=&bit;    /</em> 把位域变量 bit 的地址送给指针变量 pbit <em>/<br>    pbit-&gt;a=0;    /</em> 用指针方式给位域 a 重新赋值，赋为 0 <em>/<br>    pbit-&gt;b&amp;=3;    /</em> 使用了复合的位运算符 “&amp;=”，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） <em>/<br>    pbit-&gt;c|=1;    /</em> 使用了复合位运算符”|=”，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 <em>/<br>    printf(“%d,%d,%d\n”,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c);    /</em> 用指针方式输出了这三个域的值 */<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 笔记</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>typedef struct<br>{<br>    unsigned char a;<br>    unsigned int  b;<br>    unsigned char c;<br>} debug_size1_t;<br>typedef struct<br>{<br>    unsigned char a;<br>    unsigned char b;<br>    unsigned int  c;<br>} debug_size2_t;</p>
<p>int main(void)<br>{<br>    printf(“debug_size1_t size=%lu,debug_size2_t size=%lu\r\n”, sizeof(debug_size1_t), sizeof(debug_size2_t));<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">编译执行输出结果：</div></pre></td></tr></table></figure></p>
<p>debug_size1_t size=12,debug_size2_t size=8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">结构体占用存储空间,以32位机为例  </div><div class="line"></div><div class="line">* `debug_size1_t` 存储空间分布为a(1byte)+空闲(3byte)+b(4byte)+c(1byte)+空闲(3byte)=12(byte)。  </div><div class="line">* `debug_size2_t` 存储空间分布为a(1byte)+b(1byte)+空闲(2byte)+c(4byte)=8(byte)。</div><div class="line"></div><div class="line">[参考链接](https://blog.csdn.net/peixuan197/article/details/48162353)</div><div class="line"></div><div class="line"></div><div class="line">#### C 共用体</div><div class="line">**共用体**是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</div><div class="line"></div><div class="line">##### 定义共用体</div><div class="line">定义共用体需要使用union语句，方式与定义结构体类似。union语句定义了一个新的数据类型，带有多个成员。格式如下：</div></pre></td></tr></table></figure></p>
<p>union [union tag]<br>{<br>    member definition;<br>    member definition;<br>    …<br>    member definition;<br>} [one or more union variables];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`union tag` 是可选的，每个 `member definition` 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：</div></pre></td></tr></table></figure></p>
<p>union Data<br>{<br>    int i;<br>    float f;<br>    char str[20];<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">现在，Data类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量(相同的内存位置)可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。  </div><div class="line">共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。  </div><div class="line"></div><div class="line">##### 访问共用体成员</div><div class="line">为了访问共用体的成员，我们使用**成员访问运算符（.）**。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 **union** 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>union Data<br>{<br>   int i;<br>   float f;<br>   char  str[20];<br>};</p>
<p>int main( )<br>{<br>   union Data data;        </p>
<p>   data.i = 10;<br>   data.f = 220.5;<br>   strcpy( data.str, “C Programming”);</p>
<p>   printf( “data.i : %d\n”, data.i);<br>   printf( “data.f : %f\n”, data.f);<br>   printf( “data.str : %s\n”, data.str);</p>
<p>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">运行结果：</div></pre></td></tr></table></figure></p>
<p>data.i : 1917853763<br>data.f : 4122360580327794860452759994368.000000<br>data.str : C Programming<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。</div><div class="line"></div><div class="line">##### 笔记</div></pre></td></tr></table></figure></p>
<p>union Data{<br>    int i;<br>    float f;<br>    char str[9];<br>    double d;<br>}data;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">共用体所占内存并非是9个char，即9个字节，而是double的两倍，即16个字节，而且每次输出都是它前面离它最近的值。[参考链接](https://wenku.baidu.com/view/6365bfe64bfe04a1b0717fd5360cba1aa8118c65.html)</div><div class="line"></div><div class="line">#### C typedef</div><div class="line">C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。比如：</div></pre></td></tr></table></figure></p>
<p>typedef unsigned char BYTE;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在这个类型定义之后，标识符BYTE可作为类型unsigned char的缩写，例如：</div></pre></td></tr></table></figure></p>
<p>BYTE b1, b2;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">定义时一般用大写字母以便提醒用户类型名称是一个象征性的缩写，也可以使用小写字母。  </div><div class="line">可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>typedef struct Books<br>{<br>   char  title[50];<br>   char  author[50];<br>   char  subject[100];<br>   int   book_id;<br>} Book;</p>
<p>int main( )<br>{<br>   Book book;</p>
<p>   strcpy( book.title, “C 教程”);<br>   strcpy( book.author, “Runoob”);<br>   strcpy( book.subject, “编程语言”);<br>   book.book_id = 12345;</p>
<p>   printf( “书标题 : %s\n”, book.title);<br>   printf( “书作者 : %s\n”, book.author);<br>   printf( “书类目 : %s\n”, book.subject);<br>   printf( “书 ID : %d\n”, book.book_id);</p>
<p>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### typedef vs #define</div><div class="line">`#define` 是 C 指令，用于为各种数据类型定义别名，与 `typedef` 类似，但是它们有以下几点不同：  </div><div class="line"></div><div class="line">* `typedef`仅限于为类型定义符号名称，`#define`不仅可以为类型定义别名，也可以为数值定义别名，比如可以定义1 为 ONE</div><div class="line">* `typedef`是由编译器执行解释的，`#define`语句是由预编译器进行处理的</div><div class="line">* `#define`可以使用其他类型说明符对宏类型名进行扩展，但对 `typedef `所定义的类型名却不能这样做。例如：</div></pre></td></tr></table></figure></p>
<p>#define INTERGE int<br>unsigned INTERGE n;  //没问题<br>typedef int INTERGE;<br>unsigned INTERGE n;  //错误，不能在 INTERGE 前面添加 unsigned<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*  在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：</div></pre></td></tr></table></figure></p>
<p>#define PTR_INT int <em><br>PTR_INT p1, p2;        //p1、p2 类型不相同，宏展开后变为int </em>p1, p2;<br>typedef int * PTR_INT<br>PTR_INT p1, p2;        //p1、p2 类型相同，它们都是指向 int 类型的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### C 输入 &amp; 输出</div><div class="line">**输入** 意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。  </div><div class="line">**输出** 意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</div><div class="line"></div><div class="line">##### 标准文件</div><div class="line">C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。  </div><div class="line"></div><div class="line">* `标准输入` **----------&gt;** `stdin` **----------&gt;** `键盘`</div><div class="line">* `标准输出` **----------&gt;** `stdout` **----------&gt;** `屏幕`</div><div class="line">* `标准错误` **----------&gt;** `stderr` **----------&gt;** `屏幕`</div><div class="line"></div><div class="line">文件指针是访问文件的方式，C语言中`I/O`(输入和输出)经常使用`printf()`和`scanf()`两个函数。  </div><div class="line">`scanf()`函数用于从标准输入(键盘)读取和格式化，`printf()`函数发送格式化输出到标准输出(屏幕)。  </div><div class="line"></div><div class="line">##### getchar() &amp; putchar() 函数</div><div class="line">`int getchar(void)`函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一时间内只会读取一个单一的字符。可以在循环内使用这个方法，以便从屏幕上读取多个字符。  </div><div class="line">`int putchar(int c)`函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一时间内只会输出一个单一的字符。可以在循环中使用这个方法，以便在屏幕上输出多个字符。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main( )<br>{<br>   int c;</p>
<p>   printf( “Enter a value :”);<br>   c = getchar( );</p>
<p>   printf( “\nYou entered: “);<br>   putchar( c );<br>   printf( “\n”);<br>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：</div></pre></td></tr></table></figure></p>
<p>Enter a value :runoob</p>
<p>You entered: r<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### gets() &amp; puts()函数</div><div class="line">`char *gets(char *s)`函数从**stdin**读取一行到**s**所指向的缓冲区，直到一个终止符或EOF。  </div><div class="line">`int puts(const char *s)`函数把字符串**s**和一个尾随的**换行符**写入到**stdout**。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main( )<br>{<br>   char str[100];</p>
<p>   printf( “Enter a value :”);<br>   gets( str );</p>
<p>   printf( “\nYou entered: “);<br>   puts( str );<br>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</div></pre></td></tr></table></figure></p>
<p>Enter a value :runoob</p>
<p>You entered: runoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### scanf() 和 printf() 函数</div><div class="line">`int scanf(const char *format, ...)` 函数从标准输入流 **stdin** 读取输入，并根据提供的 **format** 来浏览输入。</div><div class="line">`int printf(const char *format, ...)` 函数把输出写入到标准输出流 **stdout** ，并根据提供的格式产生输出。</div><div class="line">**format** 可以是一个简单的常量字符串，但是您可以分别指定 `%s、%d、%c、%f` 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h><br>int main( ) {</stdio.h></p>
<p>   char str[100];<br>   int i;</p>
<p>   printf( “Enter a value :”);<br>   scanf(“%s %d”, str, &amp;i);</p>
<p>   printf( “\nYou entered: %s %d “, str, i);<br>   printf(“\n”);<br>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</div></pre></td></tr></table></figure></p>
<p>Enter a value :runoob 123</p>
<p>You entered: runoob 123<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">在这里，应当指出的是，`scanf()` 期待输入的格式与您给出的 `%s` 和 `%d` 相同，这意味着您必须提供有效的输入，比如 &quot;string integer&quot;，如果您提供的是 &quot;string string&quot; 或 &quot;integer integer&quot;，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，`scanf()` 就会停止读取，所以 &quot;this is test&quot; 对 `scanf()` 来说是三个字符串。</div><div class="line"></div><div class="line">#### fgets() &amp; fputs()</div><div class="line">gets函数由于没有指定输入字符大小，所以会无限读取，一旦输入的字符大于数组长度，就会发生内存越界,从而造成程序崩溃或其他数据的错误。 </div><div class="line"> </div><div class="line">**fgets**函数原型：`char *fgets(char *s, int n, FILE *stream);`//我们平时可以这么使用：`fgets(str, sizeof(str), stdin);`  </div><div class="line"></div><div class="line">其中str为数组首地址，sizeof(str)为数组大小，stdin表示我们从键盘输入数据。 </div><div class="line"> </div><div class="line">**fgets**函数功能：从文件指针stream中读取字符，存到以s为起始地址的空间里，直到读完N-1个字符，或者读完一行。 </div><div class="line"> </div><div class="line">注意：调用**fgets**函数时，最多只能读入n-1个字符。读入结束后，系统将自动在最后加&apos;\0&apos;，并以str作为函数值返回。  </div><div class="line"></div><div class="line">**fputs()**函数原型：`int fputs(const char *str, FILE *stream);`//我们平常可以这么使用：`fputs( str,stdout );`  </div><div class="line"></div><div class="line">其中str为数组首地址，stdout表示我们写入屏幕数据。 </div><div class="line"></div><div class="line">#### C 文件读写</div><div class="line">一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C语言不仅提供了访问顶层的函数，也提供了底层(OS)调用来处理存储设备上的文件。</div><div class="line"></div><div class="line">##### 打开文件</div><div class="line">可以使用`fopen()`函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型**FILE**的一个对象，类型**FILE**包含了所有用来控制流的必要的信息。下面是这个函数调用原型:</div></pre></td></tr></table></figure></p>
<p>FILE <em>fopen(const char </em>filename, const char *mode)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">**filename**是字符串，用来命名文件，访问模式**mode**的值可以是下列值中的一个： </div><div class="line"> </div><div class="line">模式| 描述</div><div class="line">-------|----------</div><div class="line">r | 打开一个已有的文本文件，允许读取文件</div><div class="line">w | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，程序会从文件的开头写入内容。</div><div class="line">a | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，程序会在已有的文件内容中追加内容。</div><div class="line">r+ | 打开一个文本文件，允许读写文件。</div><div class="line">w+ | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</div><div class="line">a+ | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式</div><div class="line"></div><div class="line">如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</div></pre></td></tr></table></figure></p>
<p>“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 关闭文件</div><div class="line">使用`fclose()`函数关闭文件。函数的原型如下：</div></pre></td></tr></table></figure></p>
<p>int fclose(FILE *fp);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">如果成功关闭文件，`fclose()` 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 `stdio.h` 中的常量。  </div><div class="line"></div><div class="line">C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。</div><div class="line">##### 写入文件</div><div class="line">把字符写入到流中的最简单的函数：</div></pre></td></tr></table></figure></p>
<p>int fputc(int c, FILE *fp);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数`fputc()`把参数c的字符值写入到fp所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回EOF。可以使用下面的函数来吧一个以null结尾的字符串写入流中：</div></pre></td></tr></table></figure></p>
<p>int fputs(const char <em>s, FILE </em>fp);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数 `fputs()` 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 `int fprintf(FILE *fp,const char *format, ...)` 函数来写把一个字符串写入到文件中。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main()<br>{<br>   FILE *fp = NULL;</p>
<p>   fp = fopen(“/tmp/test.txt”, “w+”);<br>   fprintf(fp, “This is testing for fprintf…\n”);<br>   fputs(“This is testing for fputs…\n”, fp);<br>   fclose(fp);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行。</div><div class="line"></div><div class="line">##### 读取文件</div><div class="line">从文件读取单个字符的最简单的函数：</div></pre></td></tr></table></figure></p>
<p>int fgetc(FILE *fp);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`fgetc()`函数从fp所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回EOF。  </div><div class="line">从流中读取一个字符串</div></pre></td></tr></table></figure></p>
<p>char <em>fgets(char </em>buf, int n, FILE *fp);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">函数`fgets()`函数从fp所指向的输入流中读取 **n - 1**个字符。它会把读取的字符串复制到缓冲区**buf**，并在最后追加一个null字符来终止字符串。  </div><div class="line">如果这个函数在读取最后一个字符之前就遇到一个换行符&apos;\n&apos;或文件的末尾EOF,则只会返回读取到的字符，包括换行符。也可以使用`int fscanf(FILE *fp, const char *format,...)`函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main()<br>{<br>   FILE *fp = NULL;<br>   char buff[255];</p>
<p>   fp = fopen(“/tmp/test.txt”, “r”);<br>   fscanf(fp, “%s”, buff);<br>   printf(“1: %s\n”, buff );</p>
<p>   fgets(buff, 255, (FILE*)fp);<br>   printf(“2: %s\n”, buff );</p>
<p>   fgets(buff, 255, (FILE*)fp);<br>   printf(“3: %s\n”, buff );<br>   fclose(fp);</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：</div></pre></td></tr></table></figure></p>
<p>1: This<br>2: is testing for fprintf…</p>
<p>3: This is testing for fputs…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">首先，`fscanf()`方法只读取了**This**，因为它在后边遇到了一个空格。其次，调用`fgets()`读取剩余的部分，直到行尾。最后，调用`fgets()`完整地读取第二行。</div><div class="line"></div><div class="line">##### 二进制 I/O 函数</div><div class="line">下面两个函数用于二进制输入和输出：</div></pre></td></tr></table></figure></p>
<p>size_t fread(void <em>ptr, size_t size_of_elements,<br>             size_t number_of_elements, FILE </em>a_file);</p>
<p>size_t fwrite(const void <em>ptr, size_t size_of_elements,<br>             size_t number_of_elements, FILE </em>a_file);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这两个函数都是用于存储块的读写 - 通常是数组或结构体。</div><div class="line"></div><div class="line">##### 笔记</div><div class="line">**fseek** 可以移动文件指针到指定位置读,或插入写:</div></pre></td></tr></table></figure></p>
<p>int fseek(FILE *stream, long offset, int whence);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">**fseek** 设置当前读写点到 **offset** 处, **whence** 可以是 `SEEK_SET,SEEK_CUR,SEEK_END` 这些值决定是从文件头、当前点和文件尾计算偏移量 **offset**。   </div><div class="line">你可以定义一个文件指针 FILE *fp,当你打开一个文件时，文件指针指向开头，你要指到多少个字节，只要控制偏移量就好，例如, 相对当前位置往后移动一个字节：fseek(fp,1,SEEK_CUR); 中间的值就是偏移量。 如果你要往前移动一个字节，直接改为负值就可以：fseek(fp,-1,SEEK_CUR)。</div><div class="line">执行以下实例前，确保当前目录下 test.txt 文件已创建：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main(){<br>    FILE *fp = NULL;<br>    fp = fopen(“test.txt”, “r+”);  // 确保 test.txt 文件已创建<br>    fprintf(fp, “This is testing for fprintf…\n”);<br>    fseek(fp, 10, SEEK_SET);<br>    if (fputc(65,fp) == EOF) {<br>        printf(“fputc fail”);<br>    }<br>    fclose(fp);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">执行结束后，打开text.txt文件：</div></pre></td></tr></table></figure></p>
<p>This is teAting for fprintf…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">**注意：**只有用 r+ 模式打开文件才能插入内容，w 或 w+ 模式都会清空掉原来文件的内容再来写，a 或 a+ 模式即总会在文件最尾添加内容，哪怕用 fseek() 移动了文件指针位置。</div><div class="line"></div><div class="line">#### C 预处理器  </div><div class="line">C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。  </div><div class="line">所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：  </div><div class="line"></div><div class="line">指令| 描述</div><div class="line">-------|----------</div><div class="line">`#define` | 定义宏</div><div class="line">`#include` | 包含一个源代码文件</div><div class="line">`#undef` | 取消已定义的宏</div><div class="line">`#ifdef` | 如果宏已定义，则返回真</div><div class="line">`#ifndef` | 如果宏没有定义，则返回真</div><div class="line">`#if` | 如果给定条件为真，则编译下面代码</div><div class="line">`#else` | `#if`的替代方案</div><div class="line">`#elif` | 如果前面的 `#if` 给定条件不为真，当前条件为真，则编译下面代码</div><div class="line">`#endif` | 结束一个 `#if……#else` 条件编译块</div><div class="line">`#error` | 当遇到标准错误时，输出错误信息</div><div class="line">`#pragma` | 使用标准化方法，向编译器发布特殊的命令到编译器中</div><div class="line"></div><div class="line">##### 预定义宏</div><div class="line">ANSI C 定义了许多宏。在编程中可以使用这些宏，但是不能直接修改这些预定义的宏。</div><div class="line"></div><div class="line">宏| 描述</div><div class="line">------- | ----------</div><div class="line">`__DATE__` | 当前日期，一个以“MMMM DD YYYY”格式表示的字符串常量</div><div class="line">`__TIME__` | 当前时间，一个以“HH:MM:SS”格式表示的字符创常量</div><div class="line">`__FILE__` | 这会包含当前文件名，一个字符串常量</div><div class="line">`__LINE__` | 这会包含当前行号，一个十进制常量</div><div class="line">`__STDC__` | 当编译器以ANSI标准编译时，则定义为1</div><div class="line">`__func__` | 当前函数名称</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main( )<br>{<br>    printf(“File :%s\n”, <strong>FILE</strong> );<br>    printf(“Date :%s\n”, <strong>DATE</strong> );<br>    printf(“Time :%s\n”, <strong>TIME</strong> );<br>    printf(“Line :%d\n”, <strong>LINE</strong> );<br>    printf(“ANSI :%d\n”, <strong>STDC</strong> );<br>    printf(“FUNC : %s\n”, <strong>func</strong>);<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码（在文件 **main.c** 中）被编译和执行时，它会产生下列结果：</div></pre></td></tr></table></figure></p>
<p>File :/Users/Macx/Desktop/HelloWorld/HelloWorld/main.c<br>Date :Mar 29 2018<br>Time :15:10:07<br>Line :16<br>ANSI :1<br>FUNC : main<br>Program ended with exit code: 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 预处理器运算符</div><div class="line">C 预处理器提供了下列的运算符来帮助您创建宏：  </div><div class="line">**宏延续运算符（\）**  </div><div class="line">一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</div></pre></td></tr></table></figure></p>
<p>#define  message_for(a, b)  \<br>    printf(#a “ and “ #b “: We love you!\n”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**字符串常量化运算符（#）**  </div><div class="line">在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#define  message_for(a, b)  \<br>    printf(#a “ and “ #b “: We love you!\n”)</p>
<p>int main(void)<br>{<br>   message_for(Carole, Debra);<br>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会产生下列结果：</div></pre></td></tr></table></figure></p>
<p>Carole and Debra: We love you!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**标记粘贴运算符（##）**  </div><div class="line">宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#define tokenpaster(n) printf (“token” #n “ = %d”, token##n)</p>
<p>int main(void)<br>{<br>   int token34 = 40;</p>
<p>   tokenpaster(34);<br>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会产生下列结果：</div></pre></td></tr></table></figure></p>
<p>token34 = 40<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</div></pre></td></tr></table></figure></p>
<p>printf (“token34 = %d”, token34);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**defined() 运算符**  </div><div class="line">预处理器 **defined** 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用过`#define`定义过。如果指定标识符已定义，则值为真(非零)。如果指定的标识符未定义，则值为假(零)。下面的实例演示了`defined`运算符的用法：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#if !defined (MESSAGE)</p>
<p>   #define MESSAGE “You wish!”</p>
<p>#endif</p>
<p>int main(void)<br>{<br>   printf(“Here is the message: %s\n”, MESSAGE);<br>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 参数化的宏</div><div class="line">CPP 一个强大的功能是可以使用参数化的宏来模拟函数。</div></pre></td></tr></table></figure></p>
<p>int square(int x) {<br>    return x * x;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我们可以使用宏重写上面的代码，如下：</div></pre></td></tr></table></figure></p>
<p>#define square(x) ((x) * (x))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。</div><div class="line"></div><div class="line">#### C 头文件 </div><div class="line">头文件的扩展名为.h的文件，包含了C函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。  </div><div class="line">在程序中要使用头文件，需要使用C预编译指令**#include**来引用它。</div><div class="line"></div><div class="line">##### 引用头文件的语法</div><div class="line">用C预编译指令**#include**可以引用用户和系统的头文件。它的形式有以下两种：</div></pre></td></tr></table></figure></p>
<p>#include <file><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为file的文件。</div></pre></td></tr></table></figure></file></p>
<p>#include “file”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为file的文件。</div><div class="line"></div><div class="line">##### 引用头文件的操作</div><div class="line">**#include**指令会指示C预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及**#include**指令之后的文本输出。例如，如果您有一个头文件 **header.h**，如下：</div></pre></td></tr></table></figure></p>
<p>char *test (void);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">和一个使用了头文件的主程序program.c,如下：</div></pre></td></tr></table></figure></p>
<p>int x </p>
<p>#include “header.h”</p>
<p>int main(void)<br>{<br>    puts(test());<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">编译器会看到如下的代码信息：</div></pre></td></tr></table></figure></p>
<p>int x;<br>char *test(void);</p>
<p>int main(void)<br>{<br>    puts(test());<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 只引用一次头文件</div><div class="line">如果一个头文件被引用了两次，编译器会处理两次文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下</div></pre></td></tr></table></figure></p>
<p>#ifndef HEADER_FILE</p>
<p>#define HEADER_FILE</p>
<p>the entire header file file</p>
<p>#endif<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这种结构就是通常听说的包装器 **ifndef** 。当再次引用头文件，条件为假，因为HEADER_FILE已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</div><div class="line"></div><div class="line">##### 有条件引用</div><div class="line">有时需要从多个不同的头文件中选择一个引用到程序。例如，需要指定操作系统上使用的配置参数，可以通过一系列条件来实现这点，如下：</div></pre></td></tr></table></figure></p>
<p>#if SYSTEM_1</p>
<pre><code>#include &quot;system_1.h&quot;
</code></pre><p>#elif SYSTEM_2</p>
<pre><code>#include &quot;system_2.h&quot;
</code></pre><p>#elif SYSTEM_3<br>    …</p>
<p>#endif<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：</div></pre></td></tr></table></figure></p>
<p> #define SYSTEM_H “system_1.h”<br> …</p>
<p> #include SYSTEM_H<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">`SYSTEM_H` 会扩展，预处理器会查找 `system_1.h`，就像 `#include` 最初编写的那样。`SYSTEM_H` 可通过 `-D` 选项被您的 **Makefile** 定义。</div><div class="line"></div><div class="line">##### 笔记</div><div class="line">在有多个 `.h` 文件和多个 `.c` 文件的时候，往往我们会用一个 `global.h` 的头文件来包括所有的 `.h` 文件，然后在除 `global.h` 文件外的头文件中 包含 `global.h` 就可以实现所有头文件的包含，同时不会乱。方便在各个文件里面调用其他文件的函数或者变量。</div></pre></td></tr></table></figure></p>
<p>#ifndef _GLOBAL_H</p>
<p>#define _GLOBAL_H</p>
<p>#include <fstream></fstream></p>
<p>#include <iostream></iostream></p>
<p>#include <math.h></math.h></p>
<p>#include <config.h><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### C 强制类型转换</div><div class="line">强制类型转换时把变量从一种类型转换为另一种类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用**强制类型转换运算符**来把值显式地从一种类型转换为另一种类型，如下所示：</div></pre></td></tr></table></figure></config.h></p>
<p>(type_name) expression;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如下面实例，使用强制类型转换运算符把一个整数变量除于另一个整数变量，得到一个浮点数：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main()<br>{<br>    int sum = 17, count = 5;<br>    double mean;</p>
<pre><code>mean = (double) sum / count;
printf(&quot;Value of mean : %f\n&quot;, mean);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，会产生下列的结果：</div></pre></td></tr></table></figure></p>
<p>Value of mean : 3.400000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">要注意的是强制类型转换运算符的优先级大于除法，因此sum的值首先被转换为double型，然后除于count，得到一个类型为double的值。  </div><div class="line">类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用**强制类型转换运算符**来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</div><div class="line"></div><div class="line">##### 整数提升</div><div class="line">整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main()<br>{<br>    int i = 17;<br>    char c = ‘c’; //ascii 值是 99<br>    int sum;</p>
<pre><code>sum = i + c;
printf(&quot;Value of sum: %d\n&quot;, sum);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果：</div></pre></td></tr></table></figure></p>
<p>Value of sum : 116<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在这里，sum的值为116，因为编译器进行了整数的提升，在执行实际加法运算时，把&apos;c&apos;的值转换为ascii值。</div><div class="line"></div><div class="line">##### 常用的算术转换</div><div class="line">常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</div></pre></td></tr></table></figure></p>
<p>int<br> ↓<br>unsigned int<br> ↓<br>long<br> ↓<br>unsigned long<br> ↓<br>long long<br> ↓<br>unsigned long long<br> ↓<br>double ← float<br> ↓<br>long double<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">常用的算术转换不适用于赋值运算符、逻辑运算符 &amp;&amp; 和 ||。让我们看看下面的实例来理解这个概念：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>main()<br>{<br>   int  i = 17;<br>   char c = ‘c’; /<em> ascii 值是 99 </em>/<br>   float sum;</p>
<p>   sum = i + c;<br>   printf(“Value of sum : %f\n”, sum );</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果：</div></pre></td></tr></table></figure></p>
<p>Value of sum : 116.000000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">在这里，c 首先被转换为整数，但是由于最后的值是 double 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。</div><div class="line"></div><div class="line">#### C 错误处理  </div><div class="line">C 语言不提供对错误处理的直接支持，但作为一种系统的编程语言，它以返回值的形式允许访问底层数据。在发生错误时，大多数的C 或 UNIX 函数调用返回一个错误码**errno**,该错误代码是全局变量，表示在函数调用期间发生了错误。可以在**&lt;error.h&gt;**头文件中找到各种各样的错误代码。  </div><div class="line">所以，C程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把**errno**设置为0，这是一种良好的编程习惯。0值表示程序中没有错误。  </div><div class="line"></div><div class="line">##### errno、 perror() 和 strerror()</div><div class="line">C语言提供了`perror()`和`strerror()`函数来显示与**errno**相关的文本消息 </div><div class="line"> </div><div class="line">* `perror()`函数显示传给它的字符串，后跟一个冒号、一个空格和当前**errno**值的文本表示形式</div><div class="line">* `strerror()`函数返回一个指针，指针指向当前**errno**值的文本表示形式</div><div class="line"></div><div class="line">模拟一种错误情况，尝试打开一个不存在的文件。可以使用多种方式来输出错误信息，这里使用函数来演示用法。另外有一点需要注意，您应该使用 **stderr** 文件流来输出所有的错误。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <errno.h></errno.h></p>
<p>#include <string.h></string.h></p>
<p>extern int errno;</p>
<p>int main()<br>{<br>    FILE *pf;<br>    int errnum;<br>    pf = fopen(“unexist.txt”, “rb”);<br>    if (pf == NULL)<br>    {<br>        errnum =  errno;<br>        fprintf(stderr, “错误号：%d\n”, errno);<br>        perror(“通过 perror 输出错误”);<br>        fprintf(stderr, “打开文件错误：%s\n”,strerror( errnum ));<br>    }else {<br>        fclose(pf);<br>    }<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果：</div></pre></td></tr></table></figure></p>
<p>错误号: 2<br>通过 perror 输出错误: No such file or directory<br>打开文件错误: No such file or directory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 被零除的错误</div><div class="line">在进行除法运算时，如果不检查除数是否为0，则会导致一个运行错误。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>main()<br>{<br>   int dividend = 20;<br>   int divisor = 0;<br>   int quotient;</p>
<p>   if( divisor == 0){<br>      fprintf(stderr, “除数为 0 退出运行…\n”);<br>      exit(-1);<br>   }<br>   quotient = dividend / divisor;<br>   fprintf(stderr, “quotient 变量的值为 : %d\n”, quotient );</p>
<p>   exit(0);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 程序退出状态</div><div class="line"></div><div class="line">通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。   </div><div class="line">如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>main()<br>{<br>   int dividend = 20;<br>   int divisor = 5;<br>   int quotient;</p>
<p>   if( divisor == 0){<br>      fprintf(stderr, “除数为 0 退出运行…\n”);<br>      exit(EXIT_FAILURE);<br>   }<br>   quotient = dividend / divisor;<br>   fprintf(stderr, “quotient 变量的值为: %d\n”, quotient );</p>
<p>   exit(EXIT_SUCCESS);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### C 递归</div><div class="line">递归指的是在函数的定义中使用函数自身的方法。  </div><div class="line">语法格式如下：</div></pre></td></tr></table></figure></p>
<p>void recursion()<br>{<br>    statements;<br>    … … …<br>    recursion(); //函数调用自身<br>}</p>
<p>int main()<br>{<br>    recursion();<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。  </div><div class="line">递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等。  </div><div class="line"></div><div class="line">##### 数的阶乘</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>double factorial(unsigned int i)<br>{<br>   if(i &lt;= 1)<br>   {<br>      return 1;<br>   }<br>   return i * factorial(i - 1);<br>}<br>int  main()<br>{<br>    int i = 15;<br>    printf(“%d 的阶乘为 %f\n”, i, factorial(i));<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 斐波那契数列</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int fibonaci(int i)<br>{<br>   if(i == 0)<br>   {<br>      return 0;<br>   }<br>   if(i == 1)<br>   {<br>      return 1;<br>   }<br>   return fibonaci(i-1) + fibonaci(i-2);<br>}</p>
<p>int  main()<br>{<br>    int i;<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>       printf(“%d\t\n”, fibonaci(i));<br>    }<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 笔记</div><div class="line">递归是一个简洁的概念，同时也是一种很有用的手段。但是，使用递归是要付出代价的。与直接的语句(如while循环)相比，递归函数会耗费更多的运行时间，并且要占用大量的栈空间。递归函数每次调用自身时，都需要把它的状态存到栈中，以便在它调用完自身后，程序可以返回到它原来的状态。未经精心设计的递归函数总是会带来麻烦。</div><div class="line"></div><div class="line">#### C 可变参数  </div><div class="line">C语言提供了一种允许定义一个函数，能根据具体的需求接受可变数量的参数。</div></pre></td></tr></table></figure></p>
<p>int func(int, … )<br>{<br>   .<br>   .<br>   .<br>}</p>
<p>int main()<br>{<br>   func(2, 2, 3);<br>   func(3, 2, 3, 4);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">注意：函数**func()**最后一个参数写成省略号，即三个点号(...),省略号之前的那个参数**int**，代表了要传递的可变参数的总数。为了使用这个功能，需要使用**stdarg.h**头文件，该文件提供实现可变参数功能的函数和宏。  </div><div class="line"></div><div class="line">* 定义一个函数，最后一个参数为省略号，省略号前可以设置自定义参数。</div><div class="line">* 在函数定义中创建一个**va_list**类型的变量，该类型是在**stdarg.h**头文件中定义的。</div><div class="line">* 使用**int**参数和**va_start**宏来初始化**va_list**变量为一个参数列表。宏**va_start**是在**stdarg.h**头文件中定义的。</div><div class="line">* 使用**va_arg**宏和**va_list**变量来访问参数列表中的每个项。</div><div class="line">* 使用**va_end**来清理赋予**va_list**变量的内存。</div><div class="line"></div><div class="line">编写一个带有可变数量参数的函数，并返回它们的平均值:</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdarg.h></stdarg.h></p>
<p>double average(int num,…)<br>{<br>    va_list valist;<br>    double sum = 0.0;<br>    int i;</p>
<pre><code>//为num个参数初始化 valist
va_start(valist,num);

//访问所有赋给valist的参数
for(i = 0; i &lt; num; i ++)
{
    sum += va_arg(valist, int);
}
//清理为valist保留的内存
va_end(valist);

return sum / num;
</code></pre><p>}</p>
<p>int main()<br>{<br>    printf(“Average of 2, 3, 4, 5 = %f\n”, average(4, 2, 3, 4, 5));<br>    printf(“Average of 5, 10, 15 = %f\n”, average(3, 5, 10, 15));<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 average() 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。</div></pre></td></tr></table></figure></p>
<p>Average of 2, 3, 4, 5 = 3.500000<br>Average of 5, 10, 15 = 10.000000;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### C 内存管理</div><div class="line">C 语言为内存的分配和管理提供了几个函数。这些函数可以在`&lt;stdlib.h&gt;`头文件中找到。</div><div class="line"></div><div class="line">序号 | 函数和描述</div><div class="line">------ | ------------</div><div class="line">1 | `void *calloc(int num,int size);` &lt;/br&gt;在内存中动态地分配num个长度为size的连续空间，并将每一个字节都初始化为0。所以它的结果是分配了`num*size`个字节长度的内存空间，并且每个字节的值都是0.</div><div class="line">2 | `void free(void *address);` &lt;/br&gt;该函数释放**address**所指向的内存块，释放的是动态分配的内存空间。</div><div class="line">3 | `void *malloc(int num);` &lt;/br&gt;在堆区分配一块指定大小的内存空间，用来存储数据。这块内存空间在函数执行完成后不会被初始化，他们的值是未知的。</div><div class="line">4 | `void *realloc(void *address, int newsize)` &lt;/br&gt;该函数重新分配内存，把内存扩展到newsize。</div><div class="line"></div><div class="line">##### 动态分配内存</div><div class="line">编程时，如果预先知道数组的大小，那么定义数组时比较容易。例如，一个存储人名的数组，它最多容纳100个字符，所以可以定义数组，如下所示：</div></pre></td></tr></table></figure></p>
<p>char name[100];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">但是，如果预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <string.h></string.h></p>
<p>int main()<br>{<br>    char name[100];<br>    char *description;</p>
<pre><code>strcpy(name, &apos;Zara Ali&apos;);

//动态分配内存
description = malloc(200 * sizeof(char));
if(description == NULL){
    fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);
}else {
    strcpy(description, &quot;Zara ali a DPS student in class 10th&quot;);
}
printf(&quot;Name = %s\n&quot;, name);
printf(&quot;Description : %s\n&quot;, description);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当上面的代码被编译时，它会产生下列的结果</div></pre></td></tr></table></figure></p>
<p>Name = Zara Ali<br>Description: Zara ali a DPS student in class 10th<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</div></pre></td></tr></table></figure></p>
<p>calloc(200, sizeof(char));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</div><div class="line"></div><div class="line">##### 重新调整内存的大小和释放内存</div><div class="line">程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议在不需要内存时，都应该调用函数`free()`来释放内存。或者可以通过调用函数`realloc()`来增加或减少已分配的内存块的大小。</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <string.h></string.h></p>
<p>int main()<br>{<br>   char name[100];<br>   char *description;</p>
<p>   strcpy(name, “Zara Ali”);</p>
<p>   /<em> 动态分配内存 </em>/<br>   description = malloc( 30 <em> sizeof(char) );<br>   if( description == NULL )<br>   {<br>      fprintf(stderr, “Error - unable to allocate required memory\n”);<br>   }<br>   else<br>   {<br>      strcpy( description, “Zara ali a DPS student.”);<br>   }<br>   /</em> 假设您想要存储更大的描述信息 <em>/<br>   description = realloc( description, 100 </em> sizeof(char) );<br>   if( description == NULL )<br>   {<br>      fprintf(stderr, “Error - unable to allocate required memory\n”);<br>   }<br>   else<br>   {<br>      strcat( description, “She is in class 10th”);<br>   }</p>
<p>   printf(“Name = %s\n”, name );<br>   printf(“Description: %s\n”, description );</p>
<p>   /<em> 使用 free() 函数释放内存 </em>/<br>   free(description);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果：</div></pre></td></tr></table></figure></p>
<p>Name = Zara Ali<br>Description: Zara ali a DPS student.She is in class 10th<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。  </div><div class="line"></div><div class="line">#### C 命令行参数</div><div class="line">执行程序时，可以从命令行传值给C程序。这些值被称为**命令行参数**,他们对程序很重要，特别是想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。  </div><div class="line">命令行参数是使用`main()`函数的参数来处理的，其中，**argc**是指传入参数的个数，**argv[]**是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否提供参数，并根据参数执行相应的动作:</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main(int argc, char *argv[])<br>{<br>    if(argc == 2){<br>        printf(“The argument supplied is %s\n”, argv[1]);<br>    }else if (argc &gt; 2) {<br>        printf(“Too many arguments supplied.\n”);<br>    }else {<br>        printf(“One argument expected.\n”)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用一个参数，编译并执行上面的代码，它会产生下列结果：</div></pre></td></tr></table></figure></p>
<p>$./a.out testing<br>The argument supplied is testing<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用两个参数，编译并执行上面的代码，它会产生下列结果：</div></pre></td></tr></table></figure></p>
<p>$./a.out testing1 testing2<br>Too many arguments supplied.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不传任何参数，编译并执行上面的代码，它会产生下列结果：</div></pre></td></tr></table></figure></p>
<p>$./a.out<br>One argument expected<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">应当指出的是，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。  </div><div class="line">多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 &quot;&quot; 或单引号 &apos;&apos; 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号&quot;&quot;&quot;&quot;。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h></stdio.h></p>
<p>int main( int argc, char *argv[] )<br>{<br>   printf(“Program name %s\n”, argv[0]);</p>
<p>   if( argc == 2 )<br>   {<br>      printf(“The argument supplied is %s\n”, argv[1]);<br>   }<br>   else if( argc &gt; 2 )<br>   {<br>      printf(“Too many arguments supplied.\n”);<br>   }<br>   else<br>   {<br>      printf(“One argument expected.\n”);<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果：</div></pre></td></tr></table></figure></p>
<p>$./a.out “testing1 testing2”</p>
<p>Progranm name ./a.out<br>The argument supplied is testing1 testing2<br>```</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/04/小知识点3/" rel="next" title="小知识点3">
                <i class="fa fa-chevron-left"></i> 小知识点3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments"></div>
    
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='/lib/Valine.min.js'></script>
    <script>
        new Valine({
            av: AV,
            el: '.comments' ,
            verify: true,
            app_id: 'QOVnk3YjdW9xkwvrI6zUvQ9B-gzGzoHsz',
            app_key: 'qQFkxfC0d1DeinWAf6e3gm11',
            placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!'
        });
    </script>
    

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oui2ar2u7.bkt.clouddn.com/Roronoa_Zoro.png"
               alt="Kerwin" />
          <p class="site-author-name" itemprop="name">Kerwin</p>
           
              <p class="site-description motion-element" itemprop="description">iOS 学习总结 思考感悟 知识管理</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-常量"><span class="nav-number">1.</span> <span class="nav-text">C 常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-存储类"><span class="nav-number">2.</span> <span class="nav-text">C 存储类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#auto-存储类"><span class="nav-number">2.1.</span> <span class="nav-text">auto 存储类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#register-存储类"><span class="nav-number">2.2.</span> <span class="nav-text">register 存储类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static-存储类"><span class="nav-number">2.3.</span> <span class="nav-text">static 存储类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#extern-存储类"><span class="nav-number">2.4.</span> <span class="nav-text">extern 存储类</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kerwin</span>
</div>


<div class="powered-by">
   个人专属
</div>

<div class="theme-info">
  博客 - Kerwin
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("QOVnk3YjdW9xkwvrI6zUvQ9B-gzGzoHsz", "qQFkxfC0d1DeinWAf6e3gm11");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

</body>
</html>
