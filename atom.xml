<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kerwin</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-19T13:58:57.130Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kerwin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题二</title>
    <link href="http://yoursite.com/2017/10/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/10/19/面试题二/</id>
    <published>2017-10-19T13:10:15.000Z</published>
    <updated>2017-10-19T13:58:57.130Z</updated>
    
    <content type="html"><![CDATA[<p>1.OC的理解与特性    </p><blockquote><ul><li>OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言。  </li><li>Objective-C具有相当多的动态特性，表现为三方面：动态类型（Dynamic typing）、动态绑定（Dynamic binding）和动态加载（Dynamic loading）。动态——必须到运行时（run time）才会做的一些事情。  <ul><li>动态类型：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单来说就是id类型。事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛。静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。  </li><li>动态绑定：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对应的属性和响应消息也被完全确定。  </li><li>动态加载：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retina设备上加载@2x的图片，而在老一些的普通苹设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类。</li></ul></li></ul></blockquote><p>2.简述内存管理基本原则  </p><blockquote><ul><li>之前：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建或引用一个对象的时候，需要向她发送alloc、copy、retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（MRC）。  </li><li>目前：iOS 5.0之后引用自动管理机制——自动引用计数（ARC），管理机制与手动机制一样，只是不再需要调用retain、release、autorelease；它编译时的特性，当你使用ARC时，在适当位置插入release和autorelease；它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。  </li><li>如果使用alloc、copy(mutableCopy)或者retian一个对象时,你就有义务,向它发送一条release或者autorelease消息。其他方法创建的对象,不需要由你来管理内存。（MRC）  </li><li>向一个对象发送一条autorelease消息,这个对象并不会立即销毁, 而是将这个对象放入了自动释放池,待池子释放时,它会向池中每一个对象发送 一条release消息,以此来释放对象. （MRC）  </li><li>向一个对象发送release消息,并不意味着这个对象被销毁了,而是当这个对象的引用计数为0时,系统才会调用dealloc方法,释放该对象和对象本身它所拥有的实例。（MRC） </li></ul><p><strong>其他注意事项 :</strong></p><ul><li>如果一个对象有一个strong类型的指针指向着，这个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil。如果一个指针被指向nil，那么它原来指向的对象就被释放了。当一个视图控制器被释放时，它内部的全局指针会被指向nil。用法：不管全局变量还是局部变量用strong描述就行。  </li><li>局部变量：出了作用域，指针会被置为nil。  </li><li>方法内部创建对象，外部使用需要添加_autorelease;  </li><li>连线的时候，用_weak描述。  </li><li>代理使用unsafe_unretained就相当于assign；  </li><li>block中为了避免循环引用问题，使用_weak描述；  </li><li>声明属性时，不要以new开头。如果非要以new开头命名属性的名字，需要自己定制get方法名，如<code>@property(getter=theString) NSString * newString;</code>   </li><li>如果要使用自动释放池，用@autoreleasepool{}  </li><li>ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成COre Foundation中的变量需要交换管理权；  </li><li>在非ARC工程中采用ARC去编译某些类：-fobjc-arc。  </li><li>在ARC下的工程采用非ARC去编译某些类：-fno-objc-arc。</li></ul></blockquote><p>3.如何理解MVC设计模式  </p><blockquote><p>MVC是一种架构模式，M表示MOdel，V表示视图View，C表示控制器Controller： </p><ul><li>Model负责存储、定义、操作数据；  </li><li>View用来展示书给用户，和用户进行操作交互；  </li><li>Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，MOdel也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，MOdel发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。  </li></ul></blockquote><p>4.如何理解MVVM设计模式  </p><blockquote><ul><li>ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。  </li><li>View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。  </li><li>如需了解更多，请查看<a href="https://www.teehanlax.com/blog/model-view-viewmodel-for-ios/" target="_blank" rel="external">这篇文章</a>。  </li></ul></blockquote><p>5.Objective-C 中是否支持垃圾回收机制？  </p><blockquote><ul><li>OC是支持垃圾回收机制的(Garbage collection简称GC),但是apple的移动终端中,是不支持GC的,Mac桌面系统开发中是支持的.  </li><li>移动终端开发是支持ARC（Automatic Reference Counting的简称）,ARC是在IOS5之后推出的新技术,它与GC的机制是不同的。我们在编写代码时, 不需要向对象发送release或者autorelease方法,也不可以调用delloc方法,编译器会在合适的位置自动给用户生成release消息(autorelease),ARC的特点是自动引用技术简化了内存管理的难度.  </li></ul></blockquote><p>6.协议的基本概念和协议中方法默认为什么类型  </p><blockquote><ul><li>OC中的协议是一个方法列表,且多少有点相关。它的特点是可以被任何类使用(实现),但它并不是类(这里我们需要注意),自身不会实现这样方法, 而是又其他人来实现协议经常用来实现委托对象(委托设计模式)。如果一个类采用了一个协议,那么它必须实现协议中必须需要实现的方法,在协议中的方法默认是必须实现(@required),添加关键字@optional,表明一旦采用该协议,这些“可选”的方法是可以选择不实现的。</li></ul></blockquote><p>7.简述类目category优点和缺点  </p><blockquote><p>优点： </p><ul><li>不需要通过增加子类而增加现有类的行为(方法),且类目中的方法与原始类方法基本没有区别;  </li><li>通过类目可以将庞大一个类的方法进行划分,从而便于代码的日后的维护、更新以及提高代码的阅读性;</li></ul><p>缺点：  </p><ul><li>无法向类目添加实例变量,如果需要添加实例变量,只能通过定义子类的方式;</li><li>类目中的方法与原始类以及父类方法相比具有更高优先级,如果覆盖父类的方法,可能导致super消息的断裂。因此,最好不要覆盖原始类中的方法。  </li></ul></blockquote><p>8.类别的作用  </p><blockquote><ul><li>给系统原有类添加方法，不能扩展属性。如果类别中方法的名字跟系统的方法名一样，在调用的时候类别中的方法优先级更高；  </li><li><p>分散类的实现如：<br><code>+ (NSIndexPath *)indexPathForRow:(NSInteger)row inSection:(NSInteger)section</code><br>原本属于NSIndexPath的方法，但因为这个方法经常使用的表的时候调用、跟表的关系特别密切，因此把这个方法一类别的形式、声明在UITableView.h中。</p></li><li><p>声明私有方法，某一个方法只实现，不声明，相当于私有方法。  </p></li><li>类别不能声明变量，类别不可以直接添加属性。property描述setter方法，就不会报错。</li></ul></blockquote><p>9.循环引用的产生原因，以及解决方法  </p><blockquote><ul><li><p>产生原因：如下图所示，对象A和对象B相互引用了对方作为自己的成员变量，只有自己销毁的时候才能将成员变量的引用计数减1。对象A的销毁依赖于对象B的销毁，同时对象B销毁也依赖与对象A的销毁，从而形成循环引用，此时，即使外界没有任何指针访问它，它也无法释放。<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458636240331049.png" alt=""><br>多个对象间依然会存在循环引用问题，形成一个环，在编程中，形成的环越大越不容易察觉，如下图所示：<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458636212752528.png" alt=""><br>解决方法：</p></li><li><p>事先知道存在循环引用的地方，在合理的位置主动断开一个引用，是对象回收；  </p></li><li>使用<a href="https://www.tuicool.com/articles/NVNrMv7" target="_blank" rel="external">弱引用</a>的方法。  </li></ul></blockquote><p>10.键路径(keyPath)、键值编码（KVC）和键值观察（KVO） </p><blockquote><p>键路径</p><ul><li>在一个给定的实体中,同一个属性的所有值具有相同的数据类型。</li><li>键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。 - 键路径是一个由用点作分隔符的键组成的字符串,用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的,接下来每个键的值也是相对于其前面的性质。</li><li>键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径,您可以指定对象图中的一个任意深度的路径,使其指向相关对象的特定属性。 </li></ul><p>键值编码KVC </p><ul><li>键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码；</li><li>KVC的缺点：一旦使用 KVC 你的编译器无法检查出错误,即不会对设置的键、键路径进行错误检查,且执行效率要低于合成存取器方法和自定的 setter 和 getter 方法。因为使用 KVC 键值编码,它必须先解析字符串,然后在设置或者访问对象的实例变量。 </li></ul><p>键值观察KVO</p><ul><li>键值观察机制是一种能使得对象获取到其他对象属性变化的通知 ，极大的简化了代码。</li><li>实现 KVO 键值观察模式,被观察的对象必须使用 KVC 键值编码来修 改它的实例变量,这样才能被观察者观察到。因此,KVC是KVO的基础。<br>Demo(自定义的一个button)  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"highlighted"</span> options:<span class="number">0</span> context:<span class="literal">nil</span>]; </div><div class="line"><span class="meta">#pragma mark KVO </span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"highlighted"</span>] ) &#123; </div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay]; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</p></blockquote><p>11.KVC机制通过key找到value的原理。  </p><blockquote><ul><li>当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过下面几种不同的方式解析这个调用。</li><li>首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。</li><li>补充：KVC查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。</li><li>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。</li></ul></blockquote><p>12.在 Objective-C 中如何实现 KVO  </p><blockquote><ul><li>注册观察者(注意：观察者和被观察者不会被保留也不会被释放)</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure><ul><li>接收变更通知  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure><ul><li>移除对象的观察者身份  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure><ul><li>KVO中谁要监听谁注册，然后对响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性名都是通过NSString来查找，编译器不会检错和补全，全部取决于自己。  </li></ul></blockquote><p>13.代理的作用  </p><blockquote><ul><li>代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性。</li><li>改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</li><li>另外一点，代理可以理解为java中的回调监听机制的一种类似。</li><li>代理的属性常是assign的原因：防止循环引用,以至对象无法得到正确的释放。  </li></ul></blockquote><p>14.NSNotification、Block、Delegate和KVO的区别。  </p><blockquote><ul><li>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；</li><li>效率：Delegate比NSNOtification高；</li><li>Delegate和Block一般是一对一的通信；</li><li>Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；</li><li>Block：Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；</li></ul></blockquote><p>15.Objective-C中可修改和不可以修改类型  </p><blockquote><ul><li>可修改不可修改的集合类，就是可动态添加修改和不可动态添加修改。</li><li>比如NSArray和NSMutableArray,前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间  </li></ul></blockquote><p>16.当我们调用一个静态方法时,需要对对象进行 release 吗?  </p><blockquote><ul><li>不需要,静态方法(类方法)创建一个对象时,对象已被放入自动释放池。在自动释放池被释放时,很有可能被销毁。  </li></ul></blockquote><p>17.当我们释放我们的对象时,为什么需要调用[super dealloc]方法,它的位置又是如何的呢?  </p><blockquote><ul><li>因为子类的某些实例是继承自父类的,因此需要调用[super dealloc]方法, 来释放父类拥有的实例,其实也就是子类本身的。一般来说我们优先释放子类拥 有的实例,最后释放父类所拥有的实例</li></ul></blockquote><p>18.对谓词的认识</p><blockquote><p>Cocoa 中提供了一个NSPredicate的类,该类主要用于指定过滤器的条件, 每一个对象通过谓词进行筛选,判断条件是否匹配。<a href="http://www.cocoachina.com/ios/20160111/14926.html" target="_blank" rel="external">iOS中的谓词（NSPredicate）使用</a>  </p></blockquote><p>19.static、self、super关键字的作用  </p><blockquote><ul><li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值.</li><li>在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问.</li><li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明.</li><li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝.</li><li>self:当前消息的接收者。</li><li>super:向父类发送消息。</li></ul></blockquote><p>20.#include与#import的区别，#import 与@class 的区别  </p><blockquote><ul><li><code>#include</code> 和<code>#impor</code>t其效果相同,都是查询类中定义的行为(方法);</li><li><code>#import</code>不会引起交叉编译,确保头文件只会被导入一次；</li><li><code>@class</code> 的表明,只定 义了类的名称,而具体类的行为是未知的,一般用于.h 文件；</li><li><code>@class</code> 比<code>#import</code>编译效率更高。</li><li>此外<code>@class</code>和<code>#import</code>的主要区别在于解决引用死锁的问题。</li></ul></blockquote><p>21.@public、@protected、@private 它们的含义与作用  </p><blockquote><ul><li>@public:对象的实例变量的作用域在任意地方都可以被访问 ;</li><li>@protected:对象的实例变量作用域在本类和子类都可以被访问 ;</li><li>@private:实例变量的作用域只能在本类(自身)中访问 .</li></ul></blockquote><p>22.解释 id 类型</p><blockquote><ul><li>任意类型对象，程序运行时才决定对象的类型。</li></ul></blockquote><p>23.switch 语句 if 语句区别与联系  </p><blockquote><ul><li>均表示条件的判断,switch语句表达式只能处理的是整型、字符型和枚举类型,而选择流程语句则没有这样的限制。但switch语句比选择流程控制语句效率更高。</li></ul></blockquote><p>24.isMemberOfClass 和 isKindOfClass 联系与区别  </p><blockquote><ul><li>联系：两者都能检测一个对象是否是某个类的成员</li><li>区别：isKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员 ,而isMemberOfClass 只能做到第一点。</li><li>举例：如 ClassA派 生 自NSObject 类 , ClassA *a = [ClassA alloc] init];,[a isKindOfClass:[NSObject class]] 可以检查出 a 是否是 NSObject派生类 的成员,但 isMemberOfClass 做不到。  </li></ul></blockquote><p>25.iOS 开发中数据持久性有哪几种?  </p><blockquote><p>数据存储的核心都是写文件。</p><ul><li>属性列表：只有NSString、NSArray、NSDictionary、NSData可writeToFile；存储依旧是plist文件。plist文件可以存储的7种数据类型：array、dictionary、string、bool、data、date、number。</li><li>对象序列化（对象归档）：对象序列化通过序列化的形式，键值关系存储到本地，转化成二进制流。通过runtime实现自动化归档/解档，实现NSCoding协议必须实现的两个方法：<br>1.编码（对象序列化）：把不能直接存储到plist文件中得到数据，转化为二进制数据，NSData，可以存储到本地；<br>2.解码（对象反序列化）：把二进制数据转化为本来的类型。  </li><li>SQLite 数据库：大量有规律的数据使用数据库。</li><li>CoreData ：通过管理对象进行增、删、查、改操作的。它不是一个数据库，不仅可以使用SQLite数据库来保持数据，也可以使用其他的方式来存储数据。如：XML。 </li></ul><p>CoreData的介绍： </p><ul><li>CoreData是面向对象的API，CoreData是iOS中非常重要的一项技术，几乎在所有编写的程序中，CoreData都作为数据存储的基础。</li><li>CoreData是苹果官方提供的一套框架，用来解决与对象声明周期管理、对象关系管理和持久化等方面相关的问题。</li><li>大多数情况下，我们引用CoreData作为持久化数据的解决方案，并利用它作为持久化数据映射为内存对象。提供的是对象-关系映射功能，也就是说，CoreData可以将Objective-C对象转换成数据，保存到SQL中，然后将保存后的数据还原成OC对象。  </li></ul><p>CoreData的特征：</p><ul><li>通过CoreData管理应用程序的数据模型，可以极大程度减少需要编写的代码数量。</li><li>将对象数据存储在SQLite数据库已获得性能优化。</li><li>提供NSFetchResultsController类用于管理表视图的数据，即将Core Data的持久化存储在表视图中，并对这些数据进行管理：增删查改。</li><li>管理undo/redo操纵；</li><li>检查托管对象的属性值是否正确。</li></ul></blockquote><p>26.Core Data的6成员对象</p><blockquote><ul><li>NSManageObject:被管理的数据记录Managed Object Model是描述应用程序的数据模型，这个模型包含实体（Entity）、特性（Property）、读取请求（Fetch Request）等。</li><li>NSManageObjectContext：管理对象上下文，持久性存储模型对象，参与数据对象进行各种操作的全过程，并监测数据对象的变化，以提供对undo/redo的支持及更新绑定到数据的UI。</li><li>NSPersistentStoreCoordinator:连接数据库的Persistent Store Coordinator相当于数据文件管理器，处理底层的对数据文件的读取和写入，一般我们与这个没有交集。</li><li>NSManagedObjectModel：被管理的数据模型、数据结构。</li><li>NSFetchRequest：数据请求；</li><li>NSEntityDescription：表格实体结构，还需知道.xcdatamodel文件编译后为.momd或者.mom文件。</li></ul></blockquote><p>27.Core Data的功能  </p><blockquote><ul><li>对于KVC和KVO完整且自动化的支持，除了为属性整合KVO和KVC访问方法外，还整合了适当的集合访问方法来处理多值关系；</li><li>自动验证属性（property）值；</li><li>支持跟踪修改和撤销操作；</li><li>关系维护，Core Data管理数据的关系传播，包括维护对象间的一致性；</li><li>在内存上和界面上分组、过滤、组织数据；</li><li>自动支持对象存储在外部数据仓库的功能；</li><li>创建复杂请求：无需动手写SQL语句，在获取请求（fetch request）中关联NSPredicate。NSPreadicate支持基本功能、相关子查询和其他高级的SQL特性。它支持正确的Unicode编码、区域感知查询、排序和正则表达式；</li><li>延迟操作：Core Data使用懒加载（lazy loading）方式减少内存负载，还支持部分实体化延迟加载和复制对象的数据共享机制；</li><li>合并策略：Core Data内置版本跟踪和乐观锁（optimistic locking）来支持多用户写入冲突的解决，其中，乐观锁就是对数据冲突进行检测，若冲突就返回冲突的信息；</li><li>数据迁移：Core Data的Schema Migration工具可以简化应对数据库结构变化的任务，在某些情况允许你执行高效率的数据库原地迁移工作；</li><li>可选择针对程序Controller层的集成，来支持UI的显示同步Core Data在IPhone OS之上，提供NSFetchedResultsController对象来做相关工作，在Mac OS X上我们用Cocoa提供的绑定（Binding）机制来完成的。  </li></ul></blockquote><p>28.对象可以被copy的条件  </p><blockquote><ul><li>只有实现了NSCopying和NSMutableCopying协议的类的对象才能被拷贝,分为不可变拷贝和可变拷贝,具体区别<a href="http://www.jianshu.com/p/f84803356cbb" target="_blank" rel="external">戳这里</a></li><li>NSCopying协议方法为：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</div><div class="line">  MyObject *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone: zone] init];</div><div class="line">  <span class="keyword">copy</span>.username = [<span class="keyword">self</span>.username copyWithZone:zone];</div><div class="line">  <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><p>29.自动释放池工作原理  </p><blockquote><ul><li>自动释放池是NSAutorelease类的一个实例,当向一个对象发送autorelease消息时,该对象会自动入池,待池销毁时,将会向池中所有对象发送一条release消息,释放对象。</li><li>[pool release]、 [pool drain]表示的是池本身不会销毁,而是池子中的临时对象都被发送release,从而将对象销毁。  </li></ul></blockquote><p>30.在某个方法中 <strong>self.name = _name</strong>，<strong>name = _name</strong> 它们有区别吗，为什么?</p><blockquote><ul><li>前者是存在内存管理的setter方法赋值,它会对<code>_name</code>对象进行保留或者拷贝操作</li><li>后者是普通赋值</li><li>一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写Setter方法来执行某些额外的工作。比如说，外部传一个模型过来，那么我会直接重写Setter方法，当模型传过来时，也就是意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI。  </li></ul></blockquote><p>31.解释self = [super init]方法  </p><blockquote><ul><li>容错处理,当父类初始化失败,会返回一个nil,表示初始化失败。由于继承的关系,子类是需要拥有父类的实例和行为,因此,我们必须先初始化父类,然后再初始化子类</li></ul></blockquote><p>32.定义属性时，什么时候用 assign、retain、copy 以及它们的之间的区别。  </p><blockquote><ul><li>assign:普通赋值,一般常用于基本数据类型,常见委托设计模式, 以此来防止循环引用。(我们称之为弱引用).</li><li>retain:保留计数,获得到了对象的所有权,引用计数在原有基础上加1.</li><li>copy:一般认为,是在内存中重新开辟了一个新的内存空间,用来 存储新的对象,和原来的对象是两个不同的地址,引用计数分别为1。但是当copy对象为不可变对象时,那么copy 的作用相当于retain。因为,这样可以节约内存空间</li></ul></blockquote><p>33.堆和栈的区别</p><blockquote><ul><li>栈区(stack)由编译器自动分配释放 ,存放方法(函数)的参数值, 局部变量的值等，栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的。</li><li>堆区(heap)一般由程序员分配释放, 若程序员不释放,程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活。</li><li>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出.</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</li><li>全局区(静态区)(static),全局变量和静态变量的存储是放在一块 的,初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放。</li><li>文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。</li><li>程序代码区—存放函数体的二进制代码</li></ul></blockquote><p>34.怎样使用performSelector传入3个以上参数，其中一个为结构体。</p><blockquote><p>因为系统提供的performSelector的API中，并没有提供三个参数。因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型,我们只能通过对象放入结构作为属性来传过去了.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector;</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object;</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object1 withObject:(<span class="keyword">id</span>)object2;</div></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> HYBStruct &#123;</div><div class="line"><span class="keyword">int</span> a;</div><div class="line"><span class="keyword">int</span> b;</div><div class="line">&#125; *my_struct;</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HYBObject</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) my_struct arg3;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *arg1;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *arg2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HYBObject</span></span></div><div class="line"><span class="comment">// 在堆上分配的内存，我们要手动释放掉</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">free(<span class="keyword">self</span>.arg3);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">my_struct str = (my_struct)(malloc(<span class="keyword">sizeof</span>(my_struct)));</div><div class="line">str-&gt;a = <span class="number">1</span>;</div><div class="line">str-&gt;b = <span class="number">2</span>;</div><div class="line">HYBObject * obj = [[HYBObject alloc] init];</div><div class="line">obj.arg1 = <span class="string">@"arg1"</span>;</div><div class="line">obj.arg2 = <span class="string">@"arg2"</span>;</div><div class="line">obj.arg3 = str; </div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(call:) withObject:obj];</div><div class="line"><span class="comment">// 在回调时得到正确的数据的</span></div><div class="line">-(<span class="keyword">void</span>)call:(HYBObject *)obj &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d %d"</span>, obj.arg3-&gt;a, obj.arg3-&gt;b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><p>35.UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</p><blockquote><p>这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：</p><ul><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li><li>UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode</li><li>UIInitializationRunLoopMode：run loop启动时，会切换到该mode</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合  </li></ul><p><strong>苹果公开提供的Mode有两个：</strong></p><ul><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）  </li><li>在编程中：如果我们把一个NSTimer对象NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。</li></ul></blockquote><p>36.对于单元格重用的理解  </p><blockquote><ul><li>当屏幕上滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，若有，就直接用，没有就重新创建一个。  </li></ul></blockquote><p>37.解决cell重用的问题</p><blockquote><ul><li>UITableView通过重用单元格来达到节省内存的目的，通过为每个单元格指定一个重用标示（reuseidentifier），即指定了单元格的种类，以及当单元格滚出屏幕时，允许恢复单元格以便复用。对于不同种类的单元格使用不同的ID，对于简单的表格，一个标示符就够了。</li><li>如一个TableView中有10个单元格，但屏幕最多显示4个，实际上iPhone只为其分配4个单元格的内存，没有分配10个，当滚动单元格时，屏幕内显示的单元格重复使用这4个内存。实际上分配的cell的个数为屏幕最大显示数，当有新的cell进入屏幕时，会随机调用已经滚出屏幕的Cell所占的内存，这就是Cell的重用。</li><li>对于多变的自定义Cell，这种重用机制会导致内容出错，为解决这种出错的方法，把原来的<code>UITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:defineString];</code>修改为：<code>UITableViewCell *cell = [tableview cellForRowAtIndexPath:indexPath];</code>,这样就解决掉cell重用机制导致的问题。</li></ul></blockquote><p>37.有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？  </p><blockquote><ul><li>对于这四个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务a */</span> &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务b */</span> &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务c */</span> &#125;); </div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务d */</span> &#125;); </div><div class="line">dispatch_group_notify(group,dispatch_get_main_queue(), ^&#123;</div><div class="line"><span class="comment">// 在a、b、c、d异步执行完成后，会回调这里</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>当然，我们还可以使用非常老套的方法来处理，通过四个变量来标识a、b、c、d四个任务是否完成，然后在runloop中让其等待，当完成时才退出runloop。但是这样做会让后面的代码得不到执行，直到Run loop执行完毕。</li><li>解释：要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了。  </li></ul></blockquote><p>38.使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码。  </p><blockquote><ul><li>代码紧凑，传值、回调都很方便，省去了写代理的很多代码。</li><li>NSTimer封装成的block，<a href="http://www.jianshu.com/p/1dbd7a228a22" target="_blank" rel="external">具体实现</a>。</li><li>实现方法：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES callback:^() &#123;</div><div class="line">  weakSelf.secondsLabel.text = ...</div><div class="line">&#125;</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure></blockquote><p>39.一个view已经初始化完毕，view上面添加了n个button，除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改button的值。  </p><blockquote><p>有2种方法解决：</p><ul><li>第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可。</li><li>第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找。  </li></ul></blockquote><p>40.线程与进程的区别和联系?  </p><blockquote><ul><li>一个程序至少要有进程,一个进程至少要有一个线程。</li><li>进程:资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li><li>线程:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。</li><li>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</li><li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li><li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。  </li></ul></blockquote><p>41.多线程编程  </p><blockquote><ul><li>NSThread:当需要进行一些耗时操作时会把耗时的操作放到线程中。线程同步：多个线程同时访问一个数据会出问题，NSlock、线程同步块、@synchronized(self){}。</li><li>NSOperationQueue操作队列（不需考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation、BSBlockOperation、自定义Operation。创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到操作队列中时，默认会调用main方法。</li><li>GCD（`Grand Central Dispatch）宏大的中央调度，串行队列、并发队列、主线程队列；</li><li>同步和异步：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个。</li><li>串行和并行：串行是多个任务按一定顺序执行，并行是多个任务同时执行；</li><li>代码是在分线程执行，在主线程队列中刷新UI。  </li></ul><p><strong>多线程编程是防止主线程堵塞、增加运行效率的最佳方法。</strong>  </p><ul><li>Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法；</li><li>一个NSOperationQueue操作队列，相当于一个线程管理器，而非一个线程，因为你可以设置这个线程管理器内可以并行运行的线程数量等。</li><li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。</li><li>iPhoneOS下的主线程的堆栈大小是1M。第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力。  </li></ul></blockquote><p>42.定时器与线程的区别</p><blockquote><ul><li>定时器;可以执行多次，默认在主线程中。</li><li>线程：只能执行一次。</li></ul></blockquote><p>43.Apple设备尺寸和编程尺寸  </p><blockquote><p><img src="http://oui2ar2u7.bkt.clouddn.com/1458634713310033.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/1458634609615814.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/1458634677550676.png" alt="">  </p></blockquote><p>44.TCP和UDP的区别于联系  </p><blockquote><ul><li>TCP为传输控制层协议，为面向连接、可靠的、点到点的通信；</li><li>UDP为用户数据报协议，非连接的不可靠的点到多点的通信；</li><li>TCP侧重可靠传输，UDP侧重快速传输。  </li></ul></blockquote><p>45.TCP连接的三次握手  </p><blockquote><ul><li>第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN+RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次状态。  </li></ul></blockquote><p>46.Scoket连接和HTTP连接的区别  </p><blockquote><ul><li>HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</li><li>HTTP连接：短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPhone主要使用类NSURLConnection。</li><li>Socket连接：长连接，客户端跟服务器端直接使用Socket进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8K（理解为一个数据包大小）</li></ul></blockquote><p>47.HTTP协议的特点，关于HTTP请求GET和POST的区别  </p><blockquote><p>GET和POST的区别：</p><ul><li>HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。HTTP是一个属于应用层面向对象的协议，HTTP有两类报文：请求报文和响应报文。</li><li>HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。</li><li>HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。</li><li>GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有参数都拼接在地址后面），不适合传输大量数据（长度有限制，为1024个字节）。</li><li>GET提交、请求的数据会附在URL之后，即把数据放置在HTTP协议头中。以？分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母或数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。</li><li>POST请求：参数在请求数据区放着，相对GET请求更安全，并且数据大小没有限制。把提交的数据放置在HTTP包的包体中.</li><li>GET提交的数据会在地址栏显示出来，而POST提交，地址栏不会改变。  </li></ul><p><strong>传输数据的大小：</strong></p><ul><li>GET提交时，传输数据就会受到URL长度限制，POST由于不是通过URL传值，理论上书不受限。  </li></ul><p><strong>安全性：</strong></p><ul><li>POST的安全性要比GET的安全性高；</li><li>通过GET提交数据，用户名和密码将明文出现在URL上，比如登陆界面有可能被浏览器缓存。</li><li>HTTPS：安全超文本传输协议（Secure Hypertext Transfer Protocol），它是一个安全通信通道，基于HTTP开发，用于客户计算机和服务器之间交换信息，使用安全套结字层（SSI）进行信息交换，即HTTP的安全版。  </li></ul></blockquote><p>48.ASIHttpRequest、AFNetWorking之间的区别  </p><blockquote><ul><li>ASIHttpRequest功能强大，主要是在MRC下实现的，是对系统CFNetwork API进行了封装，支持HTTP协议的CFHTTP，配置比较复杂，并且ASIHttpRequest框架默认不会帮你监听网络改变，如果需要让ASIHttpRequest帮你监听网络状态改变，并且手动开始这个功能。</li><li>AFNetWorking构建于NSURLConnection、NSOperation以及其他熟悉的Foundation技术之上。拥有良好的架构，丰富的API及模块构建方式，使用起来非常轻松。它基于NSOperation封装的，AFURLConnectionOperation子类。</li><li>ASIHttpRequest是直接操作对象ASIHttpRequest是一个实现了NSCoding协议的NSOperation子类；AFNetWorking直接操作对象的AFHttpClient，是一个实现NSCoding和NSCopying协议的NSObject子类。</li><li>同步请求：ASIHttpRequest直接通过调用一个startSynchronous方法；AFNetWorking默认没有封装同步请求，如果开发者需要使用同步请求，则需要重写getPath:paraments:success:failures方法，对于AFHttpRequestOperation进行同步处理。</li><li>性能对比：AFNetworking请求优于ASIHttpRequest；  </li></ul></blockquote><p>49.XML数据解析方式各有什么不同，JSON解析有哪些框架？  </p><blockquote><ul><li>XML数据解析的两种解析方式：DOM解析和SAX解析；</li><li>DOM解析必须完成DOM树的构造，在处理规模较大的XML文档时就很耗内存，占用资源较多，读入整个XML文档并构建一个驻留内存的树结构（节点树），通过遍历树结构可以检索任意XML节点，读取它的属性和值，通常情况下，可以借助XPath查询XML节点；</li><li>SAX与DOM不同，它是事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或者一条指令时，程序就产生一个事件进行相应的处理，一边读取XML文档一边处理，不必等整个文档加载完才采取措施，当在读取解析过程中遇到需要处理的对象，会发出通知进行处理。因此，SAX相对于DOM来说更适合操作大的XML文档。</li><li>JSON解析：性能比较好的主要是第三方的JSONKIT和iOS自带的JSON解析类，其中自带的JSON解析性能最高，但只能用于iOS5之后。</li></ul></blockquote><p>50.如何进行真机调试？  </p><blockquote><p>1.首先需要用钥匙串创建一个钥匙（key）；<br>2.将钥匙串上传到官网，获取iOS Development证书；<br>3.创建App ID即我们应用程序中的Boundle ID；<br>4.添加Device ID即UDID；<br>5.通过勾选前面所创建的证书：App ID、Device ID；<br>6.生成mobileprovision文件；<br>7.先决条件：申请开发者账号 99美刀  </p></blockquote><p>51.APP发布的上架流程  </p><blockquote><p>1.登录<a href="https://itunesconnect.apple.com/login" target="_blank" rel="external">应用发布网站</a>添加应用信息；<br>2.下载安装发布证书；<br>3.选择发布证书，使用Archive编译发布包，用Xcode将代码（发布包）上传到服务器；<br>4.等待审核通过;<br>5.生成IPA：菜单栏-&gt;Product-&gt;Archive.    </p></blockquote><p>52.SVN的使用  </p><blockquote><ul><li>SVN=版本控制+备份服务器，可以把SVN当成备份服务器，并且可以帮助你记住每次上服务器的档案内容，并自动赋予每次变更的版本；</li><li>SVN的版本控制：所有上传版本都会帮您记录下来，也有版本分支及合并等功能。SVN可以让不同的开发者存取同样的档案，并且利用SVN Server作为档案同步的机制，即您有档案更新时，无需将档案寄送给您的开发成员。SVN的存放档案方式是采用差异备份的方式，即会备份到不同的地方，节省硬盘空间，也可以对非文字文件进行差异备份。</li><li>SVN的重要性：备份工作档案的重要性、版本控管的重要性、伙伴间的数据同步的重要性、备份不同版本是很耗费硬盘空间的；</li><li>防止冲突：<br>1.防止代码冲突：不要多人同时修改同一文件，例如：A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改；<br>2.服务器上的项目文件Xcodeproj，仅让一个人管理提交，其他人只更新，防止文件发生冲突。  </li></ul></blockquote><p>53.如何进行网络消息推送  </p><blockquote><ul><li>一种是Apple自己提供的通知服务（APNS服务器）、一种是用第三方推送机制。</li><li>首先应用发送通知，系统弹出提示框询问用户是否允许，当用户允许后向苹果服务器(APNS)请求deviceToken，并由苹果服务器发送给自己的应用，自己的应用将DeviceToken发送自己的服务器，自己服务器想要发送网络推送时将deviceToken以及想要推送的信息发送给苹果服务器，苹果服务器将信息发送给应用。</li><li>推送信息内容，总容量不超过256个字节；</li><li>iOS SDK本身提供的APNS服务器推送，它可以直接推送给目标用户并根据您的方式弹出提示。<br>优点：不论应用是否开启，都会发送到手机端；<br>缺点：消息推送机制是苹果服务端控制，个别时候可能会有延迟，因为苹果服务器也有队列来处理所有的消息请求；  </li><li>第三方推送机制，普遍使用Socket机制来实现，几乎可以达到即时的发送到目标用户手机端，适用于即时通讯类应用。<br>优点：实时的，取决于心跳包的节奏；<br>缺点：iOS系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这种推送机制不可用.  </li></ul></blockquote><p>54.网络七层协议  </p><blockquote><ul><li>应用层：<br>1.用户接口、应用程序；<br>2.Application典型设备：网关；<br>3.典型协议、标准和应用：TELNET、FTP、HTTP. </li><li>表示层：<br>1.数据表示、压缩和加密presentation.<br>2.典型设备：网关.<br>3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG.<br>4.表示层相当于一个东西的表示，表示的一些协议，比如图片、声音和视频MPEG。    </li><li>会话层：<br>1.会话的建立和结束；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：RPC、SQL、NFS、X WINDOWS、ASP.   </li><li>传输层：<br>1.主要功能：端到端控制Transport；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：TCP、UDP、SPX  </li><li>网络层：<br>1.主要功能：路由、寻址Network；<br>2.典型设备：路由器；<br>3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP；  </li><li>数据链路层：<br>1.主要功能：保证无差错的疏忽链路的data link；<br>2.典型设备：交换机、网桥、网卡；<br>3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；  </li><li>物理层：<br>1.主要功能：传输比特流Physical；<br>2.典型设备：集线器、中继器.<br>3.典型协议、标准和应用：V.35、EIA/TIA-232.   </li></ul></blockquote><p>55.对NSUserDefaults的理解  </p><blockquote><ul><li>NSUserDefaults：系统提供的一种存储数据的方式，主要用于保存少量的数据，默认存储到library下的Preferences文件夹。  </li></ul></blockquote><p>56.SDWebImage原理</p><blockquote><p>调用类别的方法：</p><ul><li>从内存中（字典）找图片（当这个图片在本次程序加载过），找到直接使用；</li><li>从沙盒中找，找到直接使用，缓存到内存。</li><li>从网络上获取，使用，缓存到内存，缓存到沙盒。   </li></ul></blockquote><p>57.OC中是否有二维数组，如何实现二维数组？  </p><blockquote><ul><li>OC中没有二维数组，可通过嵌套数组实现二维数组。</li></ul></blockquote><p>58.LayoutSubViews在什么时候被调用？  </p><blockquote><ul><li>当View本身的frame改变时，会调用这个方法。  </li></ul></blockquote><p>59.深拷贝和浅拷贝  </p><blockquote><ul><li>如果对象有个指针型成员变量指向内存中的某个资源，那么如何复制这个对象呢？你会只是复制指针的值传给副本的新对象吗？指针只是存储内存中资源地址的占位符。在复制操作中，如果只是将指针复制给新对象，那么底层的资源实际上仍然由两个实例在共享。<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458633865626354.png" alt="">  </li><li>浅复制：两个实例的指针仍指向内存中的同一资源，只复制指针值而不是实际资源；</li><li>深复制：不仅复制指针值，还复制指向指针所指向的资源。如下图：<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458633819176042.png" alt=""></li></ul></blockquote><p>60.单例模式理解与使用  </p><blockquote><ul><li>单例模式是一种常用设计模式，单例模式是一个类在系统中只有一个实例对象。通过全局的一个入口点对这个实例对象进行访问；</li><li>iOS中单例模式的实现方式一般分为两种：非ARC和ARC+GCD。</li></ul></blockquote><p>61.对沙盒的理解  </p><blockquote><ul><li>每个iOS应用都被限制在“沙盒”中，沙盒相当于一个加了仅主人可见权限的文件夹，及时在应用程序安装过程中，系统为每个单独的应用程序生成它的主目录和一些关键的子目录。苹果对沙盒有几条限制:<br>1.应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序的沙盒；<br>2.应用之间不能共享数据，沙盒里的文件不能被复制到其他应用程序的文件夹中，也不能把其他应用文件夹复制到沙盒中；<br>3.苹果禁止任何读写沙盒以外的文件，禁止应用程序将内容写到沙盒以外的文件夹中；<br>4.沙盒目录里有三个文件夹：Documents——存储；应用程序的数据文件，存储用户数据或其他定期备份的信息；Library下有两个文件夹，Caches存储应用程序再次启动所需的信息,Preferences包含应用程序的偏好设置文件，不可在这更改偏好设置；temp存放临时文件即应用程序再次启动不需要的文件。  </li><li>获取沙盒根目录的方法，有几种方法：用NSHomeDirectory获取。</li><li>获取Document路径: <code>NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)</code>.  </li></ul></blockquote><p>62.对瀑布流的理解  </p><blockquote><ul><li>首先图片的宽度都是一样的，1.将图片等比例压缩，让图片不变形；2.计算图片最低应该摆放的位置，哪一列低就放在哪；3.进行最优排列，在ScrollView的基础上添加两个tableView，然后将之前所计算的scrollView的高度通过tableView展示出来。</li><li>如何使用两个TableView产生联动：将两个tableView的滚动事件禁止掉，最外层scrollView滚动时将两个TableView跟着滚动，并且更改contentOffset，这样产生效果滚动的两个tableView。 </li></ul></blockquote><p>63.ViewController 的 loadView、viewDidLoad、viewDidUnload 分别是在什么时候调用的？  </p><blockquote><ul><li>viewDidLoad在view从nib文件初始化时调用，loadView在controller的view为nil时调用。</li><li>此方法在编程实现view时调用,view控制器默认会注册memory warning notification,当view controller的任何view没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release,如果是retain的IBOutlet view 属性则不要在这里release,IBOutlet会负责release 。   </li></ul></blockquote><p>64.关键字volatile有什么含意?并给出三个不同的例子：</p><blockquote><ul><li>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：<br>1.并行设备的硬件寄存器（如：状态寄存器）；<br>2.一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)；<br>3.多线程应用中被几个任务共享的变量</li></ul></blockquote><p>65.@synthesize、@dynamic的理解  </p><blockquote><ul><li>@synthesize是系统自动生成getter和setter属性声明;@synthesize的意思是，除非开发人员已经做了，否则由编译器生成相应的代码，以满足属性声明；</li><li>@dynamic是开发者自已提供相应的属性声明,@dynamic意思是由开发人员提供相应的代码：对于只读属性需要提供setter，对于读写属性需要提供 setter 和getter。查阅了一些资料确定@dynamic的意思是告诉编译器,属性的获取与赋值方法由用户自己实现, 不自动生成。  </li></ul></blockquote><p>66.frame和bounds有什么不同？</p><blockquote><ul><li>frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）</li><li>bounds指的是：该view在本身坐标系统中的位置和大小。（参照点是本身坐标系统）</li></ul></blockquote><p>67.view的touch事件有哪些？  </p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event; </div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div></pre></td></tr></table></figure></blockquote><p>68.自定义实现UITabbarController的原理  </p><blockquote><ul><li>运用字典，点击五个按钮的一个可以从字典里选择一个控制器对象，将其View显示到主控制器视图上。</li></ul></blockquote><p>69.iOS中的响应者链的工作原理  </p><blockquote><ul><li>每一个应用有一个响应者链，我们的视图结构是一个N叉树(一个视图可以有多个子视图，一个子视图同一时刻只有一个父视图),而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点。</li><li>当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追朔出一条链，那么对于这一个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发。</li><li>如需了解更多细节，请读<a href="http://www.tuicool.com/articles/6VFn2q" target="_blank" rel="external">这篇文章</a>。  </li></ul></blockquote><p>70.View和View之间传值方式  </p><blockquote><ul><li>对象的property属性传值；</li><li>方法参数传值；</li><li>NSUserDefault传值；</li><li>块传值。  </li></ul></blockquote><p>71.property属性的修饰符的作用  </p><blockquote><ul><li>getter=getName、setter=setName：设置setter与getter的方法名；</li><li>readwrite、readonly：设置可供访问级别；</li><li>assign：方法直接赋值，不进行任何retain操作，为了解决原类型与环循引用问题；</li><li>retain：其setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序；</li><li>copy：其setter方法进行copy操作，与retain处理流程一样，先对旧值release，再copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。</li><li>nonatomic：非原子性访问，不加同步， 多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。  </li></ul></blockquote><p>72.对于Run Loop的理解  </p><blockquote><ul><li>RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；</li><li>每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；</li><li>在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；</li><li>NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；</li><li>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。  </li></ul></blockquote><p>73.SQLite中常用的SQL语句</p><blockquote><ul><li>创建表：creat table 表名 (字段名 字段数据类型 是否为主键, 字段名 字段数据类型, 字段名 字段数据类型…)；</li><li>增: insert into 表名 (字段1, 字段2…) values (值1, 值2…)；</li><li>删: delete from 表名 where 字段 = 值；</li></ul></blockquote><p>74.XIB与Storyboards的优缺点  </p><blockquote><p>优点：  </p><ul><li>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。</li><li>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。 </li></ul><p>缺点：</p><ul><li>XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。</li><li>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</li></ul></blockquote><p>75.将字符串“2015-04-10”格式化日期转为NSDate类型  </p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *timeStr = <span class="string">@"2015-04-10"</span>;</div><div class="line"><span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">formatter.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</div><div class="line">formatter.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</div><div class="line"><span class="built_in">NSDate</span> *date = [formatter dateFromString:timeStr];</div><div class="line"><span class="comment">// 2015-04-09 16:00:00 +0000</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, date);</div></pre></td></tr></table></figure></blockquote><p>76.队列和多线程的使用原理  </p><blockquote><p>在iOS中队列分为以下几种  </p><ul><li>串行队列：队列中的任务只会顺序执行;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_queue_create(&quot;...&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure><ul><li>并行队列： 队列中的任务通常会并发执行；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_queue_create(&quot;......&quot;,DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure><ul><li>全局队列：是系统的，直接拿过来（GET）用就可以；与并行队列类似；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</div></pre></td></tr></table></figure><ul><li>主队列：每一个应用程序对应唯一主队列，直接GET即可；在多线程开发中，使用主队列更新UI；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_get_main_queue();</div></pre></td></tr></table></figure><p>更多细节见下图：<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458633174180748.png" alt="">   </p></blockquote><p>77.内存的使用和优化的注意事项  </p><blockquote><ul><li>重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用；</li><li>尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能；</li><li>不要使用太复杂的XIB/Storyboard：载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多；</li><li>选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。</li><li>gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</li><li>延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。</li><li>数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。</li><li>处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉</li><li>重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。</li><li>避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要;</li><li>使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存;</li><li>正确选择图片加载方式：详情阅读细读<a href="http://www.cnblogs.com/jiayongqiang/p/5339583.html" target="_blank" rel="external">UIImage加载方式</a></li></ul></blockquote><p>78.UIViewController的完整生命周期</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-[ViewController initWithNibName:bundle:]；</div><div class="line">-[ViewController init]；</div><div class="line">-[ViewController loadView]；</div><div class="line">-[ViewController viewDidLoad]；</div><div class="line">-[ViewController viewWillDisappear:]；</div><div class="line">-[ViewController viewWillAppear:]；</div><div class="line">-[ViewController viewDidAppear:]；</div><div class="line">-[ViewController viewDidDisappear:]；</div></pre></td></tr></table></figure></blockquote><p>79.UIImageView添加圆角  </p><blockquote><ul><li>最直接的方法就是使用如下属性设置：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imgView.layer.cornerRadius = <span class="number">10</span>;</div><div class="line"><span class="comment">// 这一行代码是很消耗性能的</span></div><div class="line">imgView.clipsToBounds = <span class="literal">YES</span>;</div></pre></td></tr></table></figure><p><strong>这是离屏渲染（off-screen-rendering），消耗性能的</strong></p><ul><li>给UIImage添加生成圆角图片的扩展API：这是on-screen-rendering  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageWithCornerRadius:(<span class="built_in">CGFloat</span>)radius &#123;</div><div class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="number">0.</span>f, <span class="number">0.</span>f, <span class="keyword">self</span>.size&#125;;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="built_in">UIScreen</span>.mainScreen.scale);</div><div class="line">    <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(),[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);</div><div class="line">   <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</div><div class="line">   [<span class="keyword">self</span> drawInRect:rect];</div><div class="line">   <span class="built_in">UIImage</span> * image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">   <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">   <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.OC的理解与特性    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题一</title>
    <link href="http://yoursite.com/2017/10/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>http://yoursite.com/2017/10/19/面试题一/</id>
    <published>2017-10-19T11:25:30.000Z</published>
    <updated>2017-10-19T13:20:21.989Z</updated>
    
    <content type="html"><![CDATA[<p>1.Object-c的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式是用继承好还是分类好？为什么？  </p><blockquote><p>答：Object-c的类不可以多重继承；可以实现多个接口，通过实现多个接口可以完成C++的多重继承；Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p></blockquote><p>2、#import跟#include有什么区别？@class呢，#import&lt;&gt;和#import””有什么区别？  </p><blockquote><p>答：#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字,使用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once;@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含;#import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</p></blockquote><p>3、属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?  </p><blockquote><p>答：<br>1). readwrite 是可读可写特性;需要生成getter方法和setter方法时<br>2). readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变<br>3). assign 是赋值特性，setter方法将传入参数赋值给实例变量;仅设置变量时;<br>4). retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;<br>5). copy 表示赋值特性，setter方法将传入对象复制一份;需要完全一份新的变量时。<br>6).nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic   </p></blockquote><p>4.写一个setter方法用于完成<code>@property (nonatomic,retain)NSString *name</code>,写一个setter方法用于完成<code>@property(nonatomic，copy)NSString *name</code>  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span>*)str</div><div class="line">&#123;</div><div class="line">   [str <span class="keyword">retain</span>];</div><div class="line">   [name release];</div><div class="line">   name = str;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)str</div><div class="line">&#123;</div><div class="line">   <span class="keyword">id</span> t = [str <span class="keyword">copy</span>];</div><div class="line">   [name release];</div><div class="line">   name = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5.对于语句<code>NSString*obj = [[NSData alloc] init];</code> obj在编译时和运行时分别时什么类型的对象?  </p><blockquote><p>答：编译时是<strong>NSString</strong>的类型;运行时是<strong>NSData</strong>类型的对象</p></blockquote><p>6.常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</p><blockquote><p>答：object-c的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。  </p></blockquote><p>7.id 声明的对象有什么特性?  </p><blockquote><p>答：<strong>id</strong>声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象;</p></blockquote><p>8.Objective-C如何对内存管理的,说说你的看法和解决方法?  </p><blockquote><p>答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、MRC(手动内存计数)、NSAutoRealeasePool(内存池)。<br>1)ARC:系统会自动帮我们释放不再使用的对象，我们不用考虑它什么时候工作，怎样工作。  </p><p>2)MRC:从一段内存被申请之后，就存在一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为0的时候，那么就是释放这段内存的时候。比如说，当在程序A里面一段内存被成功申请完成之后，那么这个计数器就从0变成1(我们把这个过程叫做alloc)，然后程序B也需要使用这个内存，那么计数器就从1变成了2(我们把这个过程叫做retain)。紧接着程序A不再需要这段内存了，那么程序A就把这个计数器减1(我们把这个过程叫做release);程序B也不再需要这段内存的时候，那么也把计数器减1(这个过程还是release)。当系统(也就是Foundation)发现这个计数器变 成员了0，那么就会调用内存回收程序把这段内存回收(我们把这个过程叫做dealloc)。顺便提一句，如果没有Foundation，那么维护计数器，释放内存等等工作需要你手工来完成。<br>解决:一般是由类的静态方法创建的, 函数名中不会出现alloc或init字样, 如[NSString string]和[NSArray arrayWithObject:], 创建后引用计数+0, 在函数出栈后释放, 即相当于一个栈上的局部变量. 当然也可以通过retain延长对象的生存期.   </p><p>3)NSAutoRealeasePool:可以通过创建和释放内存池控制内存申请和回收的时机.<br>解决:是由autorelease加入系统内存池, 内存池是可以嵌套的, 每个内存池都需要有一个创建释放对, 就像main函数中写的一样. 使用也很简单, 比如[[[NSString alloc]initialWithFormat:@”Hey you!”] autorelease], 即将一个NSString对象加入到最内层的系统内存池, 当我们释放这个内存池时, 其中的对象都会被释放.</p></blockquote><p>9.原子(atomic)跟非原子(non-atomic)属性有什么区别?  </p><blockquote><p>答：<br>1). atomic提供多线程安全。是防止在写未完成的时候被另外一个线程读取，造成数据错误<br>2). non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。</p></blockquote><p>10.看下面的程序,在MRC的环境下,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *ary = [[<span class="built_in">NSMutableArray</span> array] <span class="keyword">retain</span>];</div><div class="line"><span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"test"</span>];</div><div class="line">[str <span class="keyword">retain</span>];</div><div class="line">[ary addObject:str];</div><div class="line"><span class="built_in">NSLog</span>(@”%@%d”,str,[str retainCount]);</div><div class="line">[str <span class="keyword">retain</span>];</div><div class="line">[str release];</div><div class="line">[str release];</div><div class="line"><span class="built_in">NSLog</span>(@”%@%d”,str,[str retainCount]);</div><div class="line">[ary removeAllObjects];</div><div class="line"><span class="built_in">NSLog</span>(@”%@%d”,str,[str retainCount]);</div></pre></td></tr></table></figure><blockquote><p>答：str的retainCount创建+1，retain+1，加入数组自动+1，所以第一个NSlog输出为3,这是retainCount为3<br>retain+1，release-1，release-1，所以第二个NSlog输出为2,这是retainCount为2<br>数组删除所有对象，所有数组内的对象自动-1，所以第三个NSlog输出为1,这是retainCount为1</p></blockquote><p>11.在MRC的环境下,内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?  </p><blockquote><p>答：谁申请，谁释放<br>遵循Cocoa Touch的使用原则;<br>内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放，要细心。<br>关键字alloc 或new 生成的对象需要手动释放;<br>设置正确的property属性，对于retain需要在合适的地方释放。</p></blockquote><p>12.如何对iOS设备进行性能测试?  </p><blockquote><p>答： Profile-&gt; Instruments -&gt;Time Profiler</p></blockquote><p>13.Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?  </p><blockquote><p>答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;<br>在主线程执行代码，方法是<code>performSelectorOnMainThread</code>，如果想延时执行代码可以用<code>performSelector:onThread:withObject:waitUntilDone</code>:</p></blockquote><p>14.MVC设计模式是什么？ 你还熟悉什么设计模式？  </p><blockquote><p>答：设计模式：并不是一种新技术，而是一种编码经验，使用比如java中的接口，iphone中的协议，继承关系等基本手段，用比较成熟的逻辑去处理某一种类型的事情，总结为所谓设计模式。面向对象编程中，java已经归纳了23种设计模式。  </p><p><strong>mvc设计模式</strong> ：模型，视图，控制器，可以将整个应用程序在思想上分成三大块，对应是的数据的存储或处理，前台的显示，业务逻辑的控制。 Iphone本身的设计思想就是遵循mvc设计模式。其不属于23种设计模式范畴。</p><p><strong>代理模式</strong>：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用.比如一个工厂生产了产品，并不想直接卖给用户，而是搞了很多代理商，用户可以直接找代理商买东西，代理商从工厂进货.常见的如QQ的自动回复就属于代理拦截，代理模式在iphone中得到广泛应用.</p><p><strong>单例模式</strong>：说白了就是一个类不通过alloc方式创建对象，而是用一个静态方法返回这个类的对象。系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为，比如想获得[UIApplication sharedApplication];任何地方调用都可以得到 UIApplication的对象，这个对象是全局唯一的。  </p><p><strong>观察者模式</strong>： 当一个物体发生变化时，会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的对象给这个物体，当这个物体的发生改变，就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的。</p><p>工厂模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Factory&#123;</div><div class="line">  public static Samplecreator(int which)&#123;</div><div class="line">    if(which == 1)</div><div class="line">      return new SampleA();</div><div class="line">    elseif(which == 2)</div><div class="line">      return new SampleB();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><p>15.浅复制和深复制的区别?</p><blockquote><p>答：浅复制：只复制指向对象的指针，而不复制引用对象本身。深复制：复制引用对象本身。<br>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。<br>用网上一哥们通俗的话将就是：<br>浅复制好比你和你的影子，你完蛋，你的影子也完蛋<br>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p></blockquote><p>16.类别的作用?继承和类别在实现中有何区别?  </p><blockquote><p>答：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改，并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。<br>类别主要有3个作用：<br>1).将类的实现分散到多个不同文件或多个不同框架中。<br>2).创建对私有方法的前向引用。<br>3).向对象添加非正式协议。  </p><p>继承可以增加，修改或者删除方法，并且可以增加属性。</p></blockquote><p>17.类别和类扩展的区别。  </p><blockquote><p>答：category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。<br>extensions可以认为是一个私有的Category。  </p></blockquote><p>18.oc中的协议和java中的接口概念有何不同?  </p><blockquote><p>答：OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。<br>其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，  现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</p></blockquote><p>19.什么是KVO和KVC?  </p><blockquote><p>答：KVC:键–值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。<br>KVO:键值观察机制，提供了观察某一属性变化的方法，极大的简化了代码。具体使用可以参考如下代码自定义的一个button,对于按钮点击变化状态的的监控。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"highlighted"</span> options:<span class="number">0</span> context:<span class="literal">nil</span>];</div><div class="line"><span class="meta">#pragma mark - KVO</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"highlighted"</span>])</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。<br>对于kvc机制如何通过key寻找到value：当通过KVC调用对象时，比如：<code>[self valueForKey:@”someKey”]</code>时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有someKey这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量(iVar)，如果还没有找到，程序会继续试图调用 <code>-(id)valueForUndefinedKey:</code>这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。<br>注：Key-Value 代码查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。<br>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。<br>因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，可以按照kvc查找的逻辑理解，就说的过去了。</p><p>20.代理的作用?</p><blockquote><p>答：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。<br>另外一点，代理可以理解为java中的回调监听机制的一种类似。</p></blockquote><p>21.oc中可修改和不可以修改类型。  </p><blockquote><p>答：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。<br>比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。</p></blockquote><p>22.我们说的oc是动态运行时语言是什么意思?  </p><blockquote><p>答：这个问题其实浅涉及到两个概念，运行时和多态。<br>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。<br>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器)。因此也可以说，运行时机制是多态的基础</p></blockquote><p>23.通知和协议的不同之处?  </p><blockquote><p>协议有控制链(has-a)的关系，通知没有。<br>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。<br>代理按我们的理解，倒不是直接说不能一对多，比如我们知道的明星经纪代理人，很多时候一个经纪人负责好几个明星的事务，只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星的一个发布会，代理人发出处理发布会的消息后，变成B的<br>发布会了。但是通知就不一样，它只关心发出通知，而不关心多少接收到感兴趣要处理。<br>因此控制链(has-a)从英语单词大致可以看出，单一拥有和可控制的对应关系。</p></blockquote><p>24.对于单例的理解  </p><blockquote><p>答：在objective-c中要实现一个单例类，至少需要做以下三个步骤：<br>1).为单例对象实现一个静态实例，并初始化，然后设置成nil，<br>2).实现一个实例构造方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，<br>3).重写allocWithZone，copyWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实例的时候不产生一个新实例。</p></blockquote><p>25.frame和bounds有什么不同? </p><blockquote><p>答:frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父亲的坐标系统)<br>bounds指的是：该view在本身坐标系统中 的位置和大小。(参照点是本身坐标系统)</p></blockquote><p>26.方法和选择器有何不同?  </p><blockquote><p>答：selector是一个方法的名字，method是一个组合体，包含了名字和实现.</p></blockquote><p>27.NSOperationQueue?<br>答：存放NSOperation的集合类。<br>操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。<br>虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。<br>这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。但是转念一想其实可以参考银行的取票和叫号系统。因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。<br>网上有一篇关于这操作队列话题的文章，其中有一句提到“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”瞬间觉得这个queue名字有点忽悠人了，还不如pool~<br>综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了</p><p>28.什么是延迟加载?  </p><blockquote><p>答：懒汉模式，只在用到的时候才去初始化。也可以理解成延时加载。最简单的一个例子就是tableView中图片的加载显示了；一个延时加载，避免内存过高，一个异步加载，避免线程堵塞。</p></blockquote><p>29.一个tableView是否可以关联两个不同的数据源?你会怎么处理?</p><blockquote><p>答：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。<br>因此我们并不关心如何去关联它，它怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。</p></blockquote><p>30.什么时候使用NSMutableArray，什么时候使用NSArray?</p><blockquote><p>答：当数组在程序运行时，需要不断变化的，使用NSMutableArray，当数组在初始化后，便不再改变的，使用NSArray。需要指出的是，使用NSArray只表明的是该数组在运行时不发生改变，即不能往NSAarry的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。NSArray是线程安全的，NSMutableArray不是线程安全的，多线程使用到NSMutableArray需要注意。</p></blockquote><p>31.给出委托方法的实例，并且说出UITableVIew的Data Source方法  </p><blockquote><p>答：CocoaTouch框架中用到了大量委托，其中UITableViewDelegate就是委托机制的典型应用，是一个典型的使用委托来实现适配器模式，<strong>其中UITableViewDelegate协议是目标，tableview是适配器，实现UITableViewDelegate协议，并将自身设置为talbeview的delegate的对象，是被适配器</strong>，一般情况下该对象是UITableViewController。<br>UITableVIew的Data Source方法有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;</div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</div></pre></td></tr></table></figure></blockquote><p>32.在应用中可以创建多少autorelease对象，是否有限制?</p><blockquote><p>答：无。</p></blockquote><p>33.如果我们不创建内存池，是否有内存池提供给我们?  </p><blockquote><p>答:界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池</p></blockquote><p>34.什么时候需要在程序中创建内存池?  </p><blockquote><p>答：用户自己创建的数据线程，则需要创建该线程的内存池</p></blockquote><p>35.类NSObject的那些方法经常被使用?  </p><blockquote><p>答：NSObject是Objetive-C的基类，其由NSObject类及一系列协议构成。<br>其中类方法alloc、class、 description 对象方法init、dealloc、– performSelector:withObject:afterDelay:等经常被使用</p></blockquote><p>36.什么是简便构造方法?</p><blockquote><p>答：简便构造方法一般由CocoaTouch框架提供，如NSNumber的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: +numberWithInt:Foundation下大部分类均有简便构造方法。</p></blockquote><p>37.如何使用Xcode设计通用应用?  </p><blockquote><p>答：使用MVC模式设计应用，其中Model层完成脱离界面，即在Model层，其是可运行在任何设备上，在controller层，根据iPhone与iPad(独有UISplitViewController)的不同特点选择不同的viewController对象。在View层，可根据现实要求，来设计，其中以xib文件设计时，其设置其为universal。</p></blockquote><p>38.UIView的动画效果有那些?  </p><blockquote><p>答：有很多，如<br>UIViewAnimationOptionCurveEaseInOut<br>UIViewAnimationOptionCurveEaseIn<br>UIViewAnimationOptionCurveEaseOut<br>UIViewAnimationOptionCurveLinear<br>UIViewAnimationOptionTransitionNone<br>UIViewAnimationOptionTransitionFlipFromLeft<br>UIViewAnimationOptionTransitionFlipFromRight<br>UIViewAnimationOptionTransitionCurlUp<br>UIViewAnimationOptionTransitionCurlDown<br>UIViewAnimationOptionTransitionCrossDissolve<br>UIViewAnimationOptionTransitionFlipFromTop<br>UIViewAnimationOptionTransitionFlipFromBottom</p></blockquote><p>39.在iPhone应用中如何保存数据?  </p><blockquote><p>答：有以下几种保存机制：<br>1).通过web服务，保存在服务器上<br>2).通过NSCoder固化机制，将对象保存在文件中<br>3).通过SQlite或CoreData保存在文件数据库中  </p></blockquote><p>40.什么是coredata?  </p><blockquote><p>答：coredata是苹果提供一套数据保存框架，其基于SQlite  </p></blockquote><p>41.什么是NSManagedObject模型?  </p><blockquote><p>答：NSManagedObject是NSObject的子类 ，也是coredata的重要组成部分，它是一个通用的类,实现了core data 模型层所需的基本功能，用户可通过子类化NSManagedObject，建立自己的数据模型。</p></blockquote><p>42.什么是NSManagedobjectContext?</p><blockquote><p>答：NSManagedobjectContext对象负责应用和数据库之间的交互。</p></blockquote><p>43.什么是谓词?</p><blockquote><p>答：谓词是通过NSPredicate，是通过给定的逻辑条件作为约束条件，完成对数据的筛选。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">predicate =[<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"customerID == %d"</span>,n];</div><div class="line">a = [customers filteredArrayUsingPredicate:predicate];</div></pre></td></tr></table></figure></blockquote><p>44.和coredata一起有哪几种持久化存储机制?  </p><blockquote><p>答：存入到文件、 存入到NSUserDefaults(系统plist文件中)、存入到Sqlite文件数据库  </p></blockquote><p>45.谈谈对Block 的理解?并写出一个使用Block执行UIVew动画?  </p><blockquote><p>答：Block是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可以大幅提高应用的执行效率(多核心CPU可直接处理Block指令)  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">UIView</span> transitionWithView:<span class="keyword">self</span>.view duration:<span class="number">0.2</span> options:<span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span> animations:^&#123;</div><div class="line">    [[blueViewController view] removeFromSuperview];</div><div class="line">    [[<span class="keyword">self</span> view] insertSubview:yellowViewController.view atIndex:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line">completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></blockquote><p>46.写出上面代码的Block的定义。</p><blockquote><p>答：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^animations)(<span class="keyword">void</span>);</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^completion)(<span class="built_in">BOOL</span> finished);</div></pre></td></tr></table></figure></blockquote><p>47.做过的项目是否涉及网络访问功能，使用什么对象完成网络功能?</p><blockquote><p>AFNetWorking和NSURLConnection、NSURLSession </p></blockquote><p>48。简单介绍下NSURLConnection类及+ sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别?  </p><blockquote><p>答: NSURLConnection主要用于网络访问，其中+ sendSynchronousRequest:returningResponse:error:是同步访问数据，即当前线程会阻塞，并等待request的返回的response，而– initWithRequest:delegate:使用的是异步加载，当其完成网络访问后，会通过delegate回到主线程，并通知其委托的对象。</p></blockquote><p>49.多线程是什么？</p><blockquote><p>答: 多线程是个复杂的概念，按字面意思是同步完成多项任务，提高了资源的使用效率，从硬件、操作系统、应用软件不同的角度去看，多线程被赋予不同的内涵，对于硬件，现在市面上多数的CPU都是多核的，多核的CPU运算多线程更为出色;从操作系统角度，是多任务，现在用的主流操作系统都是多任务的，可以一边听歌、一边写博客;对于应用来说，多线程可以让应用有更快的回应，可以在网络下载时，同时响应用户的触摸操作。在iOS应用中，对多线程最初的理解，就是并发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成烧水的同时去摘菜，最后去炒菜。</p></blockquote><p>50.iOS 中的多线程</p><blockquote><p>答：iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更为方便的使用线程，做过C++的同学可能会对线程有更多的理解，比如线程的创立，信号量、共享变量有认识，Cocoa框架下会方便很多，它对线程做了封装，有些封装，可以让我们创建的对象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提供程序的健壮性。<br>GCD是(Grand Central Dispatch)的缩写 ，从系统级别提供的一个易用地多线程类库，具有运行时的特点，能充分利用多核心硬件。GCD的API接口为C语言的函数，函数参数中多数有Block，为我们提供强大的“接口”。<br>NSOperation与Queue：NSOperation是一个抽象类，它封装了线程的细节实现，我们可以通过子类化该对象，加上NSOperationQueue来同面向对象的思维，管理多线程程序。<br>NSThread：NSThread是一个控制线程执行的对象，它不如NSOperation抽象，通过它我们可以方便的得到一个线程，并控制它。但NSThread的线程之间的并发控制，是需要我们自己来控制的，可以通过NSCondition实现。</p></blockquote><p>51.在项目什么时候选择使用GCD，什么时候选择NSOperation?</p><blockquote><p>答: 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。<br>项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。  </p></blockquote><p>52.什么是block?  </p><blockquote><p>答: 对于闭包(block),有很多定义，其中闭包就是能够读取其它函数内部变量的函数，这个定义即接近本质又较好理解。对于刚接触Block的同学，会觉得有些绕，因为我们习惯写这样的程序main(){ funA();} funA(){funB();} funB(){…..}; 就是函数main调用函数A，函数A调用函数B… 函数们依次顺序执行，但现实中不全是这样的，例如项目经理M，手下有3个程序员A、B、C，当他给程序员A安排实现功能F1时，他并不等着A完成之后，再去安排B去实现F2，而是安排给A功能F1，B功能F2，C功能F3，然后可能去写技术文档，而当A遇到问题时，他会来找项目经理M，当B做完时，会通知M，这就是一个异步执行的例子。在这种情形下，Block便可大显身手，因为在项目经理M，给A安排工作时，同时会告诉A若果遇到困难，如何能找到他报告问题(例如打他手机号)，这就是项目经理M给A的一个回调接口，要回掉的操作，比如接到电话，百度查询后，返回网页内容给A，这就是一个Block，在M交待工作时，已经定义好，并且取得了F1的任务号(局部变量)，却是在当A遇到问题时，才调用执行，跨函数在项目经理M查询百度，获得结果后回调该block。</p></blockquote><p>53.block 实现原理  </p><blockquote><p>答: Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。<br>从计算语言的发展，最早的goto，高级语言的指针，到面向对象语言的block，从机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻辑(需求)。  </p><p>使用实例<br>cocoaTouch框架下动画效果的Block的调用<br>使用typed声明block</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^didFinishBlock)(<span class="built_in">NSObject</span>?*ob);<span class="comment">//这就声明了一个didFinishBlock类型的block</span></div></pre></td></tr></table></figure><p>然后便可用  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)didFinishBlock finishBlock;</div></pre></td></tr></table></figure><p>声明一个blokc对象，注意对象属性设置为copy，接到block 参数时，便会自动复制一份。<br>__block是一种特殊类型，使用该关键字声明的局部变量，可以被block所改变，并且其在原函数中的值会被改变</p></blockquote><p>54.关于block  </p><blockquote><p>答：<br>1). 使用block和使用delegate完成委托模式有什么优点?<br>首先要了解什么是委托模式，委托模式在iOS中大量应用，其在设计模式中是适配器模式中的对象适配器，Objective-C中使用id类型指向一切对象，使委托模式更为简洁。了解委托模式的细节：<br>iOS设计模式—-委托模式<br>使用block实现委托模式，其优点是回调的block代码块定义在委托对象函数内部，使代码更为紧凑;适配对象不再需要实现具体某个protocol，代码更为简洁。  </p><p>2). 多线程与block<br>GCD与Block<br>使用 dispatch_async 系列方法，可以以指定的方式执行block<br>GCD编程实例<br>dispatch_async的完整定义</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</div></pre></td></tr></table></figure><p>功能：在指定的队列里提交一个异步执行的block，不阻塞当前线程,通过queue来控制block执行的线程。主线程执行前文定义的 finishBlock对象  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),^(<span class="keyword">void</span>)&#123;</div><div class="line">    finishBlock();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></blockquote><p>55.谈谈Object-C的MRC内存管理方式及过程？</p><blockquote><p>答:<br>1).当你使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.<br>2).当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.<br>3).如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持retain方法和release方法的使用次数相等.</p></blockquote><p>56.Object-C有私有方法吗？私有变量呢？  </p><blockquote><p>答: objective-c – 类里面的方法只有两种, 静态方法和实例方法. 这似乎就不是完整的面向对象了,按照OO的原则就是一个对象只暴露有用的东西. 如果没有了私有方法的话, 对于一些小范围的代码重用就不那么顺手了. 在类里面声名一个私有方法  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Controller</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *something;</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">void</span>)thisIsAStaticMethod;</div><div class="line">– (<span class="keyword">void</span>)thisIsAnInstanceMethod;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Controller</span>(<span class="title">private</span>)</span></div><div class="line">-(<span class="keyword">void</span>)thisIsAPrivateMethod;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>@private可以用来修饰私有变量<br>在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的</p></blockquote><p>57.Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类  </p><blockquote><p>答: 多继承在这里是用protocol 委托代理 来实现的<br>不用去考虑繁琐的多继承 ,虚基类的概念.<br>ood的多态特性 在 obj-c 中通过委托来实现.</p></blockquote><p>58.MRC内存管理 Autorelease、retain、copy、assign的set方法和含义？</p><blockquote><p>答:<br>1).你初始化(alloc/init)的对象，你需要释放(release)它。例如：<br>NSMutableArray aArray = [[NSArray alloc] init]; 后，需要 [aArray release];<br>2).你retain或copy的，你需要释放它。例如：<br>[aArray retain] 后，需要 [aArray release];<br>3).被传递(assign)的对象，你需要斟酌的retain和release。例如：<br>obj2 = [[obj1 someMethod] autorelease];<br>对象2接收对象1的一个自动释放的值，或传递一个基本数据类型(NSInteger，NSString)时：你或希望将对象2进行retain，以防止它在被使用之前就被自动释放掉。但是在retain后，一定要在适当的时候进行释放。<br>关于索引计数(Reference Counting)的问题<br>retain值 = 索引计数(Reference Counting)<br>NSArray对象会retain(retain值加一)任何数组中的对象。当NSArray被卸载(dealloc)的时候，所有数组中的对象会 被 执行一次释放(retain值减一)。不仅仅是NSArray，任何收集类(Collection Classes)都执行类似操作。例如 NSDictionary，甚至UINavigationController。<br>Alloc/init建立的对象，索引计数为1。无需将其再次retain。<br>[NSArray array]和[NSDate date]等“方法”建立一个索引计数为1的对象，但是也是一个自动释放对象。所以是本地临时对象，那么无所谓了。如果是打算在全Class中使用的变量(iVar)，则必须retain它。<br>缺省的类方法返回值都被执行了“自动释放”方法。(如上中的NSArray)<br>在类中的卸载方法“dealloc”中，release所有未被平衡的NS对象。(所有未被autorelease，而retain值为1的) </p></blockquote><p>59.C和obj-c 如何混用  </p><blockquote><p>答:<br>1).obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码，处理mm文件可以识别obj-c,c,c++代码，但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj-c的代码，因为cpp只是cpp。<br>2).在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题<br>3).在cpp中混用obj-c其实就是使用obj-c编写的模块是我们想要的。<br>如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。<br>如果模块以函数实现，那么头文件要按c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。<br>总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，而不能直接使用 实现代码，实际上cpp混用的是obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp。</p></blockquote><p>60.Objective-C堆和栈的区别？  </p><blockquote><p>答: 管理方式：<br>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>申请大小：<br>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>碎片问题：<br>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p><p>分配方式：<br>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p>分配效率：<br>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p></blockquote><p>61.ViewController的didReceiveMemoryWarning怎么被调用：  </p><blockquote><p>答:[supper didReceiveMemoryWarning];</p></blockquote><p>62.什么时候用delegate,什么时候用Notification?</p><blockquote><p>答: delegate针对one-to-one关系，用于sender接受到reciever的某个功能反馈值。<br>notification针对one-to-one/many/none,reciver,用于通知多个object某个事件。  </p></blockquote><p>63.用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）  </p><blockquote><p><code>#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</code> </p><p>要考虑到这几件事情：<br><code>#define</code> 语法的基本知识（例如：不能以分号结束，括号的使用，等等）<br>懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。<br>意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数(用UL表达的意思更清楚)。  </p></blockquote><p>64.写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。</p><blockquote><p><code>#define MIN(A,B)（(A）&lt;= (B) ? (A):(B))</code><br>这个测试是为下面的目的而设的：<br>标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比 if-then-else 更优化的代码，了解这个用法是很重要的。<strong>懂得在宏中小心地把参数用括号括起来</strong>,我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">least = MIN(*p++,b);</div></pre></td></tr></table></figure><p>结果是： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((*p++) &lt;= (b) ? (*p++):(b))</div></pre></td></tr></table></figure><p>这个表达式会产生副作用，指针p会作两次++自增操作。  </p></blockquote><p>65.关键字const有什么含意？修饰类呢?static的作用,用于类呢?还有extern c的作用  </p><blockquote><p>答：<br>const 意味着”只读”，下面的声明都是什么意思？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const int a;</div><div class="line">int const a;</div><div class="line">const int *a;</div><div class="line">int *const a;</div><div class="line">const int * const a;</div></pre></td></tr></table></figure><p>前两个的作用是一样的，a是一个常整型数。<br>第三个意味着a是一个指向常整型数的指针(也就是说，整型数是不可修改的，但指针可以)<br>第四个意味着a是一个指向整型数的常指针(也就是说，指针指向的整型数是可以修改的，但指针是不可以修改的)<br>最后一个意味着a是一个指向常整型数的常指针(也就是说，指针指向的整型数是不可以修改的，同时指针也是不可修改的)  </p><p>结论：<br>关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。<br>如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的）通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p><p>1).欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>2).对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指<br>定为 const；<br>3).在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>4).对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；<br>5).对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。   </p></blockquote><p>66.关键字volatile有什么含意?并给出三个不同的例子。  </p><blockquote><p>答：一个定义为 volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。  </p><p>下面是volatile变量的几个例子：<br>并行设备的硬件寄存器（如：状态寄存器）<br>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>多线程应用中被几个任务共享的变量  </p></blockquote><p>67.一个参数既可以是const还可以是volatile吗？ 一个指针可以是volatile 吗？解释为什么。</p><blockquote><p>答：<br>1).可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>2).可以。尽管这并不很常见。一个例子是当一个服务子程序修改一个指向一个buffer的指针时。  </p></blockquote><p>68.static 关键字的作用  </p><blockquote><p>答：<br>1).函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，<br>因此其值在下次调用时仍维持上次的值；<br>2).在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；<br>3).在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；<br>4).在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br>5).在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。   </p></blockquote><p>69.线程与进程的区别和联系?</p><blockquote><p>答：<br>1). 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性<br>2). 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。<br>3). 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。<br>4.)线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<br>5). 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。  </p></blockquote><p>70.列举几种进程的同步机制，并比较其优缺点。  </p><blockquote><p>答：原子操作  信号量机制  自旋锁  管程，会合，分布式系统  </p></blockquote><p>71.进程之间通信的途径  </p><blockquote><p>答：共享存储系统消息传递系统管道：以文件系统为基础</p></blockquote><p>72.进程死锁的原因  </p><blockquote><p>答：资源竞争及进程推进顺序非法</p></blockquote><p>73.死锁的4个必要条件  </p><blockquote><p>答：互斥、请求保持、不可剥夺、环路  </p></blockquote><p>74.死锁的处理  </p><blockquote><p>答：鸵鸟策略、预防策略、避免策略、检测与解除死锁  </p></blockquote><p>75.cocoa touch框架  </p><blockquote><p>答：<code>iPhone OS</code>应用程序的基础<code>Cocoa Touch</code>框架重用了许多<code>Mac</code>系统的成熟模式，但是它更多地专注于触摸的接口和优化。</p><p><code>UIKit</code>为您提供了在<code>iPhone OS</code>上实现图形，事件驱动程序的基本工具，其建立在和<code>Mac OS X</code> 中一样的<code>Foundation</code>框架上，包括文件处理，网络，字符串操作等。  </p><p><code>Cocoa Touch</code>具有和<code>iPhone</code>用户接口一致的特殊设计。有了<code>UIKit</code>，您可以使用<code>iPhone OS</code> 上的独特的图形接口控件，按钮，以及全屏视图的功能，您还可以使用加速仪和多点触摸手势来控制您的应用。<br>各色俱全的框架 除了<code>UIKit</code>外，<code>Cocoa Touch</code>包含了创建世界一流<code>iPhone</code>应用程序需要的所有框架，从三维图形，到专业音效，甚至提供设备访问<code>API</code>以控制摄像头，或通过<code>GPS</code>获知当前位置。<br><code>Cocoa Touch</code>既包含只需要几行代码就可以完成全部任务的强大的<code>Objective-C</code>框架，也在需要时提供基础的<strong>C</strong>语言<code>API</code>来直接访问系统。这些框架包括：<br><strong>Core Animation</strong>：通过<strong>Core Animation</strong>，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰富的用户体验。<br><strong>Core Audio</strong>：<strong>Core Audio</strong> 是播放，处理和录制音频的专业技术，能够轻松为您的应用程序添加强大的音频功能。<br><strong>Core Data</strong>：提供了一个面向对象的数据管理解决方案，它易于使用和理解，甚至可处理任何应用或大或小的数据模型。  </p><p>功能列表：框架分类<br>下面是 Cocoa Touch 中一小部分可用的框架：<br>音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation<br>数据管理 ：Core Data ，SQLite<br>图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D<br>网络：Bonjour ，WebKit ，BSD Sockets<br>用户应用：Address Book ，Core Location ，Map Kit ，Store Kit  </p></blockquote><p>76.自动释放池是什么,如何工作?  </p><blockquote><p>答：当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放.它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。  </p></blockquote><p>77.Objective-C的优缺点  </p><blockquote><p>答：<br>objc优点：<br>1).Cateogies<br>2).Posing<br>3).动态识别<br>4).指标计算<br>5).弹性讯息传递<br>6).不是一个过度复杂的 C 衍生语言<br>7).Objective-C 与 C++ 可混合编程<br>objc缺点:<br>1).不支援命名空间<br>2).不支持运算符重载<br>3).不支持多重继承<br>4).使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。  </p></blockquote><p>78.sprintf,strcpy,memcpy使用上有什么要注意的地方。  </p><blockquote><p>答：<br>1). sprintf是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。sprintf格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小，造成溢出。<br>2).strcpy是一个字符串拷贝的函数，它的函数原型为<code>strcpy(char *dst, const char *src)</code><br>将src开始的一段字符串拷贝到dst开始的内存中去，结束的标志符号为 ‘\0’，由于拷贝的长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。<br>3). memcpy是具备字符串拷贝功能的函数，这是一个内存拷贝函数，它的函数原型为<code>memcpy(char *dst, const char* src, unsigned int len)</code>;将长度为len的一段内存，从src拷贝到dst中去，这个函数的长度可控。但是会有内存叠加的问题。</p></blockquote><p>79.readwrite，readonly，assign，retain，copy，nonatomic 属性的作用  </p><blockquote><p>答：@property是一个属性访问声明，括号内支持以下几个属性：<br>1).getter=getterName，setter=setterName，设置setter与 getter的方法名<br>2).readwrite,readonly，设置可供访问级别<br>2).assign，setter方法直接赋值，不进行任何retain操作，为了解决原类型与环循引用问题<br>3).retain，setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序(CC上有相关资料)<br>4).copy，setter方法进行Copy操作，与retain处理流程一样，先旧值release，再 Copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。<br>5).nonatomic，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。锁被加到所属对象实例级。  </p></blockquote><p>80.http和scoket通信的区别。</p><blockquote><p>答： http是客户端用http协议进行请求，发送请求时候需要封装http请求头，并绑定请求的数据，服务器一般有web服务器配合（当然也非绝对）。 http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术）。iphone主要使用类是NSURLConnection。<br>scoket是客户端跟服务器直接使用socket“套接字”进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或股票开发这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是CFSocketRef。</p></blockquote><p>81.TCP和UDP的区别  </p><blockquote><p>答： TCP全称是Transmission Control Protocol，中文名为传输控制协议，它可以提供可靠的、面向连接的网络数据传递服务。传输控制协议主要包含下列任务和功能：  </p><ul><li>确保IP数据报的成功传递。  </li><li>对程序发送的大块数据进行分段和重组。  </li><li>确保正确排序及按顺序传递分段的数据。  </li><li>通过计算校验和，进行传输数据的完整性检查。<br>TCP提供的是面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般  </li></ul></blockquote><p>82.你了解svn,cvs等版本控制工具么？  </p><blockquote><p>答：版本控制svn,cvs是两种版控制的器,需要配套相关的svn，cvs服务器。<br>scm是xcode里配置版本控制的地方。版本控制的原理就是a和b同时开发一个项目，a写完当天的代码之后把代码提交给服务器，b要做的时候先从服务器得到最新版本，就可以接着做。 如果a和b都要提交给服务器，并且同时修改了同一个方法，就会产生代码冲突，如果a先提交，那么b提交时，服务器可以提示冲突的代码，b可以清晰的看到，并做出相应的修改或融合后再提交到服务器。</p></blockquote><p>83.什么是push(推送)</p><blockquote><p>答：客户端程序留下后门端口，客户端总是监听针对这个后门的请求，于是 服务器可以主动像这个端口推送消息。</p></blockquote><p>84.静态链接库  </p><blockquote><p>答：此为.a文件，相当于java里的jar包，把一些类编译到一个包中，在不同的工程中如果导入此文件就可以使用里面的类，具体使用依然是#import “ xx.h”。  </p></blockquote><p>85.fmmpeg框架  </p><blockquote><p>答：音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。</p></blockquote><p>86.fmdb框架  </p><blockquote><p>答：数据库框架，对sqllite的数据操作进行了封装，使用着可把精力都放在sql语句上面。  </p></blockquote><p>87.什么是沙盒模型？哪些操作是属于私有api范畴?  </p><blockquote><p>答：某个iphone工程进行文件操作有此工程对应的指定的位置，不能逾越。<br>iphone沙箱模型的有四个文件夹documents，tmp，app，Library，永久数据存储一般放documents文件夹，得到模拟器的路径的可使用NSHomeDirectory()方法。Nsuserdefaults保存的文件在tmp文件夹里。</p></blockquote><p>88.在一个对象的方法里面：self.name= “object”；和 name =”object” 有什么不同吗?</p><blockquote><p>答：self.name =”object”：会调用对象的setName()方法；name = “object”：会直接把object赋值给当前对象的name属性。</p></blockquote><p>89.请简要说明viewDidLoad和viewDidUnload何时调用  </p><blockquote><p>答：viewDidLoad在view从nib文件初始化时调用，loadView在controller的view为nil时调用。此方法在编程实现view时调用，view控制器默认会注册memory warning notification，当view controller的任何view没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release，如果是retain的IBOutlet view 属性则不要在这里release，IBOutlet会负责release 。  </p></blockquote><p>90.简述内存分区情况  </p><blockquote><p>答：<br>1).代码区：存放函数二进制代码<br>2).数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量<br>3).堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放<br>4).栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数  </p></blockquote><p>91.队列和栈有什么区别  </p><blockquote><p>答：队列和栈是两种不同的数据容器。从”数据结构”的角度看，它们都是线性结构，即数据元素之间的关系相同。<br>队列是一种先进先出的数据结构，它在两端进行操作，一端进行入队列操作，一端进行出列队操作。<br>栈是一种先进后出的数据结构，它只能在栈顶进行操作，入栈和出栈都在栈顶操作。</p></blockquote><p>92.HTTP协议中，POST和GET的区别是什么？  </p><blockquote><p>答：<br>1).GET 方法<br>GET 方法提交数据不安全，数据置于请求行，客户端地址栏可见;<br>GET 方法提交的数据大小有限<br>GET 方法不可以设置书签<br>2).POST 方法<br>POST 方法提交数据安全，数据置于消息主体内，客户端不可见<br>POST 方法提交的数据大小没有限制<br>POST 方法可以设置书签  </p></blockquote><p>93.iOS的系统架构  </p><blockquote><p>答： iOS的系统架构分为（ 核心操作系统层 theCore OS layer ）、（ 核心服务层theCore Services layer ）、（ 媒体层 theMedia layer ）和（ Cocoa 界面服务层 the Cocoa Touch layer ）四个层次。  </p></blockquote><p>94.控件主要响应3种事件  </p><blockquote><p>答：<br>1). 基于触摸的事件 ;<br>2). 基于值的事件 ;<br>3).基于编辑的事件。</p></blockquote><p>95.xib文件的构成分为哪3个图标？都具有什么功能。  </p><blockquote><p>答： File’s Owner 是所有 nib 文件中的每个图标，它表示从磁盘加载 nib 文件的对象；<br>First Responder 就是用户当前正在与之交互的对象；View 显示用户界面；完成用户交互；是 UIView 类或其子类。  </p></blockquote><p>96.简述视图控件器的生命周期  </p><blockquote><p>答：<strong>loadView</strong>尽管不直接调用该方法，如多手动创建自己的视图，那么应该覆盖这个方法并将它们赋值给试图控制器的 view 属性。<br><strong>viewDidLoad</strong>只有在视图控制器将其视图载入到内存之后才调用该方法，这是执行任何其他初始化操作的入口。<br><strong>viewDidUnload</strong>当试图控制器从内存释放自己的方法的时候调用，用于清楚那些可能已经在试图控制器中创建的对象。<br><strong>viewVillAppear</strong>当试图将要添加到窗口中并且还不可见的时候或者上层视图移出图层后本视图变成顶级视图时调用该方法，用于执行诸如改变视图方向等的操作。实现该方法时确保调用 <strong>[super viewWillAppear:]</strong><br><strong>viewDidAppear</strong> 当视图添加到窗口中以后或者上层视图移出图层后本视图变成顶级视图时调用，用于放置那些需要在视图显示后执行的代码。确保调用<strong>[super viewDidAppear：]</strong>。  </p></blockquote><p>97.动画有基本类型有哪几种；表视图有哪几种基本样式。  </p><blockquote><p>答：动画有两种基本类型：隐式动画和显式动画。  </p></blockquote><p>98.实现简单的表格显示需要设置UITableView的什么属性、实现什么协议？  </p><blockquote><p>答：实现简单的表格显示需要设置 UITableView 的 dataSource 和 delegate 属性，实现UITableViewDataSource 和 UITableViewDelegate 协议。  </p></blockquote><p>99.Cocoa Touch提供了哪几种Core Animation过渡类型  </p><blockquote><p>答： Cocoa Touch 提供了 4 种 Core Animation 过渡类型，分别为：交叉淡化、推挤、显示和覆盖。</p></blockquote><p>100.UIView与CLayer有什么区别？</p><blockquote><p>答：<br>1).UIView 是 iOS 系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图部分，是由一个CALayer类来管理。 UIView 本身更像是一个 CALayer 的管理器，访问它的跟绘图和跟坐标有关的属性。<br>2).UIView 有个重要属性layer，可以返回它的主 CALayer 实例。<br>3).UIView 的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer ，来完成某些特殊的表示。即CALayer层是可以嵌套的。<br>4).UIView 的layer树形在系统内部，被维护着三份copy。分别是逻辑树，这里是代码可以操纵的；动画树，是一个中间层，系统就在这一层上更改属性，进行各种渲染操作；显示树，其内容就是当前正被显示在屏幕上得内容。<br>5).动画的运作：对UIView的subLayer（非主 Layer ）属性进行更改，系统将自动进行动画生成，动画持续时间的缺省值似乎是 0.5 秒。<br>6).坐标系统：CALayer的坐标系统比UIView多了一个<strong>anchorPoint</strong>属性，使用CGPoint 结构表示，值域是 0~1 ，是个比例值。这个点是各种图形变换的坐标原点，同时会更改layer的<strong>position</strong>的位置，它的缺省值是 {0.5,0.5} ，即在 layer 的中央。<br>7).渲染：当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用<strong>setNeedsDisplay</strong>方法来重绘显示。<br>8).变换：要在一个层中添加一个3D或仿射变换，可以分别设置层的transform或affineTransform 属性。<br>9).变形： Quartz Core的渲染能力，使二维图像可以被自由操纵，就好像是三维的。图像可以在一个三维坐标系中以任意角度被旋转，缩放和倾斜。 CATransform3D 的一套方法提供了一些魔术般的变换效果。</p></blockquote><p>101.Quatrz 2D的绘图功能的三个核心概念是什么并简述其作用  </p><blockquote><p>答：<br>上下文context：主要用于描述图形写入哪里；<br>路径path：是在图层上绘制的内容；<br>状态：用于保存配置变换的值、填充和轮廓，alpha值等。  </p></blockquote><p>102.iOS主要提供了几种播放音频的方法？  </p><blockquote><p>SystemSound Services<br>AVAudioPlayer 类<br>Audio Queue Services<br>OpenAL  </p></blockquote><p>103.使用AVAudioPlayer类调用哪个框架、使用步骤?  </p><blockquote><p>AVFoundation.framework<br>步骤：<br>配置 AVAudioPlayer 对象；<br>实现 AVAudioPlayer 类的委托方法；<br>控制 AVAudioPlayer 类的对象；<br>监控音量水平；<br>回放进度和拖拽播放。  </p></blockquote><p>104.有哪几种手势通知方法、写清楚方法名？  </p><blockquote><p>答：</p><pre><code class="objectivec">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>*)touchedwithEvent:(<span class="built_in">UIEvent</span>*)event;-(<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>*)touched withEvent:(<span class="built_in">UIEvent</span>*)event;-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>*)touchedwithEvent:(<span class="built_in">UIEvent</span>*)event;-(<span class="keyword">void</span>)touchesCanceled:(<span class="built_in">NSSet</span>*)touchedwithEvent:(<span class="built_in">UIEvent</span>*)event;</code></pre></blockquote><p>105.CFSocket使用有哪几个步骤  </p><blockquote><p>答：<br>创建 Socket 的上下文；<br>创建 Socket；<br>配置要访问的服务器信息；<br>封装服务器信息；连接服务器；  </p></blockquote><p>106.Core Foundation中提供了哪几种操作Socket的方法？  </p><blockquote><p>答： CFNetwork 、 CFSocket 和 BSD Socket 。  </p></blockquote><p>107.解析XML文件有哪几种方式？<br>答：以 DOM 方式解析 XML 文件；以 SAX 方式解析 XML 文件；  </p><p>108.iOS平台怎么做数据的持久化?coredata 和sqlite有无必然联系？Core Data是一个关系型数据库吗？  </p><blockquote><p>答：iOS中可以有四种持久化数据的方式：属性列表(plist)、对象归档、 SQLite3 和 Core Data； core data 可以使你以图形界面的方式快速的定义 app 的数据模型，同时在你的代码中容易获取到它。 Core Data 提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在 app 中继续创建新的任务。在使用 Core Data 的时候，你不用安装额外的数据库系统，因为 Core Data 使用内置的 sqlite 数据库。 Core Data 将你 app 的模型层放入到一组定义在内存中的数据对象。 Core Data 会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当 Core Data 在对你 app 数据的改变进行保存的时候， Core Data 会把这些数据归档，并永久性保存。 mac os x 中sqlite 库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用， sqlite 是一个轻量级的嵌入式 sql 数据库编程。与 Core Data 框架不同的是， sqlite 是使用程序式的， sql 的主要的 API 来直接操作数据表。 Core Data 不是一个关系型数据库，也不是关系型数据库管理系统 (RDBMS) 。虽然 Core Dta 支持SQLite 作为一种存储类型，但它不能使用任意的 SQLite 数据库。 Core Data 在使用的过程中自己创建这个数据库。 Core Data 支持对一、对多的关系。  </p></blockquote><p>109.tableView 的重用机制？  </p><blockquote><p>答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符(reuseIdentifier),即指定了单元格的种类,以及当单元格滚出屏幕时,允许恢复单元格以便重用.对于不同种类的单元格使用不同的ID,对于简单的表格,一个标识符就够了.  </p></blockquote><p>110.是否使用过环信，简单的说下环信的实现原理  </p><blockquote><p>答：环信是一个即时通讯的服务提供商<br>环信使用的是XMPP协议，它是再XMPP的基础上进行二次开发，对服务器Openfire和客户端进行功能模型的添加和客户端SDK的封装，环信的本质还是使用XMPP，基于Socket的网络通信<br>环信内部实现了数据缓存，会把聊天记录添加到数据库，把附件（如音频文件，图片文件）下载到本地，使程序员更多时间是花到用户体验体验上。  </p></blockquote><p>111.如何绘制UIView?  </p><blockquote><p>答：绘制一个UIView最灵活的方法就是由它自己完成绘制。实际上你不是绘制一个UIView，而是子类化一个UIView并赋予绘制自己的能力。当一个UIView需要执行绘制操作时，drawRect：方法就会被调用，覆盖此方法让你获得绘图操作的机会。当drawRect：方法被调用，当前图形的上下文也被设置为属于视图的图形上下文，你可以使用Core Graphic或者UIKit提供的方法将图形画在该上下文中。  </p></blockquote><p>112.什么是MVVM？主要目的是什么？优点有哪些？  </p><blockquote><p>答：MVVM即 Model-View-ViewModel<br>1.View主要用于界面呈现，与用户输入设备进行交互、<br>2.ViewModel是MVVM架构中最重要的部分，ViewModel中包含属性，方法，事件，属性验证等逻辑，负责View与Model之间的通讯<br>3.Model就是我们常说的数据模型，用于数据的构造，数据的驱动，主要提供基础实体的属性。<br>MVVM主要目的是分离视图和模型<br>MVVM优点：低耦合，可重用性，独立开发，可测试    </p></blockquote><p>113.get请求与post请求的区别  </p><blockquote><p>答：<br>1.get是向服务器发索取数据的一种请求，而post是向服务器提交数据的一种请求<br>2.get没有请求体，post有请求体<br>3.get请求的数据会暴露在地址栏中，而post请求不会，所以post请求的安全性比get请求好<br>4.get请求对url长度有限制，而post请求对url长度理论上是不会收限制的，但是实际上各个服务器会规定对post提交数据大小进行限制。  </p></blockquote><p>114.谈谈你对多线程开发的理解？ios中有几种实现多线程的方法？  </p><blockquote><p>答：好处：<br>1.使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片，视频的下载；<br>2.发挥多核处理器的优势，并发执行让系统运行的更快，更流畅，用户体验更好；<br>缺点：<br>1.大量的线程降低代码的可读性；<br>2.更多的线程需要更多的内存空间；<br>3当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。<br>iOS有3种多线程编程的技术：1.NSThread，2.NSOperationQueue，3.GCD； </p></blockquote><p>115.XMPP工作原理；xmpp系统特点  </p><blockquote><p>答：<br>原理：<br>1.所有从一个client到另一个client的jabber消息和数据都要通过xmpp server<br>2.client链接到server<br>3.server利用本地目录系统的证书对其认证<br>4.server查找，连接并进行相互认证<br>5.client间进行交互  </p><p>特点：1）客户机/服务器通信模式；2）分布式网络；3）简单的客户端；4）XML的数据格式  </p></blockquote><p>116.地图的定位是怎么实现的？  </p><blockquote><p>答：<br>1.导入了CoreLocation.framework<br>2.ios8以后，如果需要使用定位功能，就需要请求用户授权，在首次运行时会弹框提示<br>3.通过本机自带的gps获取位置信息(即经纬度)  </p></blockquote><p>117.苹果内购实现流程  </p><blockquote><p>答：<br>1）程序通过bundle存储的plist文件得到产品标识符的列表。<br>2）程序向App Store发送请求，得到产品的信息。<br>3）App Store返回产品信息。<br>4）程序把返回的产品信息显示给用户（App的store界面）<br>5）用户选择某个产品<br>6）程序向App Store发送支付请求<br>7）App Store处理支付请求并返回交易完成信息。<br>8）App获取信息并提供内容给用户。  </p></blockquote><p>118.支付宝，微信等相关类型的sdk的集成  </p><blockquote><p>答：<br>1.在支付宝，微信开发平台创建应用并获取APPID<br>2.配置密钥<br>3.集成并配置SDK<br>4.调用接口  </p></blockquote><p>119.gcd产生死锁的原因及解锁的方法  </p><blockquote><p>答：产生死锁的必要条件：1.互斥条件，2.请求与保持条件，3.不剥夺条件，4.循环等待条件。<br>解决办法：采用异步执行block。</p></blockquote><p>120.生成二维码的步骤  </p><blockquote><p>答：<br>1.使用CIFilter滤镜类生成二维码<br>2.对生成的二维码进行加工，使其更清晰<br>3.自定义二维码背景色、填充色<br>4.自定义定位角标<br>5.在二维码中心插入小图片  </p></blockquote><p>121.在使用XMPP的时候有没有什么困难  </p><blockquote><p>答：发送附件（图片，语音，文档…）时比较麻烦，XMPP框架没有提供发送附件的功能，需要自己实现。实现方法是把文件上传到文件服务器，上传成功后获取文件保存路径，再把附件的路径发送给好友</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Object-c的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式是用继承好还是分类好？为什么？  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;答：Object-c的类不可以多重继承；可以实现多个接口，通过实现多个接口可以完成C++的多重继承
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS简单的排序算法</title>
    <link href="http://yoursite.com/2017/10/18/iOS%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/18/iOS简单的排序算法/</id>
    <published>2017-10-18T13:23:13.000Z</published>
    <updated>2017-10-18T13:24:37.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 插入算法</span></div><div class="line">- (<span class="built_in">NSArray</span> *)insertSortArray:(<span class="built_in">NSArray</span> *)originArray</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> * sortArr = [originArray mutableCopy];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="built_in">NSNumber</span> * temp;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sortArr.count; i ++)</div><div class="line">    &#123;</div><div class="line">        temp = sortArr[i];</div><div class="line">        j = i - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (j &gt; <span class="number">-1</span> &amp;&amp; [temp compare:sortArr[j]] == <span class="built_in">NSOrderedAscending</span>)</div><div class="line">        &#123;</div><div class="line">            sortArr[j + <span class="number">1</span>] = sortArr[j];</div><div class="line">            j --;</div><div class="line">        &#125;</div><div class="line">        sortArr[j + <span class="number">1</span>] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sortArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><strong>描述</strong></p><p>⒈ 从第一个元素开始，该元素可以认为已经被排序<br>⒉ 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>⒊ 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>⒋ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⒌ 将新元素插入到下一位置中<br>⒍ 重复步骤2~5  </p><p><strong>算法复杂度</strong>  </p><p>如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需<strong><code>（n-1）</code></strong>次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 <strong><code>n(n-1)/2次</code></strong> 。插入排序的赋值操作是比较操作的次数加上 <strong><code>(n-1）</code></strong>次。平均来说插入排序算法的<strong><code>时间复杂度为O(n^2）</code></strong>。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择</p><p><strong>稳定性</strong></p><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p></blockquote><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 希尔排序</span></div><div class="line">- (<span class="built_in">NSArray</span> *)shellSortArray:(<span class="built_in">NSArray</span> *)originArray</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> * sortArray = [originArray mutableCopy];</div><div class="line">    <span class="built_in">NSInteger</span>  count = originArray.count;</div><div class="line">    [<span class="keyword">self</span> shellSortArray:sortArray count:count];</div><div class="line">    <span class="keyword">return</span> sortArray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)shellSortArray:(<span class="built_in">NSMutableArray</span> *)array count:(<span class="built_in">NSInteger</span>)count</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSInteger</span> i,j,gap;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (gap = count / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)<span class="comment">//步长</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i = gap; i &lt; count; i ++)<span class="comment">//直接插入</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSNumber</span> * temp = array[i];</div><div class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; [array[j] compare:array[j + gap]] == <span class="built_in">NSOrderedDescending</span>; j -= gap) &#123;</div><div class="line">                array[j + gap] = array[j];</div><div class="line">            &#125;</div><div class="line">            array[j + gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><strong>描述</strong></p><p>希尔排序的实质就是分组插入排序，该方法又称缩小增量排序，因DL．Shell于1959年提出而得名<br><strong>基本思想</strong>：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率较高。<br>以n=10的一个数组 3,2,5,8,6,0,1,4,9,7为例（位置间隔为gap的为同一组，每次对同一组的数据进行直接插入排序）<br>第一次 gap = 10 / 2 = 5 分为五组(3,0),(2,1),(5,4),(8,9) ,(6,7) 排序完为 (0,3),(1,2),(4,5),(8,9) ,(6,7)<br>3  2  5  8  6  0  1  4  9  7  → 0  1  4  8  6  3  2  5  9  7<br>第二次 gap = 5 / 2 = 2 分为两组(0,4,6,2,9),(1,8,3,5,7) 排序完为 (0,2,4,6,9),(1,3,5,7,8)<br>0  1  4  8  6  3  2  5  9  7  → 0  1  2  3  4  5  6  7  9  8<br>第三次 gap = 2 / 2 = 1 分为一组(0,1,2,3,4,5,6,7,9,8) 排序完为(0,1,2,3,4,5,6,7,8,9)<br>0  1  2  3  4  5  6  7  9  8  → 0  1  2  3  4  5  6  7  8  9<br>第四次 gap = 1 / 2 = 0 排序完成得到数组<br>0  1  2  3  4  5  6  7  8  9</p></blockquote><h3 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 归并算法</span></div><div class="line">- (<span class="built_in">NSArray</span> *)mergeSortArray:(<span class="built_in">NSArray</span> *)array</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> * tempArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:array.count];</div><div class="line">    <span class="built_in">NSMutableArray</span> * sortArray = [array mutableCopy];</div><div class="line">    [<span class="keyword">self</span> mergeSortArray:sortArray tempArray:tempArray startIndex:<span class="number">0</span> endIndex:sortArray.count - <span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> sortArray;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)mergeSortArray:(<span class="built_in">NSMutableArray</span> *)array  tempArray:(<span class="built_in">NSMutableArray</span> *)tempArray startIndex:(<span class="built_in">NSInteger</span>)startIndex endIndex:(<span class="built_in">NSInteger</span>)endIndex</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">NSInteger</span> middleIndex = (endIndex - startIndex) / <span class="number">2</span> + startIndex;</div><div class="line">    [<span class="keyword">self</span> mergeSortArray:array tempArray:tempArray startIndex:startIndex endIndex:middleIndex];</div><div class="line">    [<span class="keyword">self</span> mergeSortArray:array tempArray:tempArray startIndex:middleIndex + <span class="number">1</span> endIndex:endIndex];</div><div class="line">    [<span class="keyword">self</span> mergeSortArray:array tempArray:tempArray startIndex:startIndex middleIndex:middleIndex endIndex:endIndex];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)mergeSortArray:(<span class="built_in">NSMutableArray</span> *)array tempArray:(<span class="built_in">NSMutableArray</span> *)tempArray startIndex:(<span class="built_in">NSInteger</span>)startIndex middleIndex:(<span class="built_in">NSInteger</span>)middleIndex endIndex:(<span class="built_in">NSInteger</span>)endIndex</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = startIndex; i &lt;= endIndex; i ++)</div><div class="line">    &#123;</div><div class="line">        tempArray[i]  = array[i];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSInteger</span> leftIndex = startIndex;</div><div class="line">    <span class="built_in">NSInteger</span> rightIndex = middleIndex + <span class="number">1</span>;</div><div class="line">    <span class="built_in">NSInteger</span> currentIndex = startIndex;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (leftIndex &lt;= middleIndex &amp;&amp; rightIndex &lt;= endIndex)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ([tempArray[leftIndex] compare:tempArray[rightIndex]] != <span class="built_in">NSOrderedDescending</span>)</div><div class="line">        &#123;</div><div class="line">            array[currentIndex] = tempArray[leftIndex];</div><div class="line">            leftIndex ++;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            array[currentIndex] = tempArray[rightIndex];</div><div class="line">            rightIndex ++;</div><div class="line">        &#125;</div><div class="line">        currentIndex ++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (middleIndex - leftIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= middleIndex - leftIndex; i ++)</div><div class="line">        &#123;</div><div class="line">            array[currentIndex + i] = tempArray[leftIndex + i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><strong>定义</strong></p><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为<code>二路归并</code>。</p><p><strong>描述</strong></p><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾<br>4.将另一序列剩下的所有元素直接复制到合并序列尾</p><p><strong>算法复杂度</strong></p><p>时间复杂度为O(nlog₂n) 这是该算法中最好、最坏和平均的时间性能。<br>空间复杂度为 O(n)<br>比较操作的次数介于(nlogn) / 2和nlogn - n + 1。<br>赋值操作的次数是(2nlogn)。归并算法的空间复杂度为：0 (n)<br>归并排序比较占用内存，但却是一种效率高(仅次于快速排序)且稳定的算法。 </p></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 冒泡排序</span></div><div class="line">- (<span class="built_in">NSArray</span> *)bubbleSortArray:(<span class="built_in">NSArray</span> *)originArray</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> * sortArray = [originArray mutableCopy];</div><div class="line">    <span class="built_in">NSNumber</span> * temp;</div><div class="line">    <span class="built_in">NSInteger</span> count = originArray.count;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j ++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span> - j; i ++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> ([sortArray[i] compare:sortArray[i + <span class="number">1</span>]] == <span class="built_in">NSOrderedDescending</span>)</div><div class="line">            &#123;</div><div class="line">                temp = sortArray[i];</div><div class="line">                sortArray[i] = sortArray[i + <span class="number">1</span>];</div><div class="line">                sortArray[i + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sortArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><strong>描述</strong></p><p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3.针对所有的元素重复以上的步骤，除了最后一个。<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较  </p><p><strong>算法复杂度</strong></p><p>平均时间复杂度也是：O(n^2)<br>最优的情况下时间复杂度为：O(n)<br>最差的情况下时间复杂度为：O(n^2)   </p><p><strong>稳定性</strong></p><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p></blockquote><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 快速排序</span></div><div class="line">- (<span class="built_in">NSArray</span> *)quickSortArray:(<span class="built_in">NSArray</span> *)originArray</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> * sortArray = [originArray mutableCopy];</div><div class="line">    [<span class="keyword">self</span> quickSortArray:sortArray left:<span class="number">0</span> right:originArray.count - <span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> sortArray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)quickSortArray:(<span class="built_in">NSMutableArray</span> *)array left:(<span class="built_in">NSInteger</span>)left right:(<span class="built_in">NSInteger</span>)right</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSInteger</span> i = left;</div><div class="line">    <span class="built_in">NSInteger</span> j = right;</div><div class="line">    <span class="built_in">NSNumber</span> * key = array[left];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (i &lt; j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [key compare:array[j]] == <span class="built_in">NSOrderedAscending</span>)</div><div class="line">        &#123;<span class="comment">//而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升序还是降序）2，没有符合条件1的，并且i与j的大小没有反转</span></div><div class="line">            j --;<span class="comment">//向前寻找</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        array[i] = array[j];</div><div class="line">        <span class="comment">//找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是array[left]，那么就是给key）</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; [key compare:array[i]] == <span class="built_in">NSOrderedDescending</span>)</div><div class="line">        &#123;<span class="comment">//这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反,因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反</span></div><div class="line">            i ++;</div><div class="line">        &#125;</div><div class="line">        array[j] = array[i];</div><div class="line">    &#125;</div><div class="line">    array[i] = key;<span class="comment">//当在当组内找完一遍以后就把中间数key回归</span></div><div class="line">    [<span class="keyword">self</span> quickSortArray:array left:left right:i - <span class="number">1</span>];<span class="comment">//最后用同样的方式对分出来的左边的小组进行同上的做法</span></div><div class="line">    [<span class="keyword">self</span> quickSortArray:array left:i + <span class="number">1</span> right:right];<span class="comment">//用同样的方式对分出来的右边的小组进行同上的做法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><strong>描述</strong></p><p>快速排序是对冒泡排序的一种改进。<br>一趟快速排序的算法是：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。  </p><p><strong>算法复杂度</strong></p><p>快速排序的平均时间复杂度也是：O(nlogn)<br>快速排序最优的情况下时间复杂度为：O( nlogn )<br>最差的情况下时间复杂度为：O( n^2 )<br>最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况<br>最差的情况下空间复杂度为：O( n )      ；退化为冒泡排序的情况  </p></blockquote><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre><code class="objectivec"><span class="meta">#pragma mark - 选择排序</span>- (<span class="built_in">NSArray</span> *)selectSortArray:(<span class="built_in">NSArray</span> *)originArray{    <span class="built_in">NSMutableArray</span> * sortArray = [originArray mutableCopy];    <span class="built_in">NSNumber</span> * min;    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; sortArray.count - <span class="number">1</span>; i ++)    {        min = sortArray[i];        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> j = i + <span class="number">1</span>; j &lt; sortArray.count; j ++)        {            <span class="keyword">if</span> ([min compare:sortArray[j]] == <span class="built_in">NSOrderedDescending</span>) {                <span class="built_in">NSNumber</span> * temp = sortArray[j];                sortArray[j] = min;                min = temp;            }        }        sortArray[i] = min;    }    <span class="keyword">return</span> sortArray;}</code></pre><blockquote><p><strong>描述</strong></p><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p><p><strong>时间复杂度</strong>  </p><p>选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://yoursite.com/2017/10/12/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/12/面试题/</id>
    <published>2017-10-12T15:04:18.000Z</published>
    <updated>2017-10-12T16:09:59.354Z</updated>
    
    <content type="html"><![CDATA[<p>1.你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？  </p><p>2.你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？  </p><p>3.Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）  </p><p>4.是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。  </p><p>5.NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了…）  </p><p>6.你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。  </p><p>7.既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？  </p><p>8.您是否做过异步的网络处理和通讯方面的工作？如果有，能具体介绍一些实现策略么？  </p><p>9.对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？  </p><p>10.你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？  &lt;/p&gt;
&lt;p&gt;2.你实现过多线程的Core Data么？NSPersistentStoreCo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小知识点</title>
    <link href="http://yoursite.com/2017/10/12/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2017/10/12/小知识点/</id>
    <published>2017-10-12T13:30:11.000Z</published>
    <updated>2017-10-12T13:30:46.551Z</updated>
    
    <content type="html"><![CDATA[<p>1、在由NSString生成NSURL对象时，有可能会出现NSString中包含百分号各类括号冒号等对于url来说的非法字符如果直接进行转换的话将得到nil。在对于复杂url进行转换前，可以先试试对待转换的NSString发送 stringByAddingPercentEscapesUsingEncoding: 将其转换为合法的url字符串（其实目的就是保证非法字符用UTF8编码..） 比如这样：  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *fixedStr = [reqStr stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div></pre></td></tr></table></figure><p>2、利用代码添加autolayout约束  </p><ul><li><p>纯OC代码   </p><ul><li>在storyboard中的一条约束在代码中的体现就是一个约束对象，所以添加在storyboard上添加一条约束，相当于创建了一个约束对象并将该约束对象添加到对应的视图上  </li><li>第一步：创建子控件视图</li><li>第二步：禁用子控件的autoresizing属性</li><li>第三步：创建约束对象</li><li>第四步：添加约束对象</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"> - (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 1.创建一个子视图，添加到父视图上面</span></div><div class="line">    <span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:redView];</div><div class="line"><span class="meta">#warning 注意点: 如果通过代码来设置Autolayout约束, 那么必须先禁用Autoresizing</span></div><div class="line">    <span class="comment">// 2.禁用autoresizing</span></div><div class="line">    <span class="comment">// 2.1给需要设置约束的视图禁用autoresizing，禁用父视图autoresizing对子控件无效</span></div><div class="line">    <span class="comment">//self.view.translatesAutoresizingMaskIntoConstraints = NO;//错误写法</span></div><div class="line">    redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 3.添加约束</span></div><div class="line">    <span class="comment">// 3.1红色(红色距离顶部和左边以及右边的边距固定为20，高度固定为50)</span></div><div class="line">    <span class="comment">// 3.1.1顶部(基于父控件)</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     constraintWithItem:需要设置约束的view</div><div class="line">     attribute:需要设置约束的位置</div><div class="line">     relatedBy:约束的条件</div><div class="line">     toItem:约束依赖目标</div><div class="line">     attribute:依赖目标约束位置</div><div class="line">     multiplier:配置系数</div><div class="line">     constant:额外需要添加的长度</div><div class="line">     */</div><div class="line">     <span class="comment">/*</span></div><div class="line">     计算公式:redView.attribute = self.view.attribute * multiplier + constant;</div><div class="line">     其中:＝符号取决于relatedBy:参数</div><div class="line">     typedef NS_ENUM(NSInteger, NSLayoutRelation) &#123;</div><div class="line">     NSLayoutRelationLessThanOrEqual = -1,   小于等于</div><div class="line">     NSLayoutRelationEqual = 0,              等于</div><div class="line">     NSLayoutRelationGreaterThanOrEqual = 1, 大于等于</div><div class="line">     &#125;;</div><div class="line">     */</div><div class="line">    <span class="comment">// 3.1.1.1创建约束对象</span></div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *redTopCos = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeTop</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeTop</span> multiplier:<span class="number">1.0</span> constant:<span class="number">20</span>];</div><div class="line">    <span class="comment">// 3.1.1.2判断约束条件的层级关系，并添加到对应的视图</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:redTopCos];</div><div class="line">    <span class="comment">/*</span></div><div class="line">     attribute:传入的是枚举参数</div><div class="line">     NSLayoutAttributeLeft = 1,  左边距</div><div class="line">     NSLayoutAttributeRight,     右边距</div><div class="line">     NSLayoutAttributeTop,       距离顶部边距</div><div class="line">     NSLayoutAttributeBottom,    距离底部边距</div><div class="line">     NSLayoutAttributeLeading,   左对齐</div><div class="line">     NSLayoutAttributeTrailing,  右对齐</div><div class="line">     NSLayoutAttributeWidth,     宽度</div><div class="line">     NSLayoutAttributeHeight,    高度</div><div class="line">     NSLayoutAttributeCenterX,   中点X</div><div class="line">     NSLayoutAttributeCenterY,   中点Y</div><div class="line">     NSLayoutAttributeBaseline,  文本底线对齐</div><div class="line">     */</div><div class="line">    <span class="comment">// 3.1.2左边约束(基于父控件)</span></div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *redLeftCos = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeLeft</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeLeft</span> multiplier:<span class="number">1.0</span> constant:<span class="number">20</span>];</div><div class="line">    <span class="comment">// 3.1.2.2判断约束条件的层级关系，并添加到对应的视图</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:redLeftCos];</div><div class="line"></div><div class="line">    <span class="comment">// 3.1.3右边约束(基于父控件)</span></div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *redRightCos = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeRight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeRight</span> multiplier:<span class="number">1.0</span> constant:<span class="number">-20</span>];</div><div class="line">    <span class="comment">// 3.1.3.2判断约束条件的层级关系，并添加到对应的视图</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:redRightCos];</div><div class="line"></div><div class="line">    <span class="comment">// 3.1.4 高度约束(自身)</span></div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *redHeightCos = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeHeight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="number">0</span> multiplier:<span class="number">1.0</span> constant:<span class="number">50</span>];</div><div class="line">    <span class="comment">// 3.1.3.2判断约束条件的层级关系，并添加到对应的视图</span></div><div class="line">    [redView addConstraint:redHeightCos];</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li>VFL语言实现约束的添加</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 1.创建二个子视图，添加到父视图上面</span></div><div class="line">    <span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:redView];</div><div class="line"></div><div class="line">    <span class="built_in">UIView</span> *blueView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    blueView.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:blueView];</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#warning 注意点: 如果通过代码来设置Autolayout约束, 那么必须先禁用Autoresizing</span></div><div class="line">    <span class="comment">// 2.禁用autoresizing</span></div><div class="line">    <span class="comment">// 2.1给需要设置约束的视图禁用autoresizing，禁用父视图autoresizing对子控件无效</span></div><div class="line">    <span class="comment">//self.view.translatesAutoresizingMaskIntoConstraints = NO;//错误写法</span></div><div class="line">    redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">    blueView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 3.添加约束</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     VisualFormat: VFL语句</div><div class="line">     options: 对齐方式等</div><div class="line">     metrics: VFL语句中使用到的一些变量</div><div class="line">     views: VFL语句中使用到的一些控件</div><div class="line">     */</div><div class="line">    <span class="comment">// 3.1红色视图</span></div><div class="line">    <span class="comment">// 水平方向</span></div><div class="line">    <span class="built_in">NSArray</span> *hCos = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-20-[redView]-20-|"</span> options:kNilOptions metrics:<span class="literal">nil</span> views:<span class="built_in">NSDictionaryOfVariableBindings</span>(redView)];</div><div class="line">    [<span class="keyword">self</span>.view addConstraints:hCos];</div><div class="line"></div><div class="line">    <span class="comment">//竖直方向</span></div><div class="line"></div><div class="line">    <span class="built_in">NSArray</span> *vCos = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:|-20-[redView(==50)]"</span> options:kNilOptions metrics:<span class="literal">nil</span> views:<span class="built_in">NSDictionaryOfVariableBindings</span>(redView)];</div><div class="line">    [<span class="keyword">self</span>.view addConstraints:vCos];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 3.2蓝色视图</span></div><div class="line">    <span class="comment">// 垂直方向</span></div><div class="line">    <span class="built_in">NSArray</span> *vBlueCos = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:[redView]-20-[blueView(==50)]"</span> options:<span class="built_in">NSLayoutFormatAlignAllRight</span> metrics:<span class="literal">nil</span> views:<span class="built_in">NSDictionaryOfVariableBindings</span>(redView,blueView)];</div><div class="line">    [<span class="keyword">self</span>.view addConstraints:vBlueCos];</div><div class="line">    <span class="comment">// 水平方向</span></div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *hBlueCos = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:blueView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:redView attribute:<span class="built_in">NSLayoutAttributeWidth</span> multiplier:<span class="number">0.5</span> constant:<span class="number">0.0</span>];</div><div class="line">    [<span class="keyword">self</span>.view addConstraint:hBlueCos];</div><div class="line">    <span class="comment">/*VFL格式说明</span></div><div class="line">     功能　　　　　　　　表达式</div><div class="line">     水平方向  　　　　　 H:</div><div class="line">     垂直方向  　　　　　 V:</div><div class="line">     Views　　　　　　　　[view]</div><div class="line">     SuperView　　　　　 |</div><div class="line">     关系　　　　　　　　　&gt;=,==,&lt;=</div><div class="line">     空间,间隙　　　　　　　-</div><div class="line">     优先级　　　　　　　　@value</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>-(void)addConstraint:(NSLayoutConstraint *)constraint; 用来将约束添加到view。在添加时唯一要注意的是添加的目标view要遵循以下规则：  <ul><li>对于两个同层级view之间的约束关系，添加到他们的父view上<br><img src="http://oui2ar2u7.bkt.clouddn.com/83bbf18dgw1dx3236wmnnj.jpg" alt="">  </li><li>对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上<br><img src="http://oui2ar2u7.bkt.clouddn.com/83bbf18dgw1dx3237dsbxj.jpg" alt="">  </li><li>对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上<br><img src="http://oui2ar2u7.bkt.clouddn.com/83bbf18dgw1dx32384ardj.jpg" alt="">  </li></ul></li></ul><p>&gt;<br>可以通过-setNeedsUpdateConstraints和-layoutIfNeeded两个方法来刷新约束的改变，使UIView重新布局。这和CoreGraphic的-setNeedsDisplay一套东西是一样的～</p><p>具体可以看<a href="https://onevcat.com/2012/09/autoayout/" target="_blank" rel="external">喵神的AutoLayout（自动布局）入门</a></p><p>3、iOS 11实现左长滑删除cell </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现代理方法</span></div><div class="line">- (<span class="built_in">UISwipeActionsConfiguration</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView trailingSwipeActionsConfigurationForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">//删除</span></div><div class="line">    <span class="built_in">UIContextualAction</span> * deleteRowAction = [<span class="built_in">UIContextualAction</span> contextualActionWithStyle:<span class="built_in">UIContextualActionStyleDestructive</span> title:<span class="string">@"delete"</span> handler:^(<span class="built_in">UIContextualAction</span> * _Nonnull action, __kindof <span class="built_in">UIView</span> * _Nonnull sourceView, <span class="keyword">void</span> (^ _Nonnull completionHandler)(<span class="built_in">BOOL</span>)) &#123;</div><div class="line">        completionHandler(<span class="literal">YES</span>);</div><div class="line">    &#125;];</div><div class="line">    deleteRowAction.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">UISwipeActionsConfiguration</span> configurationWithActions:@[deleteRowAction]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在由NSString生成NSURL对象时，有可能会出现NSString中包含百分号各类括号冒号等对于url来说的非法字符如果直接进行转换的话将得到nil。在对于复杂url进行转换前，可以先试试对待转换的NSString发送 stringByAddingPercentEs
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用blend修改图片的颜色</title>
    <link href="http://yoursite.com/2017/10/12/%E7%94%A8blend%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
    <id>http://yoursite.com/2017/10/12/用blend修改图片的颜色/</id>
    <published>2017-10-12T13:28:45.000Z</published>
    <updated>2017-10-12T13:29:32.348Z</updated>
    
    <content type="html"><![CDATA[<h4 id="现在存在的问题"><a href="#现在存在的问题" class="headerlink" title="现在存在的问题"></a>现在存在的问题</h4><p>如果一个APP中可以根据用户喜好，更改APP中图片的颜色，则设计师必须重复修改图片，开发者图片文件重命名、移动和导入无用功较多，下载安装包较大。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>用blending给这张图片加上另一个纯色作为tint，并保持原来的alpha通道，然后结合Core Graphics。步骤如下：  </p><blockquote><p>1.创建一个上下文用以画新的图片<br>2.将新的tintColor设置为填充颜色<br>3.将原图片画在创建的上下文中，并用新的填充色着色（注意保持alpha通道）<br>4.从当前上下文中取得图片并返回 </p></blockquote><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>UIImage+tint</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIImage+tint.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">tint</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">UIImage</span> *)imageWithTintColor:(<span class="built_in">UIColor</span> *)tintColor blendMode:(<span class="built_in">CGBlendMode</span>)blendMode</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</div><div class="line">    [tintColor setFill];<span class="comment">//填充颜色</span></div><div class="line">    <span class="built_in">CGRect</span> bounds = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</div><div class="line">    <span class="built_in">UIRectFill</span>(bounds);</div><div class="line">    <span class="comment">//设置绘画透明混合模式和透明度</span></div><div class="line">    [<span class="keyword">self</span> drawInRect:bounds blendMode:blendMode alpha:<span class="number">1.0</span>f];</div><div class="line">    <span class="keyword">if</span> (blendMode == kCGBlendModeOverlay) &#123;</div><div class="line">        <span class="comment">//保留透明度信息</span></div><div class="line">        [<span class="keyword">self</span> drawInRect:bounds blendMode:kCGBlendModeDestinationIn alpha:<span class="number">1.0</span>f];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">UIImage</span> * tintedImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> tintedImage;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>ViewController</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"UIImage+tint.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> * imageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> * msgLabel;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    [<span class="keyword">self</span> createUI];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createUI</div><div class="line">&#123;</div><div class="line">    _imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>]];</div><div class="line">    _imageView.center = <span class="keyword">self</span>.view.center;</div><div class="line">    _imageView.userInteractionEnabled = <span class="literal">YES</span>;</div><div class="line">    <span class="built_in">UITapGestureRecognizer</span> * tap = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(changeBlendMode:)];</div><div class="line">    tap.numberOfTouchesRequired = <span class="number">1</span>;</div><div class="line">    tap.numberOfTapsRequired = <span class="number">1</span>;</div><div class="line">    [_imageView addGestureRecognizer:tap];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:_imageView];</div><div class="line">    </div><div class="line">    _msgLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">20</span>, <span class="built_in">CGRectGetMaxY</span>(_imageView.frame) + <span class="number">20</span>, <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.view.frame) - <span class="number">40</span>, <span class="number">120</span>)];</div><div class="line">    _msgLabel.numberOfLines = <span class="number">0</span>;</div><div class="line">    _msgLabel.text = <span class="string">@"在屏幕中绘图时设置透明度；点击图片切换为混合模式绘制的图片"</span>;</div><div class="line">    _msgLabel.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</div><div class="line">    _msgLabel.textColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">    _msgLabel.layer.borderColor = [<span class="built_in">UIColor</span> grayColor].CGColor;</div><div class="line">    _msgLabel.layer.borderWidth = <span class="number">1.0</span>;</div><div class="line">    [<span class="keyword">self</span>.view addSubview:_msgLabel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)changeBlendMode:(<span class="built_in">UIGestureRecognizer</span>*)gesture</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">CGBlendMode</span> blendMode = kCGBlendModeNormal;</div><div class="line">    <span class="built_in">NSString</span> *strMsg;</div><div class="line">    <span class="keyword">switch</span> (blendMode) &#123;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeNormal:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeNormal:正常；也是默认的模式。前景图会覆盖背景图"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeMultiply:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeMultiply:正片叠底；混合了前景和背景的颜色，最终颜色比原来的都暗"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeScreen:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeScreen:滤色；把前景和背景图的颜色先反过来，然后混合"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeOverlay:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeOverlay:覆盖：能保留灰度信息，结合kCGBlendModeDestinationIn能保留透明度信息，在imageWithBlendMode方法中两次执行drawInRect方法实现我们的基本需求"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeDarken:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeDarken:变暗"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeLighten:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeLighten:变亮"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeColorDodge:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeColorDodge:颜色变淡"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeColorBurn:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeColorBurn:颜色加深"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeHardLight:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeHardLight:强光"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeSoftLight:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeSoftLight:柔光"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeDifference:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeDifference:插值"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeExclusion:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeExclusion:排除"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeHue:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeHue:色调"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeSaturation:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeSaturation:饱和度"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeColor:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeColor:颜色"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeLuminosity:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeLuminosity:亮度"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">            <span class="comment">//Apple额外定义的枚举</span></div><div class="line">            <span class="comment">//R: premultiplied result, 表示混合结果</span></div><div class="line">            <span class="comment">//S: Source, 表示源颜色(Sa对应透明度值: 0.0-1.0)</span></div><div class="line">            <span class="comment">//D: destination colors with alpha, 表示带透明度的目标颜色(Da对应透明度值: 0.0-1.0)</span></div><div class="line">        <span class="keyword">case</span> kCGBlendModeClear:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeClear:R = 0"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeCopy:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeCopy:R = S"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeSourceIn:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeSourceIn:R = S * Da"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeSourceOut:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeSourceOut:R = S * (1 - Da)"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeSourceAtop:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeSourceAtop:R = S * Da + D * (1 - Da)"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeDestinationOver:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeDestinationOver:R = S * (1 - Da) + D"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeDestinationIn:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeDestinationIn: R = D * Sa;保留透明度信息"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeDestinationOut:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeDestinationOut: R = D * (1 - Sa)"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeDestinationAtop:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeDestinationAtop: R = S * (1 - Da) + D * Sa"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModeXOR:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModeXOR: R = S * (1 - Da) + D * (1 - Sa)"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModePlusDarker:</div><div class="line">            strMsg = <span class="string">@"KCGBlendModePlusDarker: R = MAX(0, (1 - D) + (1 - S))"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCGBlendModePlusLighter:</div><div class="line">            strMsg = <span class="string">@"kCGBlendModePlusLighter: R = MIN(1, S + D)（最后一种混合模式）"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    _imageView.image = [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>] imageWithTintColor:[<span class="built_in">UIColor</span> orangeColor] blendMode:blendMode];</div><div class="line">    _msgLabel.text = strMsg;</div><div class="line">    </div><div class="line">    blendMode ++;</div><div class="line">    <span class="keyword">if</span> (blendMode &gt; kCGBlendModePlusLighter) &#123;</div><div class="line">        blendMode = kCGBlendModeNormal;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</div><div class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</div><div class="line">    <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><blockquote><p>注：用kCGBlendModeOverlay能保留灰度信息，用kCGBlendModeDestinationIn能保留透明度信息。<br>因为每次使用UIImage+tint的方法绘图时，都使用了CG的绘制方法，这就意味着每次调用都会是用到CPU的Offscreen drawing，大量使用的话可能导致性能的问题。对于这里的UIImage+tint的实现，可以写一套缓存的机制，来确保大量重复的元素只在load的时候blend一次，之后将其缓存在内存中以快速读取。这是一个权衡的问题，在时间和空间中做出正确的平衡和选择是程序设计的乐趣所在。</p></blockquote><p>参考链接<br><a href="https://onevcat.com/2013/04/using-blending-in-ios/" target="_blank" rel="external">iOS中使用blend改变图片颜色</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;现在存在的问题&quot;&gt;&lt;a href=&quot;#现在存在的问题&quot; class=&quot;headerlink&quot; title=&quot;现在存在的问题&quot;&gt;&lt;/a&gt;现在存在的问题&lt;/h4&gt;&lt;p&gt;如果一个APP中可以根据用户喜好，更改APP中图片的颜色，则设计师必须重复修改图片，开发者图片文件重
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS改变状态栏文字颜色</title>
    <link href="http://yoursite.com/2017/08/31/iOS%E6%94%B9%E5%8F%98%E7%8A%B6%E6%80%81%E6%A0%8F%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/"/>
    <id>http://yoursite.com/2017/08/31/iOS改变状态栏文字颜色/</id>
    <published>2017-08-30T23:48:08.000Z</published>
    <updated>2017-08-30T23:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS改变状态栏文字颜色"><a href="#iOS改变状态栏文字颜色" class="headerlink" title="iOS改变状态栏文字颜色"></a>iOS改变状态栏文字颜色</h4><p>UINavigationController不会将<strong>preferredStatusBarStyle</strong>方法调用转给它的子视图,而是由它<strong>自己管理状态</strong>,而且它也应该那样做.因为<strong>UINavigationController</strong>包含了它自己的状态栏因此就算<strong>UINavigationController</strong>中的<strong>viewController</strong>实现了<strong>preferredStatusBarStyle</strong>方法 也不会调用那<strong>UINavigationController</strong>是怎么决定 该返回<strong>UIStatusBarStyleLightContent</strong>还是<strong>UIStatusBarStyleDefault</strong>的呢? 它是基于它的<strong>UINavigationBar.barStyle</strong>属性.默认<strong>(UIBarStyleDefault)</strong>的是<strong>黑色</strong>文本的状态栏 而<strong>UIBarStyleBlack</strong>是设置为<strong>白色</strong>文本的状态栏。</p><p>可以在自定义的导航控制器中或者系统导航控制器中的类别中添加代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIStatusBarStyle</span>)preferredStatusBarStyle</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.topViewController.preferredStatusBarStyle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>比如有这样的一个需求，默认大多数界面的状态栏文本颜色为白色，个别为黑色，可以为项目中自定义的父控制器或者UIViewController的类别中添加代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIStatusBarStyle</span>)preferredStatusBarStyle</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIStatusBarStyleLightContent</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在需要的改变的个别页面中添加代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIStatusBarStyle</span>)preferredStatusBarStyle</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIStatusBarStyleLightContent</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>注意：info里面如果你加了View controller-based status bar appearance,设置为YES,如果设置为NO，上面的代码没效果</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;iOS改变状态栏文字颜色&quot;&gt;&lt;a href=&quot;#iOS改变状态栏文字颜色&quot; class=&quot;headerlink&quot; title=&quot;iOS改变状态栏文字颜色&quot;&gt;&lt;/a&gt;iOS改变状态栏文字颜色&lt;/h4&gt;&lt;p&gt;UINavigationController不会将&lt;stro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS查看子视图</title>
    <link href="http://yoursite.com/2017/08/31/iOS%E6%9F%A5%E7%9C%8B%E5%AD%90%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/08/31/iOS查看子视图/</id>
    <published>2017-08-30T23:47:27.000Z</published>
    <updated>2017-08-30T23:49:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS遍历打印所有子视图"><a href="#iOS遍历打印所有子视图" class="headerlink" title="iOS遍历打印所有子视图"></a>iOS遍历打印所有子视图</h4><p>有时我们想看一下系统的view比如导航条的子视图结构，可以用下面的代码来实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归获取子视图</span></div><div class="line">- (<span class="keyword">void</span>)getSub:(<span class="built_in">UIView</span> *)view andLevel:(<span class="keyword">int</span>)level &#123;</div><div class="line">    <span class="built_in">NSArray</span> *subviews = [view subviews];</div><div class="line"></div><div class="line">    <span class="comment">// 如果没有子视图就直接返回</span></div><div class="line">    <span class="keyword">if</span> ([subviews count] == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> subviews) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 根据层级决定前面空格个数，来缩进显示</span></div><div class="line">        <span class="built_in">NSString</span> *blank = <span class="string">@""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level; i++) &#123;</div><div class="line">            blank = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"  %@"</span>, blank];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 打印子视图类名</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@%d: %@"</span>, blank, level, subview.class);</div><div class="line"></div><div class="line">        <span class="comment">// 递归获取此视图的子视图</span></div><div class="line">        [<span class="keyword">self</span> getSub:subview andLevel:(level+<span class="number">1</span>)];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印导航条</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 打印所有子视图</span></div><div class="line">[<span class="keyword">self</span> getSub:<span class="keyword">self</span>.navigationController.navigationBar andLevel:<span class="number">1</span>];</div></pre></td></tr></table></figure><p><img src="http://oui2ar2u7.bkt.clouddn.com/2017-08-28.png" alt=""> </p><h4 id="OC中load方法和initialize方法的异同"><a href="#OC中load方法和initialize方法的异同" class="headerlink" title="OC中load方法和initialize方法的异同"></a>OC中load方法和initialize方法的异同</h4><p>+load</p><p>首先，load方法是一定会在runtime中被调用的，只要类被添加到runtime中了，就会调用load方法，所以我们可以自己实现laod方法来在这个时候执行一些行为。</p><p>而且有意思的一点是，load方法不会覆盖。也就是说，如果子类实现了load方法，那么会先调用父类的load方法，然后又去执行子类的load方法。同样的，如果分类实现了load方法，也会先执行主类的load方法，然后又会去执行分类的load方法。所以父类的load会执行很多次，这一点需要注意。而且执行顺序是 类 -&gt; 子类 -&gt;分类。而不同类之间的顺序不一定。</p><p>+initialize</p><p>与load不同的是，initialize方法不一定会执行。只有当一个类第一次被发送消息的时候会执行，注意是第一次。什么叫发送消息呢，就是执行类的一些方法的时候。也就是说这个方法是懒加载，没有用到这个类就不会调用，可以节省系统资源。</p><p>还有一点截然相反，却更符合我们预期的就是，initialize方法会覆盖。也就是说如果子类实现了initialize方法，就不会执行父类的了，直接执行子类本身的。如果类别实现了initialize方法，也不会再执行主类的。所以initialize方法的执行覆盖顺序是 子类类别 -&gt; 子类 -&gt; 父类类别 -&gt;类。且只会有一个initialize方法被执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;iOS遍历打印所有子视图&quot;&gt;&lt;a href=&quot;#iOS遍历打印所有子视图&quot; class=&quot;headerlink&quot; title=&quot;iOS遍历打印所有子视图&quot;&gt;&lt;/a&gt;iOS遍历打印所有子视图&lt;/h4&gt;&lt;p&gt;有时我们想看一下系统的view比如导航条的子视图结构，可以用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS自定义导航条</title>
    <link href="http://yoursite.com/2017/08/27/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%9D%A1/"/>
    <id>http://yoursite.com/2017/08/27/iOS自定义导航条/</id>
    <published>2017-08-27T12:35:19.000Z</published>
    <updated>2017-08-27T12:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="调整导航条的按钮的位置"><a href="#调整导航条的按钮的位置" class="headerlink" title="调整导航条的按钮的位置"></a>调整导航条的按钮的位置</h4><p>在自定义导航条左侧返回按钮，返回按钮明显会有点偏右，应该如何调整的，由于导航栏的<strong>NavigationItem</strong>是个比较特殊的<strong>View</strong>，设置<strong>Frame</strong>是行不通的，在苹果提供的<strong>UIButtonBarItem</strong>中有个叫做<strong>UIBarButtonSystemItemFixedSpace</strong>的控件，利用它，我们就可以轻松调整返回按钮的位置,具体代码如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> leftBtn = <span class="type">UIButton</span>(type: .custom)</div><div class="line">leftBtn.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">25</span>, height: <span class="number">25</span>)</div><div class="line">leftBtn.setBackgroundImage(<span class="type">UIImage</span>(named: <span class="string">"back"</span>), <span class="keyword">for</span>: .normal)</div><div class="line">leftBtn.addTarget(<span class="keyword">self</span>, action: #selector(leftBarBtnClicked(btn:)), <span class="keyword">for</span>: .touchUpInside);</div><div class="line"><span class="keyword">let</span> leftBarBtn = <span class="type">UIBarButtonItem</span>(customView: leftBtn)</div><div class="line">        </div><div class="line"><span class="comment">//创建UIBarButtonSystemItemFixedSpace</span></div><div class="line"><span class="keyword">let</span> spaceItem = <span class="type">UIBarButtonItem</span>(barButtonSystemItem: .fixedSpace, target: <span class="literal">nil</span>, action: <span class="literal">nil</span>)</div><div class="line">        </div><div class="line"><span class="comment">//将宽度设置为负值</span></div><div class="line">spaceItem.width = -<span class="number">15</span>;</div><div class="line">        </div><div class="line"><span class="comment">//将两个BarButtonItem都返回给NavigationItem</span></div><div class="line">navigationItem.leftBarButtonItems = [spaceItem,leftBarBtn];</div><div class="line">```  </div><div class="line">调整完可以棉线看到返回按钮已经紧靠着屏幕边缘，`这个方法同样适用于调整导航栏右侧的按钮`  </div><div class="line"></div><div class="line">#### 让滑动返回手势生效</div><div class="line">适用自定义的按钮去替换系统默认的返回按钮，会出现滑动返回手势失效的情况。可以通过重新添加导航栏的`interactivePopGestureRecognizer`的`delegate`即可。  </div><div class="line">首先为<span class="type">ViewController</span>添加`<span class="type">UIGestureRecognizerDelegate</span>`协议  </div><div class="line"></div><div class="line">```swift</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstViewController</span>: <span class="title">UIViewController</span>,<span class="title">UIGestureRecognizerDelegate</span> </span>&#123;&#125;</div></pre></td></tr></table></figure><p>然后设置代理  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">navigationController?.interactivePopGestureRecognizer?.delegate = <span class="keyword">self</span>;</div></pre></td></tr></table></figure><h4 id="全屏滑动返回"><a href="#全屏滑动返回" class="headerlink" title="全屏滑动返回"></a>全屏滑动返回</h4><p>(1)系统自带的手势是<code>UIScreenEdgePanGestureRecognizer</code>类型对象，看名字就知道这个是屏幕边缘滑动手势。所以系统自带的滑动效果，自然只能实现侧边滑动。<br>(2)我们自己给导航控制器添加UIGestureRecognizerDelegate协议，添加一个全屏的滑动手势。然后用新添加的滑动手势，来调用系统实现的滑动返回功能（<code>handleNavigationTransition</code> 方法），这样就实现了全屏滑动功能。<br>(3)注意：我们还要禁止系统自带滑动手势，同时只有非根控制器才有滑动返回功能，根控制器没有。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNavigationController</span>: <span class="title">UINavigationController</span>,<span class="title">UIGestureRecognizerDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        <span class="comment">// Do any additional setup after loading the view.</span></div><div class="line">        </div><div class="line">        <span class="keyword">let</span> target = interactivePopGestureRecognizer?.delegate</div><div class="line">        </div><div class="line">        <span class="comment">//创建全屏滑动手势，调用系统自带滑动手势的target的action方法</span></div><div class="line">        </div><div class="line">        <span class="keyword">let</span> pan = <span class="type">UIPanGestureRecognizer</span>(target: target, action: <span class="type">Selector</span>(<span class="string">"handleNavigationTransition:"</span>))</div><div class="line">        </div><div class="line">        <span class="comment">//设置手势的代理</span></div><div class="line">        pan.delegate = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//给导航控制器的View添加全屏滑动手势</span></div><div class="line">        view.addGestureRecognizer(pan)</div><div class="line">        </div><div class="line">        <span class="comment">//禁止使用系统自带的滑动手势</span></div><div class="line">        interactivePopGestureRecognizer?.isEnabled = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gestureRecognizer</span><span class="params">(<span class="number">_</span> gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">if</span> childViewControllers.<span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方法的原理其实很简单，其实就是自定义一个全屏滑动手势，并将滑动事件设置为系统滑动事件，然后禁用系统滑动手势即可。<code>handleNavigationTransition</code>就是系统滑动的方法，虽然系统并未提供接口，但是可以通过runtime找到这个方法，因此直接调用即可。</p><h4 id="整体滑动返回"><a href="#整体滑动返回" class="headerlink" title="整体滑动返回"></a>整体滑动返回</h4><p>虽然实现了全屏滑动返回，但是滑动时的切换依然是系统自带的动画，如果遇到前一个界面的NavigationBar为透明或前后两个Bar颜色不一样，这种渐变式的动画看起来就会不太友好，尤其当前后两个界面其中一个界面的NavigationBar为透明或隐藏时，其效果更是惨不忍睹。<br>整体滑动返回等于将两个NavigationBar独立开来，因此可以相对完美的解决导航栏滑动切换中的种种Bug。<br>实现这个效果有三种基本思路 </p><p>&gt;</p><ul><li>使用UINavigationController自带的setNavigationBarHidden: animated:方法来实现，每次push或pop时，在当前控制器的viewWillDisappear:中设置隐藏，在要跳转的控制器的viewWillAppear:中设置导航栏显示。  </li><li>在每次Push前对当前页面进行截图并保存到数组，Pop时取数组最后一个元素显示，滑动结束后调用系统Pop方法并删除最后一张截图。  </li><li>使用iOS 7之后开放的，UIViewControllerAnimatedTransitioning协议，来实现自定义导航栏转场动画及交互。</li></ul><p>三种方法中，方法一十分繁琐，且会有很多莫名其妙的BUG，直接pass。<br>在iOS的交互中，push一般通过按钮的点击事件或View的tap事件触发，而pop则可能通过事件触发，也可能通过右滑手势触发。因此，我们将这个我们要实现的动画效果分为交互效果和无交互效果两种。分别实现这两种效果，可以较为完美的解决Push和Pop的动画问题。  </p><h5 id="实现交互动画效果"><a href="#实现交互动画效果" class="headerlink" title="实现交互动画效果"></a>实现交互动画效果</h5><p>方法二</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="type">ScreenWidth</span> = <span class="type">UIScreen</span>.main.bounds.size.width</div><div class="line"><span class="keyword">let</span> <span class="type">ScreenHeight</span> = <span class="type">UIScreen</span>.main.bounds.size.height</div><div class="line"><span class="keyword">let</span> kDefaultAlpha : <span class="type">CGFloat</span> = <span class="number">0.6</span> <span class="comment">//默认的将要变透明的遮罩的初始透明度（全黑）</span></div><div class="line"><span class="keyword">let</span> kTargetTranslateScale : <span class="type">CGFloat</span> = <span class="number">0.75</span> <span class="comment">//当拖动的距离，占了屏幕的总宽度的3/4时，就让imageView完全显示，遮盖完全消失</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNavigationController</span>: <span class="title">UINavigationController</span>,<span class="title">UIGestureRecognizerDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> screenshotImageView : <span class="type">UIImageView</span>!</div><div class="line">    <span class="keyword">var</span> coverView : <span class="type">UIView</span>!</div><div class="line">    <span class="keyword">var</span> screenshotImgs : <span class="type">Array</span>&lt;<span class="type">UIImage</span>&gt;!</div><div class="line">    <span class="keyword">var</span> panGestureRec : <span class="type">UIScreenEdgePanGestureRecognizer</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        <span class="comment">//1、创建Pan手势识别器，并绑定监听方法</span></div><div class="line">        panGestureRec = <span class="type">UIScreenEdgePanGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(panGestureRecognizer(pan:)))</div><div class="line">        panGestureRec.edges = <span class="type">UIRectEdge</span>.<span class="keyword">left</span></div><div class="line">        <span class="comment">//为导航控制器的view添加Pan手势识别器</span></div><div class="line">        view.addGestureRecognizer(panGestureRec)</div><div class="line">        </div><div class="line">        <span class="comment">//2、创建截图的ImageView</span></div><div class="line">        screenshotImageView = <span class="type">UIImageView</span>()</div><div class="line">        <span class="comment">//app的frame是包括了状态栏高度的frame</span></div><div class="line">        screenshotImageView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">ScreenWidth</span>, height: <span class="type">ScreenHeight</span>)</div><div class="line">        </div><div class="line">        <span class="comment">//3、创建截图上面的黑色半透明遮罩</span></div><div class="line">        coverView = <span class="type">UIView</span>()</div><div class="line">        <span class="comment">//遮罩的frame就是截图的frame</span></div><div class="line">        coverView.frame = screenshotImageView.frame</div><div class="line">        <span class="comment">//遮罩为黑色</span></div><div class="line">        coverView.backgroundColor = <span class="type">UIColor</span>.black</div><div class="line">        </div><div class="line">        <span class="comment">//4、存放所有的截图数组初始化</span></div><div class="line">        screenshotImgs = []</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:响应手势的方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">panGestureRecognizer</span><span class="params">(pan : UIScreenEdgePanGestureRecognizer)</span></span> &#123;</div><div class="line">        <span class="comment">//如果当前显示的控制器已经是根控制器了，不做任何切换动画，直接返回</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.visibleViewController == <span class="keyword">self</span>.viewControllers[<span class="number">0</span>] &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//判断pan手势的各个阶段</span></div><div class="line">        <span class="keyword">switch</span> panGestureRec.state &#123;</div><div class="line">        <span class="keyword">case</span> .began:<span class="comment">//开始拖拽阶段</span></div><div class="line">            dragBegin()</div><div class="line">        <span class="keyword">case</span> .ended:<span class="comment">//结束拖拽阶段</span></div><div class="line">            dragEnd()</div><div class="line">        <span class="keyword">default</span>:<span class="comment">//正在拖拽阶段</span></div><div class="line">            dragging(pan: pan)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:开始拖拽，添加图片和遮罩</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragBegin</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//重点：每次开始pan手势时，都要添加截图imageView和遮罩cover到window中</span></div><div class="line">        view.window?.insertSubview(screenshotImageView, at: <span class="number">0</span>)</div><div class="line">        view.window?.insertSubview(coverView, aboveSubview: screenshotImageView)</div><div class="line">        </div><div class="line">        <span class="comment">//并且，让imageView显示截图数组中的最后（最新）一张截图</span></div><div class="line">        screenshotImageView.image = screenshotImgs.last</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:正在拖动，动画效果的精髓，进行位移和透明度的变化</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragging</span><span class="params">(pan : UIScreenEdgePanGestureRecognizer)</span></span> &#123;</div><div class="line">        <span class="comment">//得到手指拖动的位移</span></div><div class="line">        <span class="keyword">let</span> offsetX = pan.translation(<span class="keyword">in</span>: view).x</div><div class="line">        </div><div class="line">        <span class="comment">//让整个view都平移</span></div><div class="line">        <span class="comment">//挪动整个导航view</span></div><div class="line">        <span class="keyword">if</span> offsetX &gt; <span class="number">0</span> &#123;</div><div class="line">            view.transform = <span class="type">CGAffineTransform</span>(translationX: offsetX, y: <span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//计算目前手指拖动位移占屏幕总的宽高的比例，当这个比例达到3/4时，就让imageview完全显示，遮盖完全消失</span></div><div class="line">        <span class="keyword">let</span> currentTranslateScaleX = offsetX / <span class="keyword">self</span>.view.frame.width</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> offsetX &lt; <span class="type">ScreenWidth</span> &#123;</div><div class="line">            screenshotImageView.transform = <span class="type">CGAffineTransform</span>(translationX: (offsetX - <span class="type">ScreenWidth</span>) * <span class="number">0.6</span>, y: <span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 让遮盖透明度改变,直到减为0,让遮罩完全透明,默认的比例-(当前平衡比例/目标平衡比例)*默认的比例</span></div><div class="line">        <span class="keyword">let</span> alpha = kDefaultAlpha - (currentTranslateScaleX / kTargetTranslateScale) * kDefaultAlpha</div><div class="line">        </div><div class="line">        coverView.alpha = alpha</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:结束拖动，判断结束时拖动的距离做响应的处理，并将图片和遮罩从父控件上移除</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragEnd</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//取出挪动的距离</span></div><div class="line">        <span class="keyword">let</span> translateX = view.transform.tx</div><div class="line">        <span class="comment">//取出宽度</span></div><div class="line">        <span class="keyword">let</span> width = view.frame.size.width</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> translateX &lt;= <span class="number">40</span> &#123;<span class="comment">// 如果手指移动的距离还不到屏幕的一半,往左边挪 (弹回)</span></div><div class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, animations: &#123; </div><div class="line">                <span class="comment">//重要~~让被右移的view弹回归位,只要清空transform即可办到</span></div><div class="line">                <span class="keyword">self</span>.view.transform = <span class="type">CGAffineTransform</span>.identity</div><div class="line">                <span class="comment">//让imageview大小恢复默认的</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.transform = <span class="type">CGAffineTransform</span>(translationX: -<span class="type">ScreenWidth</span>, y: <span class="number">0</span>)</div><div class="line">                <span class="comment">//让遮盖的透明度恢复默认的alpha</span></div><div class="line">                <span class="keyword">self</span>.coverView.alpha = kDefaultAlpha</div><div class="line">            &#125;, completion: &#123; (finished) <span class="keyword">in</span></div><div class="line">                <span class="comment">//重要,动画完成之后,每次都要记得 移除两个view,下次开始拖动时,再添加进来</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.removeFromSuperview()</div><div class="line">                <span class="keyword">self</span>.coverView.removeFromSuperview()</div><div class="line">                </div><div class="line">            &#125;)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果手指移动的距离还超过了屏幕的一半,往右边挪</span></div><div class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, animations: &#123; </div><div class="line">                <span class="comment">// 让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform</span></div><div class="line">                <span class="keyword">self</span>.view.transform = <span class="type">CGAffineTransform</span>(translationX: width, y: <span class="number">0</span>)</div><div class="line">                <span class="comment">//让imageView位移还原</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.transform = <span class="type">CGAffineTransform</span>(translationX: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line">                <span class="comment">//让遮盖alpha变为0，变得完全透明</span></div><div class="line">                <span class="keyword">self</span>.coverView.alpha = <span class="number">0</span></div><div class="line">            &#125;, completion: &#123; (finished) <span class="keyword">in</span></div><div class="line">                <span class="comment">// 重要~~让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform,不然下次再次开始drag时会出问题,因为view的transform没有归零</span></div><div class="line">                <span class="keyword">self</span>.view.transform = <span class="type">CGAffineTransform</span>.identity</div><div class="line">                <span class="comment">// 移除两个view,下次开始拖动时,再加回来</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.removeFromSuperview()</div><div class="line">                <span class="keyword">self</span>.coverView.removeFromSuperview()</div><div class="line">                <span class="comment">// 执行正常的Pop操作:移除栈顶控制器,让真正的前一个控制器成为导航控制器的栈顶控制器</span></div><div class="line">                <span class="keyword">self</span>.popViewController(animated: <span class="literal">false</span>)</div><div class="line">            &#125;)</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:实现截图保存功能，并在push前截图</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">screenShot</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//将要被截图的view，即窗口的根控制器的view</span></div><div class="line">        <span class="keyword">let</span> beyondVC = <span class="keyword">self</span>.view.window?.rootViewController;</div><div class="line">        <span class="comment">//背景图片 总的大小</span></div><div class="line">        <span class="keyword">let</span> size = beyondVC?.view.frame.size</div><div class="line">        <span class="comment">//开启上下文，使用参数之后，截出来的是原图（YES  0.0 质量高）</span></div><div class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(size!, <span class="literal">true</span>, <span class="number">0.0</span>)</div><div class="line">        <span class="comment">//要裁剪的矩形范围</span></div><div class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">ScreenWidth</span>, height: <span class="type">ScreenHeight</span>)</div><div class="line">        <span class="comment">////注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代</span></div><div class="line">        beyondVC?.view.drawHierarchy(<span class="keyword">in</span>: rect, afterScreenUpdates: <span class="literal">false</span>)</div><div class="line">        <span class="comment">//从上下文中，取出UIImage</span></div><div class="line">        <span class="keyword">let</span> snapshot = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</div><div class="line">        <span class="comment">//添加截取好的图片到图片数组</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> _snapshot = snapshot &#123;</div><div class="line">            screenshotImgs.append(_snapshot)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//千万记得，结束上下文（移除栈顶的基于当前位图的图形上下文）</span></div><div class="line">        <span class="type">UIGraphicsEndImageContext</span>()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">pushViewController</span><span class="params">(<span class="number">_</span> viewController: UIViewController, animated: Bool)</span></span> &#123;</div><div class="line">        <span class="comment">//有在导航控制器里面有子控制器的时候才需要截图</span></div><div class="line">        <span class="keyword">if</span> viewControllers.<span class="built_in">count</span> &gt;= <span class="number">1</span> &#123;</div><div class="line">            <span class="comment">//调用自定义方法，使用上下文截图</span></div><div class="line">            screenShot()</div><div class="line">            viewController.navigationItem.leftBarButtonItems = <span class="type">UIBarButtonItem</span>.leftBarbuttonItem(<span class="keyword">self</span>, action: #selector(leftBarBtnClicked(btn:)), normalIcon: <span class="string">"back"</span>, hightlightIcon: <span class="string">"back"</span>)</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//截图完毕之后，才调用父类的push方法</span></div><div class="line">        <span class="keyword">super</span>.pushViewController(viewController, animated: <span class="literal">true</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//重写常用的Pop方法</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     由于可能调用的是导航栏的popViewController(animated: Bool) -&gt; UIViewController?方法、popToViewController(_ viewController: UIViewController, animated: Bool) -&gt; [UIViewController]?方法 或func popToRootViewController(animated: Bool) -&gt; [UIViewController]?来返回，这种情况下，删除的可能就不是一张截图，因此我们需要分别重写这些Pop方法，去确定我们要删除多少张图片</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">popViewController</span><span class="params">(animated: Bool)</span></span> -&gt; <span class="type">UIViewController</span>? &#123;</div><div class="line">        screenshotImgs.removeLast()</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.popViewController(animated: animated)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">popToViewController</span><span class="params">(<span class="number">_</span> viewController: UIViewController, animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]? &#123;</div><div class="line">        <span class="keyword">for</span>  vc <span class="keyword">in</span> viewControllers &#123;</div><div class="line">            <span class="keyword">if</span> viewController == vc &#123;</div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">            screenshotImgs.removeLast()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.popToViewController(viewController, animated: animated)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">popToRootViewController</span><span class="params">(animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]? &#123;</div><div class="line">        screenshotImgs.removeAll()</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.popToRootViewController(animated: animated)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:返回方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">leftBarBtnClicked</span><span class="params">(btn:UIButton)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.popViewController(animated: <span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实现非交互动画效果"><a href="#实现非交互动画效果" class="headerlink" title="实现非交互动画效果"></a>实现非交互动画效果</h4><p>实现原理  </p><blockquote><p>注：FromVC代表即将消失的视图控制器，ToVC表示将要展示的视图控制器</p></blockquote><p>要实现的效果：<br>Push的时候，FromVC往左移动，ToVC从屏幕右侧出现跟随FromVC左移直至FromVC消失，此时ToVC刚好完整显示在屏幕上。<br>Pop的时候，FromVC向右移动，ToVC从屏幕边缘出现跟随FromVC向右移动直至FromVC消失，此时ToVC刚好完整显示在屏幕上  </p><p>实现的时候，我们依然需要将Push和Pop分开讨论<br>先说Pop<br>1.和交互式动画一样，每次Push时对屏幕截屏并保存，Pop的再次截屏但不保存<br>2.把Pop时截取的图片作为FromVC展示，把Push到这个界面时截取的图片作为ToVC展示<br>3.并对两张图片做位移动画，动画结束后移除两张图片  </p><p>然后是Push<br>1.Push时先对当前屏幕截屏。<br>2.将截取的图片保存方便Pop回来时使用，并把这张图片作为这次Push的FromVC保存。<br>3.获取当前导航栏控制器对象，调整其Transform属性中的位移参数作为ToVC展示<br>4.对截图和导航栏做位移，动画结束后直接移除截屏图片  </p><blockquote><p><strong>为什么要对导航栏作位移？</strong></p><p>首先，在Push结束之前，我们是无法知道ToVC具体是什么样子，系统的截屏方法对于未加载出来的View是无能为力的，而UIView的 snapshotViewAfterScreenUpdates:方法又无法带着导航栏一起映射到一个新的View上，因此视觉效果很差。<br>正好在Pop的时候，为了达到想要的动画效果，用来展示的两张图片都需要放到导航栏的View上，因此在Push的时候我们就直接将导航栏的View做一个放射变换，当然，这也就意味着，当我们Push的时候，截屏就不能再放到导航栏上，而是应该放到它的“更上一层“ – UITabbarController的View上。</p></blockquote><p>话不多说，附上代码如下</p><h5 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h5><p>创建动画控制器。更准确的说，需要实现的细节都在UIViewControllerAnimatedTransitioning中</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationController</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> navigationOperation : <span class="type">UINavigationControllerOperation</span>!</div><div class="line">    <span class="keyword">var</span> navigationController : <span class="type">UINavigationController</span>?&#123;</div><div class="line">        <span class="keyword">didSet</span>&#123;</div><div class="line">           <span class="keyword">let</span> beyondVC = navigationController!.view.window?.rootViewController</div><div class="line">            <span class="comment">//判断该导航栏是否有TabBarController</span></div><div class="line">            <span class="keyword">if</span> navigationController!.tabBarController == beyondVC &#123;</div><div class="line">                isTabbarExist = <span class="literal">true</span></div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                isTabbarExist = <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//导航栏Pop时删除了多少张截图（调用PopToViewController时，计算要删除的截图的数量）</span></div><div class="line">    <span class="keyword">var</span> removeCount : <span class="type">NSInteger</span> = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> screenShotArray : <span class="type">Array</span>&lt;<span class="type">UIImage</span>&gt; = []</div><div class="line">    <span class="comment">//所属的导航栏有没有TabBarController</span></div><div class="line">    <span class="keyword">var</span> isTabbarExist = <span class="literal">false</span></div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animationController</span>(<span class="title">operation</span> : <span class="title">UINavigationControllerOperation</span>) -&gt; <span class="title">AnimationController</span></span>&#123;</div><div class="line">        <span class="keyword">let</span> ac = <span class="type">AnimationController</span>()</div><div class="line">        ac.navigationOperation = operation;</div><div class="line">        <span class="keyword">return</span> ac</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animationController</span>(<span class="title">operation</span> : <span class="title">UINavigationControllerOperation</span>, <span class="title">navigationController</span> : <span class="title">UINavigationController</span>) -&gt; <span class="title">AnimationController</span> </span>&#123;</div><div class="line">        <span class="keyword">let</span> ac = <span class="type">AnimationController</span>()</div><div class="line">        ac.navigationController = navigationController</div><div class="line">        ac.navigationOperation = operation</div><div class="line">        <span class="keyword">return</span> ac</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:UIViewControllerAnimatedTransitioning</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0.4</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> screenImgView = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">ScreenWidth</span>, height: <span class="type">ScreenHeight</span>))</div><div class="line">        <span class="keyword">let</span> screenImg = <span class="keyword">self</span>.screenShot()</div><div class="line">        screenImgView.image = screenImg</div><div class="line">        </div><div class="line">        <span class="comment">//取出fromViewController,fromView和toViewController，toView</span></div><div class="line">        <span class="keyword">let</span> fromVC = transitionContext.viewController(forKey: .from)</div><div class="line">        <span class="keyword">let</span> toVC = transitionContext.viewController(forKey: .to)</div><div class="line">        <span class="keyword">let</span> toView = transitionContext.view(forKey: .to)</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> fromViewEndFrame = transitionContext.finalFrame(<span class="keyword">for</span>: fromVC!)</div><div class="line">        fromViewEndFrame.origin.x = <span class="type">ScreenWidth</span></div><div class="line">        <span class="keyword">var</span> fromViewStartFrame = fromViewEndFrame</div><div class="line">        <span class="keyword">let</span> toViewEndFrame = transitionContext.finalFrame(<span class="keyword">for</span>: toVC!)</div><div class="line">        <span class="keyword">let</span> toViewStartFrame = toViewEndFrame</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> containerView = transitionContext.containerView</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> navigationOperation == <span class="type">UINavigationControllerOperation</span>.push &#123;</div><div class="line">            screenShotArray.append(screenImg!)</div><div class="line">            </div><div class="line">            <span class="comment">//这句非常重要，没有这句，就无法正常push和Pop出对应的界面</span></div><div class="line">            containerView.addSubview(toView!)</div><div class="line">            </div><div class="line">            toView?.frame = toViewStartFrame</div><div class="line">            </div><div class="line">            <span class="comment">//将截图添加到导航栏的view所属的window上</span></div><div class="line">            navigationController?.view.window?.insertSubview(screenImgView, at: <span class="number">0</span>)</div><div class="line">            </div><div class="line">            navigationController?.view.transform = <span class="type">CGAffineTransform</span>(translationX: <span class="type">ScreenWidth</span>, y: <span class="number">0</span>)</div><div class="line">            </div><div class="line">            <span class="type">UIView</span>.animate(withDuration: transitionDuration(using: transitionContext), animations: &#123; </div><div class="line">                <span class="keyword">self</span>.navigationController?.view.transform = <span class="type">CGAffineTransform</span>(translationX: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line">                screenImgView.center = <span class="type">CGPoint</span>(x: -<span class="type">ScreenWidth</span> / <span class="number">2.0</span>, y: <span class="type">ScreenHeight</span> / <span class="number">2.0</span>)</div><div class="line">            &#125;, completion: &#123; (finished) <span class="keyword">in</span></div><div class="line">                screenImgView.removeFromSuperview()</div><div class="line">                transitionContext.completeTransition(<span class="literal">true</span>)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> navigationOperation == <span class="type">UINavigationControllerOperation</span>.pop &#123;</div><div class="line">            fromViewStartFrame.origin.x = <span class="number">0</span></div><div class="line">            containerView.addSubview(toView!)</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> lastVCImgView = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: -<span class="type">ScreenWidth</span>, y: <span class="number">0</span>, width: <span class="type">ScreenWidth</span>, height: <span class="type">ScreenHeight</span>))</div><div class="line">            <span class="comment">//若removeCount大于0，则说明pop了不止一个控制器</span></div><div class="line">            <span class="keyword">if</span> removeCount &gt; <span class="number">0</span> &#123;</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; removeCount &#123;</div><div class="line">                    <span class="keyword">if</span> i == removeCount - <span class="number">1</span> &#123;</div><div class="line">                        <span class="comment">//当删除到要跳转页面的截图时，不要删除，并将该截图作为ToVC的截图显示</span></div><div class="line">                        lastVCImgView.image = screenShotArray.last</div><div class="line">                        removeCount = <span class="number">0</span></div><div class="line">                        <span class="keyword">break</span></div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        screenShotArray.removeLast()</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                lastVCImgView.image = screenShotArray.last</div><div class="line">            &#125;</div><div class="line">            screenImgView.layer.shadowColor = <span class="type">UIColor</span>.black.cgColor</div><div class="line">            screenImgView.layer.shadowOffset = <span class="type">CGSize</span>(width: -<span class="number">0.8</span>, height: <span class="number">0</span>)</div><div class="line">            screenImgView.layer.shadowOpacity = <span class="number">0.6</span></div><div class="line">            navigationController?.view.window?.addSubview(lastVCImgView)</div><div class="line">            navigationController?.view.addSubview(screenImgView)</div><div class="line">            </div><div class="line">            <span class="type">UIView</span>.animate(withDuration: transitionDuration(using: transitionContext), animations: &#123; </div><div class="line">                screenImgView.center = <span class="type">CGPoint</span>(x: <span class="type">ScreenWidth</span> * <span class="number">3</span> / <span class="number">2.0</span>, y: <span class="type">ScreenHeight</span> / <span class="number">2.0</span>)</div><div class="line">                lastVCImgView.center = <span class="type">CGPoint</span>(x: <span class="type">ScreenWidth</span> / <span class="number">2.0</span>, y: <span class="type">ScreenHeight</span> / <span class="number">2.0</span>)</div><div class="line">            &#125;, completion: &#123; (finished) <span class="keyword">in</span></div><div class="line">                lastVCImgView.removeFromSuperview()</div><div class="line">                screenImgView.removeFromSuperview()</div><div class="line">                <span class="keyword">self</span>.screenShotArray.removeLast()</div><div class="line">                transitionContext.completeTransition(<span class="literal">true</span>)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeLastScreenShot</span><span class="params">()</span></span> &#123;<span class="comment">//调用此方法删除数组最后一张截图 (调用pop手势或一次pop多个控制器时使用)</span></div><div class="line">        screenShotArray.removeLast()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeAllScreenShot</span><span class="params">()</span></span> &#123;<span class="comment">// 移除全部屏幕截图</span></div><div class="line">        screenShotArray.removeAll()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeLastScreenShot</span><span class="params">(withNumber number : NSInteger)</span></span> &#123;<span class="comment">//从截屏数组尾部移除指定数量的截图</span></div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; number &#123;</div><div class="line">            screenShotArray.removeLast()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">screenShot</span><span class="params">()</span></span> -&gt; <span class="type">UIImage</span>? &#123;</div><div class="line">        <span class="comment">//将要被截图的view，即窗口的根控制器的view</span></div><div class="line">        <span class="keyword">let</span> beyondVC = <span class="keyword">self</span>.navigationController?.view.window?.rootViewController;</div><div class="line">        <span class="comment">//背景图片 总的大小</span></div><div class="line">        <span class="keyword">let</span> size = beyondVC?.view.frame.size</div><div class="line">        <span class="comment">//开启上下文，使用参数之后，截出来的是原图（YES  0.0 质量高）</span></div><div class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(size!, <span class="literal">true</span>, <span class="number">0.0</span>)</div><div class="line">        <span class="comment">//要裁剪的矩形范围</span></div><div class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">ScreenWidth</span>, height: <span class="type">ScreenHeight</span>)</div><div class="line">        <span class="comment">////注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代</span></div><div class="line">        <span class="keyword">if</span> isTabbarExist &#123;</div><div class="line">            beyondVC?.view.drawHierarchy(<span class="keyword">in</span>: rect, afterScreenUpdates: <span class="literal">false</span>)</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            navigationController?.view.drawHierarchy(<span class="keyword">in</span>: rect, afterScreenUpdates: <span class="literal">false</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从上下文中，取出UIImage</span></div><div class="line">        <span class="keyword">let</span> snapshot = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</div><div class="line">        <span class="comment">//千万记得，结束上下文（移除栈顶的基于当前位图的图形上下文）</span></div><div class="line">        <span class="type">UIGraphicsEndImageContext</span>()</div><div class="line"></div><div class="line">        <span class="keyword">return</span> snapshot;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">``` </div><div class="line">##### <span class="type">CustomNavigationController</span> </div><div class="line">在<span class="type">CustomNavigationController</span>中添加`<span class="type">UINavigationControllerDelegate</span>`协议，实现其代理方法，对push以及pop 和手势滑动事件进行修改</div><div class="line"></div><div class="line">```swift</div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="type">ScreenWidth</span> = <span class="type">UIScreen</span>.main.bounds.size.width</div><div class="line"><span class="keyword">let</span> <span class="type">ScreenHeight</span> = <span class="type">UIScreen</span>.main.bounds.size.height</div><div class="line"><span class="keyword">let</span> kDefaultAlpha : <span class="type">CGFloat</span> = <span class="number">0.6</span> <span class="comment">//默认的将要变透明的遮罩的初始透明度（全黑）</span></div><div class="line"><span class="keyword">let</span> kTargetTranslateScale : <span class="type">CGFloat</span> = <span class="number">0.75</span> <span class="comment">//当拖动的距离，占了屏幕的总宽度的3/4时，就让imageView完全显示，遮盖完全消失</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">colorFromRGB</span><span class="params">(rgbValue : Int)</span></span> -&gt; <span class="type">UIColor</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">UIColor</span>(red: <span class="type">CGFloat</span>(((rgbValue &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span>, green: <span class="type">CGFloat</span>(((rgbValue &amp; <span class="number">0x0FF00</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span>, blue: <span class="type">CGFloat</span>(((rgbValue &amp; <span class="number">0x0000FF</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNavigationController</span>: <span class="title">UINavigationController</span>,<span class="title">UIGestureRecognizerDelegate</span>,<span class="title">UINavigationControllerDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> screenshotImageView : <span class="type">UIImageView</span>!</div><div class="line">    <span class="keyword">var</span> coverView : <span class="type">UIView</span>!</div><div class="line">    <span class="keyword">var</span> screenshotImgs : <span class="type">Array</span>&lt;<span class="type">UIImage</span>&gt;!</div><div class="line">    <span class="keyword">var</span> panGestureRec : <span class="type">UIScreenEdgePanGestureRecognizer</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> nextVCScreenShotImg : <span class="type">UIImage</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> animationController : <span class="type">AnimationController</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        delegate = <span class="keyword">self</span></div><div class="line">        </div><div class="line">        navigationBar.tintColor = colorFromRGB(rgbValue: <span class="number">0x6F7179</span>)</div><div class="line">        </div><div class="line">        view.layer.shadowColor = <span class="type">UIColor</span>.black.cgColor</div><div class="line">        view.layer.shadowOffset = <span class="type">CGSize</span>(width: -<span class="number">0.8</span>, height: <span class="number">0</span>)</div><div class="line">        view.layer.shadowOpacity = <span class="number">0.6</span></div><div class="line">        </div><div class="line">        animationController = <span class="type">AnimationController</span>()</div><div class="line">        </div><div class="line">        <span class="comment">//1、创建Pan手势识别器，并绑定监听方法</span></div><div class="line">        panGestureRec = <span class="type">UIScreenEdgePanGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(panGestureRecognizer(pan:)))</div><div class="line">        panGestureRec.edges = <span class="type">UIRectEdge</span>.<span class="keyword">left</span></div><div class="line">        <span class="comment">//为导航控制器的view添加Pan手势识别器</span></div><div class="line">        view.addGestureRecognizer(panGestureRec)</div><div class="line">        </div><div class="line">        <span class="comment">//2、创建截图的ImageView</span></div><div class="line">        screenshotImageView = <span class="type">UIImageView</span>()</div><div class="line">        <span class="comment">//app的frame是包括了状态栏高度的frame</span></div><div class="line">        screenshotImageView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">ScreenWidth</span>, height: <span class="type">ScreenHeight</span>)</div><div class="line">        </div><div class="line">        <span class="comment">//3、创建截图上面的黑色半透明遮罩</span></div><div class="line">        coverView = <span class="type">UIView</span>()</div><div class="line">        <span class="comment">//遮罩的frame就是截图的frame</span></div><div class="line">        coverView.frame = screenshotImageView.frame</div><div class="line">        <span class="comment">//遮罩为黑色</span></div><div class="line">        coverView.backgroundColor = <span class="type">UIColor</span>.black</div><div class="line">        </div><div class="line">        <span class="comment">//4、存放所有的截图数组初始化</span></div><div class="line">        screenshotImgs = []</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//MARK:实现`UINavigationControllerDelegate`的代理方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController, animationControllerFor operation: UINavigationControllerOperation, from fromVC: UIViewController, to toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">        animationController.navigationOperation = operation</div><div class="line">        animationController.navigationController = <span class="keyword">self</span></div><div class="line">        <span class="keyword">return</span> animationController</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">pushViewController</span><span class="params">(<span class="number">_</span> viewController: UIViewController, animated: Bool)</span></span> &#123;</div><div class="line">        <span class="comment">//只有在导航控制器里面有子控制器的时候才需要截图</span></div><div class="line">        <span class="keyword">if</span> viewControllers.<span class="built_in">count</span> &gt;= <span class="number">1</span> &#123;</div><div class="line">            <span class="comment">//调用自定义方法，使用上下文截图</span></div><div class="line">            screenShot()</div><div class="line">            viewController.navigationItem.leftBarButtonItems = <span class="type">UIBarButtonItem</span>.leftBarbuttonItem(<span class="keyword">self</span>, action: #selector(leftBarBtnClicked(btn:)), normalIcon: <span class="string">"back"</span>, hightlightIcon: <span class="string">"back"</span>)</div><div class="line">            viewController.hidesBottomBarWhenPushed = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">         <span class="comment">//截图完毕之后，才调用父类的push方法</span></div><div class="line">        <span class="keyword">super</span>.pushViewController(viewController, animated: <span class="literal">true</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//重写常用的Pop方法</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     由于可能调用的是导航栏的popViewController(animated: Bool) -&gt; UIViewController?方法、popToViewController(_ viewController: UIViewController, animated: Bool) -&gt; [UIViewController]?方法 或func popToRootViewController(animated: Bool) -&gt; [UIViewController]?来返回，这种情况下，删除的可能就不是一张截图，因此我们需要分别重写这些Pop方法，去确定我们要删除多少张图片</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">popViewController</span><span class="params">(animated: Bool)</span></span> -&gt; <span class="type">UIViewController</span>? &#123;</div><div class="line">        <span class="keyword">let</span> index = viewControllers.<span class="built_in">count</span></div><div class="line">        <span class="keyword">if</span> screenshotImgs.<span class="built_in">count</span> &gt;= index - <span class="number">1</span> &#123;</div><div class="line">            screenshotImgs.removeLast()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.popViewController(animated: animated)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">popToViewController</span><span class="params">(<span class="number">_</span> viewController: UIViewController, animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]? &#123;</div><div class="line">        <span class="keyword">var</span> removeCount = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span>  vc <span class="keyword">in</span> viewControllers &#123;</div><div class="line">            <span class="keyword">if</span> viewController == vc &#123;</div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">            screenshotImgs.removeLast()</div><div class="line">            removeCount += <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        animationController.removeCount = removeCount</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.popToViewController(viewController, animated: animated)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">popToRootViewController</span><span class="params">(animated: Bool)</span></span> -&gt; [<span class="type">UIViewController</span>]? &#123;</div><div class="line">        animationController.removeCount = screenshotImgs.<span class="built_in">count</span></div><div class="line">        screenshotImgs.removeAll()</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.popToRootViewController(animated: animated)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:实现截图保存功能，并在push前截图</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">screenShot</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//将要被截图的view，即窗口的根控制器的view</span></div><div class="line">        <span class="keyword">let</span> beyondVC = <span class="keyword">self</span>.view.window?.rootViewController;</div><div class="line">        <span class="comment">//背景图片 总的大小</span></div><div class="line">        <span class="keyword">let</span> size = beyondVC?.view.frame.size</div><div class="line">        <span class="comment">//开启上下文，使用参数之后，截出来的是原图（YES  0.0 质量高）</span></div><div class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(size!, <span class="literal">true</span>, <span class="number">0.0</span>)</div><div class="line">        <span class="comment">//要裁剪的矩形范围</span></div><div class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">ScreenWidth</span>, height: <span class="type">ScreenHeight</span>)</div><div class="line">        <span class="comment">////注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代</span></div><div class="line">        <span class="keyword">if</span> tabBarController == beyondVC &#123;</div><div class="line">            beyondVC?.view.drawHierarchy(<span class="keyword">in</span>: rect, afterScreenUpdates: <span class="literal">false</span>)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            view.drawHierarchy(<span class="keyword">in</span>: rect, afterScreenUpdates: <span class="literal">false</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//从上下文中，取出UIImage</span></div><div class="line">        <span class="keyword">let</span> snapshot = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</div><div class="line">        <span class="comment">//添加截取好的图片到图片数组</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> _snapshot = snapshot &#123;</div><div class="line">            screenshotImgs.append(_snapshot)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//千万记得，结束上下文（移除栈顶的基于当前位图的图形上下文）</span></div><div class="line">        <span class="type">UIGraphicsEndImageContext</span>()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//MARK:响应手势的方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">panGestureRecognizer</span><span class="params">(pan : UIScreenEdgePanGestureRecognizer)</span></span> &#123;</div><div class="line">        <span class="comment">//如果当前显示的控制器已经是根控制器了，不做任何切换动画，直接返回</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.visibleViewController == <span class="keyword">self</span>.viewControllers[<span class="number">0</span>] &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//判断pan手势的各个阶段</span></div><div class="line">        <span class="keyword">switch</span> panGestureRec.state &#123;</div><div class="line">        <span class="keyword">case</span> .began:<span class="comment">//开始拖拽阶段</span></div><div class="line">            dragBegin()</div><div class="line">        <span class="keyword">case</span> .ended,.cancelled,.failed:<span class="comment">//结束拖拽阶段</span></div><div class="line">            dragEnd()</div><div class="line">        <span class="keyword">default</span>:<span class="comment">//正在拖拽阶段</span></div><div class="line">            dragging(pan: pan)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:开始拖拽，添加图片和遮罩</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragBegin</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//重点：每次开始pan手势时，都要添加截图imageView和遮罩cover到window中</span></div><div class="line">        view.window?.insertSubview(screenshotImageView, at: <span class="number">0</span>)</div><div class="line">        view.window?.insertSubview(coverView, aboveSubview: screenshotImageView)</div><div class="line">        </div><div class="line">        <span class="comment">//并且，让imageView显示截图数组中的最后（最新）一张截图</span></div><div class="line">        screenshotImageView.image = screenshotImgs.last</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:正在拖动，动画效果的精髓，进行位移和透明度的变化</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragging</span><span class="params">(pan : UIScreenEdgePanGestureRecognizer)</span></span> &#123;</div><div class="line">        <span class="comment">//得到手指拖动的位移</span></div><div class="line">        <span class="keyword">let</span> offsetX = pan.translation(<span class="keyword">in</span>: view).x</div><div class="line">        </div><div class="line">        <span class="comment">//让整个view都平移</span></div><div class="line">        <span class="comment">//挪动整个导航view</span></div><div class="line">        <span class="keyword">if</span> offsetX &gt; <span class="number">0</span> &#123;</div><div class="line">            view.transform = <span class="type">CGAffineTransform</span>(translationX: offsetX, y: <span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//计算目前手指拖动位移占屏幕总的宽高的比例，当这个比例达到3/4时，就让imageview完全显示，遮盖完全消失</span></div><div class="line">        <span class="keyword">let</span> currentTranslateScaleX = offsetX / <span class="keyword">self</span>.view.frame.width</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> offsetX &lt; <span class="type">ScreenWidth</span> &#123;</div><div class="line">            screenshotImageView.transform = <span class="type">CGAffineTransform</span>(translationX: (offsetX - <span class="type">ScreenWidth</span>) * <span class="number">0.6</span>, y: <span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 让遮盖透明度改变,直到减为0,让遮罩完全透明,默认的比例-(当前平衡比例/目标平衡比例)*默认的比例</span></div><div class="line">        <span class="keyword">let</span> alpha = kDefaultAlpha - (currentTranslateScaleX / kTargetTranslateScale) * kDefaultAlpha</div><div class="line">        </div><div class="line">        coverView.alpha = alpha</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:结束拖动，判断结束时拖动的距离做响应的处理，并将图片和遮罩从父控件上移除</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dragEnd</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//取出挪动的距离</span></div><div class="line">        <span class="keyword">let</span> translateX = view.transform.tx</div><div class="line">        <span class="comment">//取出宽度</span></div><div class="line">        <span class="keyword">let</span> width = view.frame.size.width</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> translateX &lt;= <span class="number">40</span> &#123;<span class="comment">// 如果手指移动的距离还不到屏幕的一半,往左边挪 (弹回)</span></div><div class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, animations: &#123;</div><div class="line">                <span class="comment">//重要~~让被右移的view弹回归位,只要清空transform即可办到</span></div><div class="line">                <span class="keyword">self</span>.view.transform = <span class="type">CGAffineTransform</span>.identity</div><div class="line">                <span class="comment">//让imageview大小恢复默认的</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.transform = <span class="type">CGAffineTransform</span>(translationX: -<span class="type">ScreenWidth</span>, y: <span class="number">0</span>)</div><div class="line">                <span class="comment">//让遮盖的透明度恢复默认的alpha</span></div><div class="line">                <span class="keyword">self</span>.coverView.alpha = kDefaultAlpha</div><div class="line">            &#125;, completion: &#123; (finished) <span class="keyword">in</span></div><div class="line">                <span class="comment">//重要,动画完成之后,每次都要记得 移除两个view,下次开始拖动时,再添加进来</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.removeFromSuperview()</div><div class="line">                <span class="keyword">self</span>.coverView.removeFromSuperview()</div><div class="line">                </div><div class="line">            &#125;)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果手指移动的距离还超过了屏幕的一半,往右边挪</span></div><div class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>, animations: &#123;</div><div class="line">                <span class="comment">// 让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform</span></div><div class="line">                <span class="keyword">self</span>.view.transform = <span class="type">CGAffineTransform</span>(translationX: width, y: <span class="number">0</span>)</div><div class="line">                <span class="comment">//让imageView位移还原</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.transform = <span class="type">CGAffineTransform</span>(translationX: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line">                <span class="comment">//让遮盖alpha变为0，变得完全透明</span></div><div class="line">                <span class="keyword">self</span>.coverView.alpha = <span class="number">0</span></div><div class="line">            &#125;, completion: &#123; (finished) <span class="keyword">in</span></div><div class="line">                <span class="comment">// 重要~~让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform,不然下次再次开始drag时会出问题,因为view的transform没有归零</span></div><div class="line">                <span class="keyword">self</span>.view.transform = <span class="type">CGAffineTransform</span>.identity</div><div class="line">                <span class="comment">// 移除两个view,下次开始拖动时,再加回来</span></div><div class="line">                <span class="keyword">self</span>.screenshotImageView.removeFromSuperview()</div><div class="line">                <span class="keyword">self</span>.coverView.removeFromSuperview()</div><div class="line">                <span class="comment">// 执行正常的Pop操作:移除栈顶控制器,让真正的前一个控制器成为导航控制器的栈顶控制器</span></div><div class="line">                <span class="keyword">self</span>.popViewController(animated: <span class="literal">false</span>)</div><div class="line">                <span class="keyword">self</span>.animationController.removeLastScreenShot()</div><div class="line">            &#125;)</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//MARK:返回方法</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">leftBarBtnClicked</span><span class="params">(btn:UIButton)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.popViewController(animated: <span class="literal">true</span>)</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考博客<br><a href="http://www.jianshu.com/p/31f177158c9e" target="_blank" rel="external">【iOS】让我们一次性解决导航栏的所有问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;调整导航条的按钮的位置&quot;&gt;&lt;a href=&quot;#调整导航条的按钮的位置&quot; class=&quot;headerlink&quot; title=&quot;调整导航条的按钮的位置&quot;&gt;&lt;/a&gt;调整导航条的按钮的位置&lt;/h4&gt;&lt;p&gt;在自定义导航条左侧返回按钮，返回按钮明显会有点偏右，应该如何调整的，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CoreText实现图文混排以及点击事件</title>
    <link href="http://yoursite.com/2017/08/05/CoreText%E5%AE%9E%E7%8E%B0%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E4%BB%A5%E5%8F%8A%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/08/05/CoreText实现图文混排以及点击事件/</id>
    <published>2017-08-05T11:14:18.000Z</published>
    <updated>2017-08-12T10:07:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CoreText简介"><a href="#CoreText简介" class="headerlink" title="CoreText简介"></a>CoreText简介</h3><p>Core Text 是基于 iOS 3.2+ 和 OSX 10.5+ 的一种能够对文本格式和文本布局进行精细控制的文本引擎。<br>它良好的结合了 UIKit 和 Core Graphics/Quartz：<br>&gt;</p><font color="#ff0000">UIKit</font>的<font color="#ff0000">UILabel</font>允许你通过在<font color="#ff0000">IB</font>中简单的拖曳添加文本，但你不能改变文本的颜色和其中的单词。<br><font color="#ff0000">Core Graphics/Quartz</font>几乎允许你做任何系统允许的事情，但你需要为每个字形计算位置，并画在屏幕上。<br><font color="#ff0000">Core Text</font>正结合了这两者！你可以完全控制位置、布局、类似文本大小和颜色这样的属性，而<font color="#ff0000">Core Text</font>将帮你完善其它的东西——类似文本换行、字体呈现等等。<br><font color="#ff0000">iOS7</font>新推出的类库<font color="#ff0000">Textkit</font>，其实是在之前推出的CoreText上的封装<br><font color="#ff0000">CoreText</font>的主要作用也是用于文字的排版和渲染，但它是一种先进而又处于<font color="#0000ff">底层技术</font>，如果我们需要将文本内容直接渲染到图形上下文<font color="#ff0000">(Graphics context)</font>时，<font color="#0000ff">从性能和易用性来考虑，最佳方案就是使用CoreText</font>。<br><br>### 富文本<br>&gt;<br><font color="#ff0000">富文本格式(RTF)</font>规范是为了便于在应用程序之间轻松转储格式化<strong><em>文本</em></strong>和<strong><em>图形</em></strong>的一种<font color="#0000ff">编码方法</font>。<br>现在，用户可以利用特定转换软件，在不同系统如<font color="#0000ff">MS-DOS</font>、<font color="#0000ff">Windows</font>、<font color="#0000ff">OS/2</font>、<font color="#0000ff">Macintosh</font>和<font color="#0000ff">Power Macintosh</font>的应用程序之间转移字处理文档。<br><font color="#ff0000">RTF</font>规范提供一种在不同的输出设备、操作环境和操作系统之间交换文本和图形的一种格式。<br><font color="#ff0000">RTF</font>使用<font color="#0000ff">ANSI</font>,<font color="#0000ff">PC-8</font>, <font color="#0000ff">Macintosh</font>, 或<font color="#0000ff">IBM PC</font>字符集控制文档的表示法和格式化，包括屏幕显示和打印。<br>凭借<font color="#ff0000">RTF</font>规范，不同的操作系统和不同的软件程序创建的文档能够在这些操作系统和应用程序之间传递。<br>将一个格式化的文件转换为<font color="#ff0000">RTF</font>文件的软件称为<font color="#0000ff">RTF书写器</font>。<br><font color="#0000ff">RTF书写器</font>用于分离现有文本中的程序控制信息，并且生成一个包含文本和与之相关的<font color="#ff0000">RTF</font>组的新文件。<br>将<font color="#ff0000">RTF</font>文件转换成格式化文件的软件则称为<font color="#0000ff">RTF阅读器</font>。<br><br>简单来说附带有每一个文字属性的字符串，就是富文本。在iOS中，<code>AttributeString</code>专门用来处理富文本。<code>AttributedString</code>也分为<code>NSAttributedString</code>和<code>NSMutableAttributedString</code>两个类。<br>常用的一些方法<br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-initWithString: <span class="comment">//以NSString初始化一个富文本对象</span></div><div class="line">-setAttributes:range: <span class="comment">//为富文本中的一段范围添加一些属性，第一个参数是个NSDictionary字典，第二个参数是NSRange。</span></div><div class="line">-addAttribute:value:range: <span class="comment">//添加一个属性</span></div><div class="line">-addAttributes:range: <span class="comment">//添加多个属性</span></div><div class="line">-removeAttribute:range: <span class="comment">//移除属性</span></div></pre></td></tr></table></figure><br><br>代码示例<br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> * dic = @&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> fontWithName:<span class="string">@"Zapfino"</span> size:<span class="number">20</span>],<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> redColor],<span class="built_in">NSUnderlineStyleAttributeName</span>:@(<span class="built_in">NSUnderlineStyleSingle</span>)&#125;;</div><div class="line">    <span class="built_in">NSMutableAttributedString</span> * attributeStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@"0我是一个富文本，9听说我有很多属性，19I will try。32这里清除属性."</span>];</div><div class="line"><span class="comment">//    设置属性</span></div><div class="line">    [attributeStr setAttributes:dic range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, attributeStr.length)];</div><div class="line"><span class="comment">//    添加属性</span></div><div class="line">    [attributeStr addAttribute:<span class="built_in">NSFontAttributeName</span> value:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">30</span>] range:<span class="built_in">NSMakeRange</span>(<span class="number">9</span>, <span class="number">10</span>)];</div><div class="line">    [attributeStr addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:[<span class="built_in">UIColor</span> cyanColor] range:<span class="built_in">NSMakeRange</span>(<span class="number">13</span>, <span class="number">13</span>)];</div><div class="line"><span class="comment">//    添加多个属性</span></div><div class="line">    <span class="built_in">NSDictionary</span> * dicAdd = @&#123;<span class="built_in">NSBackgroundColorAttributeName</span>:[<span class="built_in">UIColor</span> yellowColor],<span class="built_in">NSLigatureAttributeName</span>:@<span class="number">1</span>&#125;;</div><div class="line">    [attributeStr addAttributes:dicAdd range:<span class="built_in">NSMakeRange</span>(<span class="number">19</span>, <span class="number">13</span>)];</div><div class="line"><span class="comment">//    移除属性</span></div><div class="line">    [attributeStr removeAttribute:<span class="built_in">NSFontAttributeName</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">32</span>, <span class="number">9</span>)];</div><div class="line">    <span class="built_in">UILabel</span> * label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">400</span>)];</div><div class="line">    label.numberOfLines = <span class="number">0</span>;</div><div class="line">    label.attributedText = attributeStr;</div></pre></td></tr></table></figure><br><br>### CoreText坐标系与UIKit坐标系<br><img src="http://oui2ar2u7.bkt.clouddn.com/96ed8957aedfb08d.jpg" alt=""><br>从图中可看出<font color="#ff0000">CoreText坐标系是以左下角为坐标原点</font>，而我们常用的<font color="#0000ff">UIKit是以左上角为坐标原点</font>。因此在CoreText中的布局完成后需要对其坐标系进行转换，否则直接绘制出现位置反转的镜像情况。<br>&gt;<br>在iOS的不同framework中使用着不同的坐标系：<br><font color="#ff0000">UIKit</font> － y轴向下<br><font color="#ff0000">Core Graphics(Quartz)</font> － y轴向上<br><font color="#ff0000">OpenGL ES</font>－ y轴向上<br><font color="#ff0000">UIKit</font>是iPhone SDK的Cocoa Touch层的核心framework，是iPhone应用程序图形界面和事件驱动的基础，它和传统的windows桌面一样，坐标系是y轴向下的;<font color="#ff0000">Core Graphics(Quartz)</font>一个基于<em>2D</em>的图形绘制引擎，它的坐标系则是y轴向上的；而<font color="#ff0000">OpenGL ES</font>是iPhone SDK的<em>2D</em>和<em>3D</em>绘制引擎，它使用左手坐标系，它的坐标系也是y轴向上的，如果不考虑z轴，在二维下它的坐标系和Quartz是一样的。<br><br>### CoreText绘制富文本<br>CoreText实现图文混排其实就是在富文本中插入一个空白的图片占位符的富文本字符串，通过代理设置相关的图片尺寸信息，根据从富文本得到的frame计算图片绘制的frame再绘制图片这么一个过程。<br>#### 整体代码<br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">    <span class="comment">//获取当前绘制上下文</span></div><div class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);<span class="comment">//设置当前文本矩阵为不做图形变换</span></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.height);<span class="comment">//平移方法，将context向上平移一个屏幕高</span></div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, <span class="number">-1.0</span>);<span class="comment">//缩放方法，x轴缩放系数为1，则不变，y轴缩放系数为-1，则相当于以x轴为轴旋转180度</span></div><div class="line">    <span class="built_in">NSMutableAttributedString</span> * attributeStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@"\n这里在测试图文混排，\n我是一个富文本"</span>];</div><div class="line">    <span class="built_in">CTRunDelegateCallbacks</span> callBacks;</div><div class="line">    memset(&amp;callBacks,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">CTRunDelegateCallbacks</span>));</div><div class="line">    callBacks.version = kCTRunDelegateVersion1;</div><div class="line">    callBacks.getAscent = ascentCallBacks;</div><div class="line">    callBacks.getDescent = descentCallBacks;</div><div class="line">    callBacks.getWidth = widthCallBacks;</div><div class="line">    <span class="built_in">NSDictionary</span> * dicPic = @&#123;<span class="string">@"height"</span>:@<span class="number">129</span>,<span class="string">@"width"</span>:@<span class="number">129</span>&#125;;</div><div class="line">    <span class="built_in">CTRunDelegateRef</span> delegate = <span class="built_in">CTRunDelegateCreate</span>(&amp; callBacks, (__bridge <span class="keyword">void</span> *)dicPic);</div><div class="line">    <span class="keyword">unichar</span> placeHolder = <span class="number">0xFFFC</span>;</div><div class="line">    <span class="built_in">NSString</span> * placeHolderStr = [<span class="built_in">NSString</span> stringWithCharacters:&amp;placeHolder length:<span class="number">1</span>];</div><div class="line">    <span class="built_in">NSMutableAttributedString</span> * placeHolderAttrStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:placeHolderStr];</div><div class="line">    <span class="built_in">CFAttributedStringSetAttribute</span>((<span class="built_in">CFMutableAttributedStringRef</span>)placeHolderAttrStr, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">1</span>), kCTRunDelegateAttributeName, delegate);</div><div class="line">    <span class="built_in">CFRelease</span>(delegate);</div><div class="line">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:<span class="number">12</span>];</div><div class="line">    <span class="built_in">CTFramesetterRef</span> frameSetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributeStr);</div><div class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</div><div class="line">    <span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="keyword">self</span>.bounds);</div><div class="line">    <span class="built_in">NSInteger</span> length = attributeStr.length;</div><div class="line">    _length = attributeStr.length;</div><div class="line">    <span class="built_in">CTFrameRef</span> frame = <span class="built_in">CTFramesetterCreateFrame</span>(frameSetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, length), path, <span class="literal">NULL</span>);</div><div class="line">    _ctFrame = frame;</div><div class="line">    <span class="built_in">CTFrameDraw</span>(frame, context);</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"bd_logo1.jpeg"</span>];</div><div class="line">    <span class="built_in">CGRect</span> imgFrm = [<span class="keyword">self</span> calculateImageRectWithFrame:frame];</div><div class="line">    <span class="keyword">self</span>.imgFrm = imgFrm;</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context,imgFrm, image.CGImage);</div><div class="line">    </div><div class="line">    <span class="built_in">CFRelease</span>(path);</div><div class="line">    <span class="built_in">CFRelease</span>(frameSetter);</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> ascentCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref valueForKey:<span class="string">@"height"</span>] floatValue];</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> descentCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> widthCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref valueForKey:<span class="string">@"width"</span>] floatValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">-(<span class="built_in">CGRect</span>)calculateImageRectWithFrame:(<span class="built_in">CTFrameRef</span>)frame</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> * arrLines = (<span class="built_in">NSArray</span> *)<span class="built_in">CTFrameGetLines</span>(frame);</div><div class="line">    <span class="built_in">NSInteger</span> count = [arrLines count];</div><div class="line">    <span class="built_in">CGPoint</span> points[count];</div><div class="line">    <span class="built_in">CTFrameGetLineOrigins</span>(frame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), points);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</div><div class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)arrLines[i];</div><div class="line">        <span class="built_in">NSArray</span> * arrGlyphRun = (<span class="built_in">NSArray</span> *)<span class="built_in">CTLineGetGlyphRuns</span>(line);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrGlyphRun.count; j ++) &#123;</div><div class="line">            <span class="built_in">CTRunRef</span> run = (__bridge <span class="built_in">CTRunRef</span>)arrGlyphRun[j];</div><div class="line">            <span class="built_in">NSDictionary</span> * attributes = (<span class="built_in">NSDictionary</span> *)<span class="built_in">CTRunGetAttributes</span>(run);            <span class="built_in">CTRunDelegateRef</span> delegate = (__bridge <span class="built_in">CTRunDelegateRef</span>)[attributes valueForKey:(<span class="keyword">id</span>)kCTRunDelegateAttributeName];</div><div class="line">            <span class="keyword">if</span> (delegate == <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSDictionary</span> * dic = <span class="built_in">CTRunDelegateGetRefCon</span>(delegate);</div><div class="line">            <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">CGPoint</span> point = points[i];</div><div class="line">            <span class="built_in">CGFloat</span> ascent;</div><div class="line">            <span class="built_in">CGFloat</span> descent;</div><div class="line">            <span class="built_in">CGRect</span> boundsRun;</div><div class="line">            boundsRun.size.width = <span class="built_in">CTRunGetTypographicBounds</span>(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;ascent, &amp;descent, <span class="literal">NULL</span>);</div><div class="line">            boundsRun.size.height = ascent + descent;</div><div class="line">            <span class="built_in">CGFloat</span> xOffset = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, <span class="built_in">CTRunGetStringRange</span>(run).location, <span class="literal">NULL</span>);</div><div class="line">            boundsRun.origin.x = point.x + xOffset;</div><div class="line">            boundsRun.origin.y = point.y - descent;</div><div class="line">            <span class="built_in">CGPathRef</span> path = <span class="built_in">CTFrameGetPath</span>(frame);</div><div class="line">            <span class="built_in">CGRect</span> colRect = <span class="built_in">CGPathGetBoundingBox</span>(path);</div><div class="line">            <span class="built_in">CGRect</span> imageBounds = <span class="built_in">CGRectOffset</span>(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class="line">            <span class="keyword">return</span> imageBounds;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectZero</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CFRelease</span>(_ctFrame);</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"><span class="meta">#### 逐句解释</span></div><div class="line"></div><div class="line">```objectivec</div><div class="line"> <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();<span class="comment">//获取当前绘制上下文</span></div></pre></td></tr></table></figure><br><br>所有的绘制操作都是在上下文上进行绘制的<br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置当前文本矩阵为不做图形变换</span></div><div class="line"><span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>); </div><div class="line"><span class="comment">//平移方法，将context向上平移一个屏幕高</span></div><div class="line"><span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.height);</div><div class="line"><span class="comment">//缩放方法，x轴缩放系数为1，则不变，y轴缩放系数为-1，则相当于以x轴为轴旋转180度</span></div><div class="line"><span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, <span class="number">-1.0</span>);</div></pre></td></tr></table></figure><br><br>coreText 起初是为OSX设计的，而OSX得坐标原点是左下角，y轴正方向朝上。iOS中坐标原点是左上角，y轴正方向向下。若不进行坐标转换，则文字从下开始，还是倒着的。这三句对context的坐标系进行转换<br>&gt;context说的是绘画人所处的角度上下文,画布无论怎么样都是正对着屏幕的，它不会旋转，或者放大缩小，或者移动,认为context就是画布这种理解是错误的<br>CTM，Context Translate Matrix。 它是把要绘制的上下文以一个叫做Matrix的东西来表示，可以简单地想作，绘制的上下文的每一个点都映射在Matrix上，你在Matrix上的操作都会使得上下文上的点产生相应的变动。如放大、旋转、移动。<br><br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">事实上，图文混排就是在要插入图片的位置插入一个富文本类型的占位符。通过CTRUNDelegate设置图片</div><div class="line">设置一个回调结构体，告诉代理该回调那些方法</div><div class="line">*/</div><div class="line"><span class="comment">//创建一个回调结构体，设置相关参数</span></div><div class="line"><span class="built_in">CTRunDelegateCallbacks</span> callBacks;</div><div class="line"><span class="comment">//memset将已开辟内存空间 callbacks 的首 n 个字节的值设为值 0, 相当于对CTRunDelegateCallbacks内存空间初始化</span></div><div class="line">memset(&amp;callBacks,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">CTRunDelegateCallbacks</span>));</div><div class="line"><span class="comment">//设置回调版本，默认这个</span></div><div class="line">callBacks.version = kCTRunDelegateVersion1;</div><div class="line"><span class="comment">//设置图片顶部距离基线的距离</span></div><div class="line">callBacks.getAscent = ascentCallBacks;</div><div class="line"><span class="comment">//设置图片底部距离基线的距离</span></div><div class="line">callBacks.getDescent = descentCallBacks;</div><div class="line"><span class="comment">//设置图片宽度</span></div><div class="line">callBacks.getWidth = widthCallBacks;</div></pre></td></tr></table></figure><br><br>coreText中大量的调用c的方法。大部分跟系统底层有关的都需要调c的方法。所以设置代理要按照人家的方法来啊。<br><br><font color="#ff00ff" size="3px">补充一下知识</font>  <p><img src="http://oui2ar2u7.bkt.clouddn.com/e34179b7262c069a.gif" alt="">  </p><p>这是一个CTRun的尺寸图，我们绘制图片的时候实际上实在一个CTRun中绘制这个图片，那么CTRun绘制的坐标系中，它会以origin点作为原点进行绘制。<br><code>基线为过原点的x轴，ascent即为CTRun顶线距基线的距离，descent即为底线距基线的距离。</code><br>我们绘制图片应该从原点开始绘制，图片的高度及宽度及CTRun的高度及宽度，我们通过代理设置CTRun的尺寸间接设置图片的尺寸。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> * dicPic = @&#123;<span class="string">@"height"</span>:@<span class="number">129</span>,<span class="string">@"width"</span>:@<span class="number">129</span>&#125;;</div><div class="line"><span class="built_in">CTRunDelegateRef</span> delegate = <span class="built_in">CTRunDelegateCreate</span>(&amp; callBacks, (__bridge <span class="keyword">void</span> *)dicPic);</div></pre></td></tr></table></figure><p>上面只是设置了回调结构体，然而我们还没有告诉这个代理我们要的图片尺寸。<br>所以这句话就在<code>设置代理的时候绑定了一个返回图片尺寸的字典。</code><br>事实上此处你可以<code>绑定任意对象</code>。此处你<code>绑定的对象既是回调方法中的参数ref</code>。<br>三个回调方法代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> ascentCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref valueForKey:<span class="string">@"height"</span>] floatValue];</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> descentCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> widthCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref valueForKey:<span class="string">@"width"</span>] floatValue];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于是c的方法，所以也没有什么对象的概念。是一个指针类型的数据。不过oc的对象其实也就是c的结构体。我们可以通过类型转换获得oc中的字典。<br><code>__bridge既是C的结构体转换成OC对象时需要的一个修饰词。</code></p><p>图片的插入(创建一个富文本类型的图片占位符，绑定我们的代理)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建空白字符</span></div><div class="line"><span class="keyword">unichar</span> placeHolder = <span class="number">0xFFFC</span>;</div><div class="line"><span class="comment">//已空白字符生成字符串</span></div><div class="line"><span class="built_in">NSString</span> * placeHolderStr = [<span class="built_in">NSString</span> stringWithCharacters:&amp;placeHolder length:<span class="number">1</span>];</div><div class="line"><span class="comment">//用字符串初始化占位符的富文本</span></div><div class="line"><span class="built_in">NSMutableAttributedString</span> * placeHolderAttrStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:placeHolderStr];</div><div class="line"><span class="comment">//给字符串中的范围中字符串设置代理</span></div><div class="line"><span class="built_in">CFAttributedStringSetAttribute</span>((<span class="built_in">CFMutableAttributedStringRef</span>)placeHolderAttrStr, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">1</span>), kCTRunDelegateAttributeName, delegate);</div><div class="line"><span class="comment">//释放（__bridge进行C与OC数据类型的转换，C为非ARC，需要手动管理）</span></div><div class="line"><span class="built_in">CFRelease</span>(delegate);</div></pre></td></tr></table></figure><p>C中就是传递指针的数据比如说字符串，数组时转换不需要用__bridge<br>需要手动释放是因为进行了类型转换之后就不属于对象了，也不再归自动引用计数机制管理了，所以手动管理。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将占位符插入原富文本</span></div><div class="line">[attributeStr insertAttributedString:placeHolderAttrStr atIndex:<span class="number">12</span>];</div></pre></td></tr></table></figure><p>绘制文本</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个frame的工厂，负责生成frame</span></div><div class="line"><span class="built_in">CTFramesetterRef</span> frameSetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributeStr);</div><div class="line"><span class="comment">//创建绘制区域</span></div><div class="line"><span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</div><div class="line"><span class="comment">//添加绘制尺寸</span></div><div class="line"><span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="keyword">self</span>.bounds);</div><div class="line"><span class="built_in">NSInteger</span> length = attributeStr.length;</div><div class="line"><span class="comment">//工厂根据绘制区域及富文本（可选范围，多次设置）设置frame</span></div><div class="line"><span class="built_in">CTFrameRef</span> frame = <span class="built_in">CTFramesetterCreateFrame</span>(frameSetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,length), path, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//根据frame绘制文字</span></div><div class="line"><span class="built_in">CTFrameDraw</span>(frame, context);</div></pre></td></tr></table></figure><p><strong><code>frameSetter</code></strong>是根据富文本生成的一个<strong><code>frame</code></strong>生成的工厂，你可以通过<strong><code>framesetter</code></strong>以及你想要绘制的富文本的范围获取该CTRun的frame。<br>但是你需要注意的是，获取的frame是仅绘制你所需要的那部分富文本的frame。即当前情况下，你绘制范围定为（10，1），那么你得到的尺寸是只绘制（10，1）的尺寸，他应该从屏幕左上角开始（因为你改变了坐标系），而不是当你绘制全部富文本时他该在的位置。</p><p>然后建立一会绘制的尺寸，实际上就是在指定你的绘制范围。<br>接着生成整个富文本绘制所需要的<strong><code>frame</code></strong>。因为范围是全部文本，所以获取的frame即为全部文本的frame(一定要搞清楚全部与指定范围获取的frame他们都是从左上角开始的，否则你会进入一个奇怪的误区，稍后会提到的)。<br>最后，根据你获得的frame，绘制全部富文本  </p><font color="#ff00ff" size="3px">补充一下知识</font>   <p><img src="http://oui2ar2u7.bkt.clouddn.com/c60db79021e6c801.jpg" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/dee7c3a14e289722.jpg" alt="">  </p><blockquote><p>CTFrame可以理解为一个整体的画布由很多行(CTLine)组成，而每一行又由一个或者多个小方块(CTRun)组成，我们不需要自己创建CTRun，Core Text将根据NSAttributedString的属性来自动创建CTRun。每个CTRun对象对应不同的属性，正因此，你可以自由的控制字体、颜色、字间距等等信息。</p><p>CTFramesetter其实就是CTFrame的工厂方法，通过给定的NSAttributedString，生成CTRrame，同时系统自动的创建了CTTypesetter，CTTypesetter就是管理你的字体的类。</p></blockquote><p>绘制图片<br>绘制图片用下面这个方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGContextDrawImage</span>(context,imgFrm, image.CGImage);<span class="comment">//绘制图片</span></div></pre></td></tr></table></figure><p>有三个参数，分别是context，frame，以及image。context就是当前的上下文image就是要添加的那个图片，不过是CGImage类型,通过UIImage转出CGImage就好了，下面讲一下frame的获取:<strong><code>-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</code></strong>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据frame获取需要绘制的线的数组</span></div><div class="line"><span class="built_in">NSArray</span> * arrLines = (<span class="built_in">NSArray</span> *)<span class="built_in">CTFrameGetLines</span>(frame);</div><div class="line"><span class="comment">//获取线的数量</span></div><div class="line"><span class="built_in">NSInteger</span> count = [arrLines count];</div><div class="line"><span class="comment">//建立起点的数组（cgpoint类型为结构体，故用C语言的数组）</span></div><div class="line"><span class="built_in">CGPoint</span> points[count];</div><div class="line"><span class="comment">//获取起点</span></div><div class="line"><span class="built_in">CTFrameGetLineOrigins</span>(frame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), points);</div></pre></td></tr></table></figure><p>因为CTFrameGetLines（）返回值是CFArrayRef类型的数据。就是一个c的数组类型吧<br>每个CTLine都有自己的origin。所以要生成一个相同元素个数的数组去盛放origin对象。<br>然后用CTFrameGetLineOrigins获取所有原点。</p><p>计算frame<br>遍历frame中的所有CTRun，检查是不是我们绑定图片的那个，如果是，根据该CTRun所在CTLine的origin以及CTRun在CTLine中的横向偏移量计算出CTRun的原点，加上其尺寸即为该CTRun的尺寸。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;<span class="comment">//遍历线的数组</span></div><div class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)arrLines[i];</div><div class="line">        <span class="built_in">NSArray</span> * arrGlyphRun = (<span class="built_in">NSArray</span> *)<span class="built_in">CTLineGetGlyphRuns</span>(line);<span class="comment">//获取GlyphRun数组（GlyphRun：高效的字符绘制方案）</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrGlyphRun.count; j ++) &#123;<span class="comment">//遍历CTRun数组</span></div><div class="line">            <span class="built_in">CTRunRef</span> run = (__bridge <span class="built_in">CTRunRef</span>)arrGlyphRun[j];<span class="comment">//获取CTRun</span></div><div class="line">            <span class="built_in">NSDictionary</span> * attributes = (<span class="built_in">NSDictionary</span> *)<span class="built_in">CTRunGetAttributes</span>(run);<span class="comment">//获取CTRun的属性</span></div><div class="line">            <span class="built_in">CTRunDelegateRef</span> delegate = (__bridge <span class="built_in">CTRunDelegateRef</span>)[attributes valueForKey:(<span class="keyword">id</span>)kCTRunDelegateAttributeName];<span class="comment">//获取代理</span></div><div class="line">            <span class="keyword">if</span> (delegate == <span class="literal">nil</span>) &#123;<span class="comment">//非空</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSDictionary</span> * dic = <span class="built_in">CTRunDelegateGetRefCon</span>(delegate);<span class="comment">//判断代理字典</span></div><div class="line">            <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">CGPoint</span> point = points[i];<span class="comment">//获取一个起点</span></div><div class="line">            <span class="built_in">CGFloat</span> ascent;<span class="comment">//获取上距</span></div><div class="line">            <span class="built_in">CGFloat</span> descent;<span class="comment">//获取下距</span></div><div class="line">            <span class="built_in">CGRect</span> boundsRun;<span class="comment">//创建一个frame</span></div><div class="line">            boundsRun.size.width = <span class="built_in">CTRunGetTypographicBounds</span>(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;ascent, &amp;descent, <span class="literal">NULL</span>);</div><div class="line">            boundsRun.size.height = ascent + descent;<span class="comment">//取得高</span></div><div class="line">            <span class="built_in">CGFloat</span> xOffset = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, <span class="built_in">CTRunGetStringRange</span>(run).location, <span class="literal">NULL</span>);<span class="comment">//获取x偏移量</span></div><div class="line">            boundsRun.origin.x = point.x + xOffset;<span class="comment">//point是行起点位置，加上每个字的偏移量得到每个字的x</span></div><div class="line">            boundsRun.origin.y = point.y - descent;<span class="comment">//计算原点</span></div><div class="line">            <span class="built_in">CGPathRef</span> path = <span class="built_in">CTFrameGetPath</span>(frame);<span class="comment">//获取绘制区域</span></div><div class="line">            <span class="built_in">CGRect</span> colRect = <span class="built_in">CGPathGetBoundingBox</span>(path);<span class="comment">//获取剪裁区域边框</span></div><div class="line">            <span class="built_in">CGRect</span> imageBounds = <span class="built_in">CGRectOffset</span>(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class="line">            <span class="keyword">return</span> imageBounds;</div></pre></td></tr></table></figure><p>手动释放创建的对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFRelease</span>(path);</div><div class="line"><span class="built_in">CFRelease</span>(frameSetter);</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CFRelease</span>(_ctFrame);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="两坐标系中point和frame的变换"><a href="#两坐标系中point和frame的变换" class="headerlink" title="两坐标系中point和frame的变换"></a>两坐标系中point和frame的变换</h4><blockquote><p>point<br>UIKit坐标系上的point转换为CoreText坐标系上的point，在UIKit坐标系上的一个点为(x,y),其在CoreText坐标系上为(x,self.bounds.size.height - y)<br>反过来转换也是一样的在CoreText坐标系上的一个点为(x,y),其在UIKit坐标系上为(x,self.bounds.size.height - y)  </p><p>frame<br>UIKit坐标系上的frame转换为CoreText坐标系上的frame，在UIKit坐标系上的一个frame为(x,y,width,height),其在CoreText坐标系上为(x,self.bounds.size.height - y - height,width,height)<br>反过来转换也是一样的在CoreText坐标系上的一个frame为(x,y,width,height),其在UIKit坐标系上为(x,self.bounds.size.height - y - height,width,height)</p></blockquote><h3 id="实现点击事件"><a href="#实现点击事件" class="headerlink" title="实现点击事件"></a>实现点击事件</h3><p>通过touchBegan方法拿到当前点击到的点，然后通过坐标判断这个点是否在某段文字上，如果在则触发对应事件。  </p><h4 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UITouch</span> * touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> location = [<span class="keyword">self</span> systemPointFromScreenPoint:[touch locationInView:<span class="keyword">self</span>]];</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> checkIsClickOnImgWithPoint:location])</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> clickOnStrWithPoint:location];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)checkIsClickOnImgWithPoint:(<span class="built_in">CGPoint</span>)location</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isFrame:<span class="keyword">self</span>.imgFrm containsPoint:location])</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"您点击到了图片"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)clickOnStrWithPoint:(<span class="built_in">CGPoint</span>)location</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> * lines = (<span class="built_in">NSArray</span> *)<span class="built_in">CTFrameGetLines</span>(_ctFrame);</div><div class="line">    <span class="built_in">CFRange</span> ranges[lines.count];</div><div class="line">    <span class="built_in">CGPoint</span> origins[lines.count];</div><div class="line">    <span class="built_in">CTFrameGetLineOrigins</span>(_ctFrame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), origins);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.count; i ++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)lines[i];</div><div class="line">        <span class="built_in">CFRange</span> range = <span class="built_in">CTLineGetStringRange</span>(line);</div><div class="line">        ranges[i] = range;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _length; i ++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">long</span> maxLoc = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lineNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lines.count; j ++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">CFRange</span> range = ranges[j];</div><div class="line">            maxLoc = range.location + range.length <span class="number">-1</span>;</div><div class="line">            <span class="keyword">if</span> (i &lt;= maxLoc)</div><div class="line">            &#123;</div><div class="line">                lineNum = j;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)lines[lineNum];</div><div class="line">        <span class="built_in">CGPoint</span> origin = origins[lineNum];</div><div class="line">        <span class="built_in">CGRect</span> <span class="built_in">CTRunFrame</span> = [<span class="keyword">self</span> frameForCTRunWithIndex:i <span class="built_in">CTLine</span>:line origin:origin];</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isFrame:<span class="built_in">CTRunFrame</span> containsPoint:location])</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。"</span>,i,lineNum + <span class="number">1</span>);<span class="comment">//点击到文字，然而没有响应的处理。可以做其他处理</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"您没有点击到文字"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)isIndex:(<span class="built_in">NSInteger</span>)index inRange:(<span class="built_in">NSRange</span>)range</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ((index &lt;= range.location + range.length - <span class="number">1</span>) &amp;&amp; (index &gt;= range.location))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGPoint</span>)systemPointFromScreenPoint:(<span class="built_in">CGPoint</span>)origin</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(origin.x, <span class="keyword">self</span>.bounds.size.height - origin.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)isFrame:(<span class="built_in">CGRect</span>)frame containsPoint:(<span class="built_in">CGPoint</span>)point</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(frame, point);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)frameForCTRunWithIndex:(<span class="built_in">NSInteger</span>)index <span class="built_in">CTLine</span>:(<span class="built_in">CTLineRef</span>)line origin:(<span class="built_in">CGPoint</span>)origin</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGFloat</span> offsetX = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, index, <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">CGFloat</span> offsetX2 = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, index + <span class="number">1</span>, <span class="literal">NULL</span>);</div><div class="line">    offsetX += origin.x;</div><div class="line">    offsetX2 += origin.x;</div><div class="line">    <span class="built_in">CGFloat</span> offsetY = origin.y;</div><div class="line">    <span class="built_in">CGFloat</span> lineAscent;</div><div class="line">    <span class="built_in">CGFloat</span> lineDeScent;</div><div class="line">    <span class="built_in">NSArray</span> * runs = (__bridge <span class="built_in">NSArray</span> *)<span class="built_in">CTLineGetGlyphRuns</span>(line);</div><div class="line">    <span class="built_in">CTRunRef</span> runCurrent;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; runs.count; k ++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CTRunRef</span> run = (__bridge <span class="built_in">CTRunRef</span>)runs[k];</div><div class="line">        <span class="built_in">CFRange</span> range = <span class="built_in">CTRunGetStringRange</span>(run);</div><div class="line">        <span class="built_in">NSRange</span> rangeOC = <span class="built_in">NSMakeRange</span>(range.location, range.length);</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isIndex:index inRange:rangeOC])</div><div class="line">        &#123;</div><div class="line">            runCurrent = run;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CTRunGetTypographicBounds</span>(runCurrent, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;lineAscent, &amp;lineDeScent, <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">CGFloat</span> height = lineAscent + lineDeScent;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(offsetX, offsetY, offsetX2 - offsetX, height);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="分段解析"><a href="#分段解析" class="headerlink" title="分段解析"></a>分段解析</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">///点击方法</span></div><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UITouch</span> * touch = [touches anyObject];</div><div class="line">   <span class="comment">//获得点击位置在CoreText坐标系上的坐标</span></div><div class="line">    <span class="built_in">CGPoint</span> location = [<span class="keyword">self</span> systemPointFromScreenPoint:[touch locationInView:<span class="keyword">self</span>]];</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> checkIsClickOnImgWithPoint:location]) &#123;<span class="comment">//检查是否点击在图片上，如果在，优先响应图片事件</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> ClickOnStrWithPoint:location];<span class="comment">//响应字符串事件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>坐标转换<br>因为UIKit坐标系与系统坐标系的不同，我们要将坐标系统一为CoreText坐标</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//坐标转换，将UIkit坐标转换为CoreText坐标</span></div><div class="line">- (<span class="built_in">CGPoint</span>)systemPointFromScreenPoint:(<span class="built_in">CGPoint</span>)origin</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(origin.x, <span class="keyword">self</span>.bounds.size.height - origin.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>点击图片判断  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图片frame的数组与点击位置比较，如果在范围内则响应数组取出对应响应并执行，返回YES,否则返回NO</span></div><div class="line">- (<span class="built_in">BOOL</span>)checkIsClickOnImgWithPoint:(<span class="built_in">CGPoint</span>)location</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isFrame:<span class="keyword">self</span>.imgFrm containsPoint:location])</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"您点击到了图片"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检测点是否包含在frame中</span></div><div class="line">- (<span class="built_in">BOOL</span>)isFrame:(<span class="built_in">CGRect</span>)frame containsPoint:(<span class="built_in">CGPoint</span>)point</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(frame, point);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于传入的point是CoreText坐标（本例中），所以frame我们一定要传入CoreText坐标系下的frame才能正确对应。</p><p>点击文字判断<br><img src="http://oui2ar2u7.bkt.clouddn.com/1501901391x1948173751.png" alt="">  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//字符串点击检查</span></div><div class="line"><span class="comment">//将响应字符串的每个字符取出与点击位置比较，若在范围内则点击到响应文字</span></div><div class="line">- (<span class="keyword">void</span>)clickOnStrWithPoint:(<span class="built_in">CGPoint</span>)location</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> * lines = (<span class="built_in">NSArray</span> *)<span class="built_in">CTFrameGetLines</span>(_ctFrame);<span class="comment">//获取所有CTLine</span></div><div class="line">    <span class="built_in">CFRange</span> ranges[lines.count];<span class="comment">//初始化每一CTLine的range数组</span></div><div class="line">    <span class="built_in">CGPoint</span> origins[lines.count];<span class="comment">//初始化每一CTLine的原点数组</span></div><div class="line">    <span class="built_in">CTFrameGetLineOrigins</span>(_ctFrame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), origins);<span class="comment">//获取所有CTLine的原点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.count; i ++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)lines[i];</div><div class="line">        <span class="built_in">CFRange</span> range = <span class="built_in">CTLineGetStringRange</span>(line);</div><div class="line">        ranges[i] = range;</div><div class="line">    &#125;<span class="comment">//获得所有CTLine的Range</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _length; i ++)</div><div class="line">    &#123;<span class="comment">//逐字检查</span></div><div class="line">        <span class="keyword">long</span> maxLoc = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lineNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lines.count; j ++)</div><div class="line">        &#123;<span class="comment">//获取对应字符所在CTLine的index</span></div><div class="line">            <span class="built_in">CFRange</span> range = ranges[j];</div><div class="line">            maxLoc = range.location + range.length <span class="number">-1</span>;</div><div class="line">            <span class="keyword">if</span> (i &lt;= maxLoc)</div><div class="line">            &#123;</div><div class="line">                lineNum = j;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)lines[lineNum];<span class="comment">//取到字符对应的CTLine</span></div><div class="line">        <span class="built_in">CGPoint</span> origin = origins[lineNum];<span class="comment">//获得字符对应的CTLine的原点</span></div><div class="line">        <span class="built_in">CGRect</span> <span class="built_in">CTRunFrame</span> = [<span class="keyword">self</span> frameForCTRunWithIndex:i <span class="built_in">CTLine</span>:line origin:origin];<span class="comment">//计算对应字符的frame</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isFrame:<span class="built_in">CTRunFrame</span> containsPoint:location])</div><div class="line">        &#123;<span class="comment">//如果点击位置在字符范围内，响应时间，跳出循环</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"您点击到了第 %d 个字符，位于第 %d 行，然而他没有响应事件。"</span>,i,lineNum + <span class="number">1</span>);<span class="comment">//点击到文字，然而没有响应的处理。可以做其他处理</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"您没有点击到文字"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">///字符frame计算</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 返回索引字符的frame</div><div class="line"></div><div class="line"> index：索引</div><div class="line"> line：索引字符所在CTLine</div><div class="line"> origin：line的起点</div><div class="line">*/</div><div class="line">-(<span class="built_in">CGRect</span>)frameForCTRunWithIndex:(<span class="built_in">NSInteger</span>)index</div><div class="line">                         <span class="built_in">CTLine</span>:(<span class="built_in">CTLineRef</span>)line</div><div class="line">                         origin:(<span class="built_in">CGPoint</span>)origin</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGFloat</span> offsetX = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, index, <span class="literal">NULL</span>);<span class="comment">//获取字符起点相对于CTLine的原点的偏移量</span></div><div class="line">    <span class="built_in">CGFloat</span> offsexX2 = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, index + <span class="number">1</span>, <span class="literal">NULL</span>);<span class="comment">//获取下一个字符的偏移量，两者之间即为字符X范围</span></div><div class="line">    offsetX += origin.x;</div><div class="line">    offsexX2 += origin.x;<span class="comment">//坐标转换，将点的CTLine坐标转换至CoreText坐标</span></div><div class="line">    <span class="built_in">CGFloat</span> offsetY = origin.y;<span class="comment">//取到CTLine的起点Y</span></div><div class="line">    <span class="built_in">CGFloat</span> lineAscent;<span class="comment">//初始化上下边距的变量</span></div><div class="line">    <span class="built_in">CGFloat</span> lineDescent;</div><div class="line">    <span class="built_in">NSArray</span> * runs = (__bridge <span class="built_in">NSArray</span> *)<span class="built_in">CTLineGetGlyphRuns</span>(line);<span class="comment">//获取所有CTRun</span></div><div class="line">    <span class="built_in">CTRunRef</span> runCurrent;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; runs.count; k ++) &#123;<span class="comment">//获取当前点击的CTRun</span></div><div class="line">        <span class="built_in">CTRunRef</span> run = (__bridge <span class="built_in">CTRunRef</span>)runs[k];</div><div class="line">        <span class="built_in">CFRange</span> range = <span class="built_in">CTRunGetStringRange</span>(run);<span class="comment">//获得CTRun在富文本中的范围</span></div><div class="line">        <span class="built_in">NSRange</span> rangeOC = <span class="built_in">NSMakeRange</span>(range.location, range.length);</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isIndex:index inRange:rangeOC]) &#123;</div><div class="line">            runCurrent = run;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CTRunGetTypographicBounds</span>(runCurrent, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;lineAscent, &amp;lineDescent, <span class="literal">NULL</span>);<span class="comment">//获得对应CTRun的尺寸信息</span></div><div class="line">    offsetY -= lineDescent;</div><div class="line">    <span class="built_in">CGFloat</span> height = lineAscent + lineDescent;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(offsetX, offsetY, offsexX2 - offsetX, height);<span class="comment">//返回一个字符的Frame</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CTLineGetOffsetForStringIndex</span>(,,)</div></pre></td></tr></table></figure><blockquote><p>获取一行文字中，指定charIndex字符相对x原点的偏移量，返回值与第三个参数同为一个值。如果charIndex超出一行的字符长度则反回最大长度结束位置的偏移量，如一行文字共有17个字符，哪么返回的是第18个字符的起始偏移，即第17个偏移+第17个字符占有的宽度=第18个起始位置的偏移。因此想求一行字符所占的像素长度时，就可以使用此函数，将charIndex设置为大于字符长度即可。  </p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">///范围检测</span></div><div class="line">-(<span class="built_in">BOOL</span>)isIndex:(<span class="built_in">NSInteger</span>)index inRange:(<span class="built_in">NSRange</span>)range</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ((index &lt;= range.location + range.length - <span class="number">1</span>) &amp;&amp; (index &gt;= range.location)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="CoreText实现图文混排之文字环绕及点击算法"><a href="#CoreText实现图文混排之文字环绕及点击算法" class="headerlink" title="CoreText实现图文混排之文字环绕及点击算法"></a>CoreText实现图文混排之文字环绕及点击算法</h3><p>整体代码  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CoreTextV</span> ()</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">CTFrameRef</span> _frame;</div><div class="line">    <span class="built_in">NSInteger</span> _length;</div><div class="line">    <span class="built_in">CGRect</span> _imgFrm;</div><div class="line">    <span class="built_in">NSMutableArray</span> * arrText;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CoreTextV</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.height);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>f, <span class="number">-1.0</span>f);</div><div class="line">    arrText = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="built_in">NSMutableAttributedString</span> * attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"</span>];</div><div class="line">    [attributedStr addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:[<span class="built_in">UIColor</span> whiteColor] range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, attributedStr.length)];</div><div class="line">    <span class="built_in">CTRunDelegateCallbacks</span> callBacks;</div><div class="line">    memset(&amp;callBacks, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">CTRunDelegateCallbacks</span>));</div><div class="line">    callBacks.version = kCTRunDelegateVersion1;</div><div class="line">    callBacks.getAscent = ascentCallBacks;</div><div class="line">    callBacks.getDescent = descentCallBacks;</div><div class="line">    callBacks.getWidth = widthCallBacks;</div><div class="line">    <span class="built_in">NSDictionary</span> * dicPic = @&#123;<span class="string">@"height"</span> : @<span class="number">90</span>, <span class="string">@"width"</span> : @<span class="number">160</span>&#125;;</div><div class="line">    <span class="built_in">CTRunDelegateRef</span> delegate = <span class="built_in">CTRunDelegateCreate</span>(&amp;callBacks, (__bridge <span class="keyword">void</span> *)dicPic);</div><div class="line">    <span class="keyword">unichar</span> placeHolder = <span class="number">0xFFFC</span>;</div><div class="line">    <span class="built_in">NSString</span> * placeHolderStr = [<span class="built_in">NSString</span> stringWithCharacters:&amp;placeHolder length:<span class="number">1</span>];</div><div class="line">    <span class="built_in">NSMutableAttributedString</span> * placeHolderAttrStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:placeHolderStr];</div><div class="line">    <span class="built_in">CFAttributedStringSetAttribute</span>((<span class="built_in">CFMutableAttributedStringRef</span>)placeHolderAttrStr, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">1</span>), kCTRunDelegateAttributeName, delegate);</div><div class="line">    <span class="built_in">CFRelease</span>(delegate);</div><div class="line">    [attributedStr insertAttributedString:placeHolderAttrStr atIndex:<span class="number">300</span>];</div><div class="line">    <span class="built_in">NSDictionary</span> * activeAttr = @&#123;<span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor],<span class="string">@"click"</span> : <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(click))&#125;;</div><div class="line">    [attributedStr addAttributes:activeAttr range:<span class="built_in">NSMakeRange</span>(<span class="number">100</span>, <span class="number">30</span>)];</div><div class="line">    [attributedStr addAttributes:activeAttr range:<span class="built_in">NSMakeRange</span>(<span class="number">400</span>, <span class="number">100</span>)];</div><div class="line">    </div><div class="line">    <span class="built_in">CTFramesetterRef</span> frameSetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedStr);</div><div class="line">    <span class="comment">//只要在这个地方传入的path中将特殊区域排除我们获得的frame就不包含该区域，从而绘制的文本也不会在该区域中绘制。</span></div><div class="line">    <span class="built_in">UIBezierPath</span> * path = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="keyword">self</span>.bounds];</div><div class="line">    <span class="built_in">UIBezierPath</span> * cirP = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">    [path appendPath:cirP];</div><div class="line">    _length = attributedStr.length;</div><div class="line">    _frame = <span class="built_in">CTFramesetterCreateFrame</span>(frameSetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, _length), path.CGPath, <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">CTFrameDraw</span>(_frame, context);</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"bd_logo1.jpeg"</span>];</div><div class="line">    [<span class="keyword">self</span> handleActiveRectWithFrame:_frame];</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context, _imgFrm, image.CGImage);</div><div class="line">    </div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context, cirP.bounds, [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"bd_logo1.jpeg"</span>] dw_ClipImageWithPath:cirP mode:DWContentModeScaleAspectFill].CGImage);</div><div class="line">    <span class="built_in">CFRelease</span>(_frame);</div><div class="line">    <span class="built_in">CFRelease</span>(frameSetter);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> ascentCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref valueForKey:<span class="string">@"height"</span>] floatValue];</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> descentCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> widthCallBacks(<span class="keyword">void</span> * ref)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref valueForKey:<span class="string">@"width"</span>] floatValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleActiveRectWithFrame:(<span class="built_in">CTFrameRef</span>)frame</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> * arrLines = (<span class="built_in">NSArray</span> *)<span class="built_in">CTFrameGetLines</span>(frame);</div><div class="line">    <span class="built_in">NSInteger</span> count = [arrLines count];</div><div class="line">    <span class="built_in">CGPoint</span> points[count];</div><div class="line">    <span class="built_in">CTFrameGetLineOrigins</span>(frame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), points);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)arrLines[i];</div><div class="line">        <span class="built_in">NSArray</span> * arrGlyphRun = (<span class="built_in">NSArray</span> *)<span class="built_in">CTLineGetGlyphRuns</span>(line);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrGlyphRun.count; j ++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">CTRunRef</span> run = (__bridge <span class="built_in">CTRunRef</span>)arrGlyphRun[j];</div><div class="line">            <span class="built_in">NSDictionary</span> * attributes = (<span class="built_in">NSDictionary</span> *)<span class="built_in">CTRunGetAttributes</span>(run);</div><div class="line">            <span class="built_in">CTRunDelegateRef</span> delegate = (__bridge <span class="built_in">CTRunDelegateRef</span>)[attributes valueForKey:(<span class="keyword">id</span>)kCTRunDelegateAttributeName];</div><div class="line">            <span class="built_in">CGPoint</span> point = points[i];</div><div class="line">            <span class="keyword">if</span> (delegate == <span class="literal">nil</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">NSString</span> * string = attributes[<span class="string">@"click"</span>];</div><div class="line">                <span class="keyword">if</span> (string)</div><div class="line">                &#123;</div><div class="line">                    [arrText addObject:[<span class="built_in">NSValue</span> valueWithCGRect:[<span class="keyword">self</span> getLocWithFrame:frame <span class="built_in">CTLine</span>:line <span class="built_in">CTRun</span>:run origin:point]]];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSDictionary</span> * metaDic = <span class="built_in">CTRunDelegateGetRefCon</span>(delegate);</div><div class="line">            <span class="keyword">if</span> (![metaDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]])</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            _imgFrm = [<span class="keyword">self</span> getLocWithFrame:frame <span class="built_in">CTLine</span>:line <span class="built_in">CTRun</span>:run origin:point];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)getLocWithFrame:(<span class="built_in">CTFrameRef</span>)frame <span class="built_in">CTLine</span>:(<span class="built_in">CTLineRef</span>)line <span class="built_in">CTRun</span>:(<span class="built_in">CTRunRef</span>)run origin:(<span class="built_in">CGPoint</span>)origin</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGFloat</span> ascent;</div><div class="line">    <span class="built_in">CGFloat</span> descent;</div><div class="line">    <span class="built_in">CGRect</span> boundsRun;</div><div class="line">    boundsRun.size.width = <span class="built_in">CTRunGetTypographicBounds</span>(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;ascent, &amp;descent, <span class="literal">NULL</span>);</div><div class="line">    boundsRun.size.height = ascent + descent;</div><div class="line">    <span class="built_in">CGFloat</span> xOffset = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, <span class="built_in">CTRunGetStringRange</span>(run).location, <span class="literal">NULL</span>);</div><div class="line">    boundsRun.origin.x = origin.x + xOffset;</div><div class="line">    boundsRun.origin.y = origin.y - descent;</div><div class="line">    <span class="built_in">CGPathRef</span> path = <span class="built_in">CTFrameGetPath</span>(frame);</div><div class="line">    <span class="built_in">CGRect</span> colRect = <span class="built_in">CGPathGetBoundingBox</span>(path);</div><div class="line">    <span class="built_in">CGRect</span> deleteBounds = <span class="built_in">CGRectOffset</span>(boundsRun, colRect.origin.x, colRect.origin.y);</div><div class="line">    <span class="keyword">return</span> deleteBounds;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)convertRectFromLoc:(<span class="built_in">CGRect</span>)rect</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(rect.origin.x, <span class="keyword">self</span>.bounds.size.height - rect.origin.y - rect.size.height, rect.size.width, rect.size.height);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGPoint</span>)systemPointFromScreenPoint:(<span class="built_in">CGPoint</span>)origin</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(origin.x, <span class="keyword">self</span>.bounds.size.height - origin.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UITouch</span> * touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> location = [<span class="keyword">self</span> systemPointFromScreenPoint:[touch locationInView:<span class="keyword">self</span>]];</div><div class="line"><span class="comment">//    CGRect imageFrmToScreen = [self convertRectFromLoc:_imgFrm];</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(_imgFrm, location))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"您点击了图片"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [arrText enumerateObjectsUsingBlock:^(<span class="built_in">NSValue</span> * rectV, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line"><span class="comment">//        CGRect textFrmToScreen = [self convertRectFromLoc:[rectV CGRectValue]];</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(rectV.CGRectValue, location))</div><div class="line">        &#123;</div><div class="line">            [<span class="keyword">self</span> click];</div><div class="line">            *stop = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)click</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"您点击了文字"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p><img src="http://oui2ar2u7.bkt.clouddn.com/1501913622x1948173751.png" alt=""><br>为什么cirP的rect是CGRectMake(100, 100, 100, 200)，这个排除的区域却在那里?原因就在于UIKit坐标系统跟CoreText坐标系统的区别。  </p><p>绘制椭圆图片可以借助github上的一个工具库<a href="https://github.com/CodeWicky/-Tools" target="_blank" rel="external">DWImageUtils</a> 贴上代码 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)dw_ClipImageWithPath:(<span class="built_in">UIBezierPath</span> *)path mode:(DWContentMode)mode</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGFloat</span> originScale = <span class="keyword">self</span>.size.width * <span class="number">1.0</span> / <span class="keyword">self</span>.size.height;</div><div class="line">    <span class="built_in">CGRect</span> boxBounds = path.bounds;</div><div class="line">    <span class="built_in">CGFloat</span> width = boxBounds.size.width;</div><div class="line">    <span class="built_in">CGFloat</span> height = width / originScale;</div><div class="line">    <span class="keyword">switch</span> (mode) &#123;</div><div class="line">        <span class="keyword">case</span> DWContentModeScaleAspectFit:</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (height &gt; boxBounds.size.height) &#123;</div><div class="line">                height = boxBounds.size.height;</div><div class="line">                width = height * originScale;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> DWContentModeScaleAspectFill:</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (height &lt; boxBounds.size.height) &#123;</div><div class="line">                height = boxBounds.size.height;</div><div class="line">                width = height * originScale;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">if</span> (height != boxBounds.size.height) &#123;</div><div class="line">                height = boxBounds.size.height;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">///开启上下文</span></div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(boxBounds.size, <span class="literal">NO</span>, [<span class="built_in">UIScreen</span> mainScreen].scale);</div><div class="line">    <span class="built_in">CGContextRef</span> bitmap = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">///归零path</span></div><div class="line">    <span class="built_in">UIBezierPath</span> * newPath = [path <span class="keyword">copy</span>];</div><div class="line">    [newPath applyTransform:<span class="built_in">CGAffineTransformMakeTranslation</span>(-path.bounds.origin.x, -path.bounds.origin.y)];</div><div class="line">    [newPath addClip];</div><div class="line">    </div><div class="line">    <span class="comment">///移动原点至图片中心</span></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(bitmap, boxBounds.size.width / <span class="number">2.0</span>, boxBounds.size.height / <span class="number">2.0</span>);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(bitmap, <span class="number">1.0</span>, <span class="number">-1.0</span>);</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(bitmap, <span class="built_in">CGRectMake</span>(-width / <span class="number">2</span>, -height / <span class="number">2</span>, width, height), <span class="keyword">self</span>.CGImage);</div><div class="line">    </div><div class="line">    <span class="comment">///生成图片</span></div><div class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> newImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://oui2ar2u7.bkt.clouddn.com/1501907720x1948173751.png" alt="">  </p><p>点击事件获取<br>1、主流方式：CTLineGetStringIndexForPosition</p><blockquote><p>主流方式就是当前大部分基于CoreText封装的富文本展示类（包括TTTAttributedLabel、NIAttributedLabel和FTCoreTextView）中使用的方法 CTLineGetStringIndexForPosition。这个方法是获取当前点在所在文字处于当前绘制文本的索引值。事实上如果没有一些其他因素的话，能使用这个方法是最简便快捷的</p><p>但是在实际使用中CTLineGetStringIndexForPosition这个方法<font color="#0000ff">获取一个字的index范围是这个字前面大概半个字开始到这个字中间的位置,从这个字的中间到这个字的后半个字就会获得下一个字的index。</font>  </p><p>CTLineGetStringIndexForPosition这个方法还有另一个作用还是很好用的。这个方法最好的用处就是判断一行CTLine最多容纳多少的字符，只需把这个point的x位置调很大（超过CTFrame path的宽度）就可以了。</p></blockquote><p>2、遍历CTRun比较法 (代码中的写法)<br>一次遍历中拿到所有活动图片和活动文字的frame，按照点击图片的处理方式处理文字，在添加点击事件的活动文本的特征点中添加加了click(属性名随便写，不要太low就行了)这么一个属性。通过遍历CTRun将活动文本的frame算出来，并存到一个数组里面arrText。</p><pre><code class="objectivec">[arrText addObject:[<span class="built_in">NSValue</span> valueWithCGRect:[<span class="keyword">self</span> getLocWithFrame:frame <span class="built_in">CTLine</span>:line <span class="built_in">CTRun</span>:run origin:point]]];</code></pre><blockquote><p>注意：文字frame不同于获取图片的frame。由于图片是在一个空白占位符上绘制文字，所以一定是以一个CTRun进行绘制的。但是第一篇文章中老司机说过，每个CTRun是所有具有相同属性的连续同行文字的集合。针对CTRun的特性，我们不难想到，文字由于可能出现两行，也有可能会活动文本的字体字号等其他属性不尽相同导致一段文字由两个CTRun进行绘制，所以不能单纯的保存一个frame，而是要以一个数组容纳他。再通过一些逻辑将不同的活动文本区别开来。</p></blockquote><p>参考：<br><a href="http://www.jianshu.com/p/6db3289fb05d" target="_blank" rel="external">CoreText实现图文混排</a><br><a href="http://www.jianshu.com/p/51c47329203e" target="_blank" rel="external">CoreText实现图文混排之点击事件</a><br><a href="http://www.jianshu.com/p/e154047b0f98" target="_blank" rel="external">CoreText实现图文混排之文字环绕及点击算法</a><br><a href="http://www.cnblogs.com/gatsbywang/p/4248977.html" target="_blank" rel="external">CoreText中坐标转换的一些理解</a><br><a href="http://blog.csdn.net/majiakun1/article/details/38140411" target="_blank" rel="external">CTLineRef详细介绍</a><br><a href="http://www.tuicool.com/articles/FfYjim" target="_blank" rel="external">CoreText原理及基本使用方法</a><br><a href="https://my.oschina.net/megan/blog/269042" target="_blank" rel="external">CoreText 实现图文混排</a><br><a href="https://my.oschina.net/u/2361492/blog/526814" target="_blank" rel="external">使用CoreText实现图文混排</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CoreText简介&quot;&gt;&lt;a href=&quot;#CoreText简介&quot; class=&quot;headerlink&quot; title=&quot;CoreText简介&quot;&gt;&lt;/a&gt;CoreText简介&lt;/h3&gt;&lt;p&gt;Core Text 是基于 iOS 3.2+ 和 OSX 10.5+ 的一种
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跳到设置页面以及App间跳转</title>
    <link href="http://yoursite.com/2017/08/04/%E8%B7%B3%E5%88%B0%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8AApp%E9%97%B4%E8%B7%B3%E8%BD%AC/"/>
    <id>http://yoursite.com/2017/08/04/跳到设置页面以及App间跳转/</id>
    <published>2017-08-04T15:23:40.000Z</published>
    <updated>2017-08-04T15:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>###从APP跳转至设置页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">跳转的URL写法:    </div><div class="line">设置页面 App-Prefs:root(之前在那个设置页面，就跳转到相应的设置页面)      </div><div class="line">无线局域网 App-Prefs:root=WIFI</div><div class="line">蓝牙 App-Prefs:root=Bluetooth</div><div class="line">蜂窝移动网络 App-Prefs:root=MOBILE_DATA_SETTINGS_ID</div><div class="line">个人热点 App-Prefs:root=INTERNET_TETHERING</div><div class="line">运营商 App-Prefs:root=Carrier</div><div class="line">通知 App-Prefs:root=NOTIFICATIONS_ID</div><div class="line">通用 App-Prefs:root=General</div><div class="line">通用-关于本机 App-Prefs:root=General&amp;path=About</div><div class="line">通用-键盘 App-Prefs:root=General&amp;path=Keyboard</div><div class="line">通用-辅助功能 App-Prefs:root=General&amp;path=ACCESSIBILITY</div><div class="line">通用-语言与地区 App-Prefs:root=General&amp;path=INTERNATIONAL</div><div class="line">通用-还原 App-Prefs:root=Reset</div><div class="line">墙纸 App-Prefs:root=Wallpaper</div><div class="line">Siri App-Prefs:root=SIRI</div><div class="line">隐私 App-Prefs:root=Privacy</div><div class="line">Safari App-Prefs:root=SAFARI</div><div class="line">音乐 App-Prefs:root=MUSIC</div><div class="line">音乐-均衡器 App-Prefs:root=MUSIC&amp;path=com.apple.Music:EQ</div><div class="line">照片与相机 App-Prefs:root=Photos</div><div class="line">FaceTime App-Prefs:root=FACETIME</div></pre></td></tr></table></figure><p><strong>使用例子</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define iOS10 ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 10.0)</span></div><div class="line"> <span class="comment">//宏定义，判断是否是 iOS10.0以上</span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span> * urlStr = <span class="string">@"App-Prefs:root=Bluetooth"</span>;</div><div class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:urlStr]]) &#123;</div><div class="line">        <span class="keyword">if</span> (iOS10) &#123;</div><div class="line">            <span class="comment">//iOS10.0以上  使用的操作</span></div><div class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:urlStr] options:@&#123;&#125; completionHandler:<span class="literal">nil</span>];</div><div class="line">        &#125; <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            <span class="comment">//iOS10.0以下  使用的操作</span></div><div class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:urlStr]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//iOS10.0以上 ，使用的操作方法</span></div><div class="line">- (<span class="keyword">void</span>)openURL:(<span class="built_in">NSURL</span>*)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options completionHandler:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="built_in">BOOL</span> success))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0) <span class="built_in">NS_EXTENSION_UNAVAILABLE_IOS</span>(<span class="string">""</span>);</div><div class="line">```  </div><div class="line"></div><div class="line">```objectivec</div><div class="line"><span class="comment">//iOS10.0以下，使用的操作方法</span></div><div class="line">- (<span class="built_in">BOOL</span>)openURL:(<span class="built_in">NSURL</span>*)url <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">10</span>_0, <span class="string">"Please use openURL:options:completionHandler: instead"</span>) <span class="built_in">NS_EXTENSION_UNAVAILABLE_IOS</span>(<span class="string">""</span>);</div></pre></td></tr></table></figure><p>注:<code>prefs:root=</code> 在iOS10以上的系统没作用了，而且可能会被app store 拒绝，应该这不是公开的URL Scheme了</p><h3 id="APP之间的跳转"><a href="#APP之间的跳转" class="headerlink" title="APP之间的跳转"></a>APP之间的跳转</h3><p>添加一个URL type  URL Schemes设置为APP的跳转标识(其道理同<strong>设置页面</strong>的跳转) 如何skipToFirst<br><img src="http://i1.bvimg.com/1949/7d52ebeab120f8b5.png" alt="URL type"><br>在第二个APP中，在需要跳转到第一个APP的地方，添加以下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * URLString = <span class="string">@"skipToFirst://"</span>;</div><div class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:URLString];</div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div></pre></td></tr></table></figure><p>重新运行第二个APP，并且触发跳转到第一个APP的事件，就完成APP之间的跳转了。</p><h3 id="APP间的传值"><a href="#APP间的传值" class="headerlink" title="APP间的传值"></a>APP间的传值</h3><p>实现APP间跳转的功能。<br>跳转的代码修改为</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * URLString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"skipToFirst://userName=%@&amp;password=%@"</span>,<span class="string">@"userName"</span>,<span class="string">@"123456"</span>];</div><div class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:URLString];</div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</div></pre></td></tr></table></figure><p>在第一个App的AppDelegate中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *urlStr = [url absoluteString];  <span class="comment">//转化为 完整的url字符串</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,urlStr);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//iOS9之后苹果建议用</span></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationOpenURLOptionsKey</span>,<span class="keyword">id</span>&gt; *)options</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *urlStr = [url absoluteString];  <span class="comment">//转化为 完整的url字符串</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,urlStr);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就获取到了urlStr字符串，之后就是自己根据需要的数据对里面的字符串进行处理。</p><h3 id="UIApplication-sharedApplication-openURL-其他应用"><a href="#UIApplication-sharedApplication-openURL-其他应用" class="headerlink" title="[[UIApplication sharedApplication] openURL: ]其他应用"></a>[[UIApplication sharedApplication] openURL: ]其他应用</h3><p>调用电话拨号</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拨打电话时，不出现确认框</span></div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"tel://13800138000"</span>]]; </div><div class="line"></div><div class="line"><span class="comment">// 拨打电话时，弹出确认框</span></div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"telprompt://800888"</span>]];</div></pre></td></tr></table></figure><p>调用自带Mail</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mailto后加自己账户</span></div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"mailto://admin@yourName.com"</span>]]; </div><div class="line">```  </div><div class="line">调用safari  </div><div class="line"></div><div class="line">```objectivec</div><div class="line"><span class="comment">// 调到百度主页</span></div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com"</span>]];</div></pre></td></tr></table></figure><p>调用短信SMS</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"sms://10086"</span>]];</div></pre></td></tr></table></figure><p>调用app Store</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"itms-apps://"</span>]];</div></pre></td></tr></table></figure><p>调用iBook</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"itms-books://"</span>]];</div></pre></td></tr></table></figure><p>调用 Map</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"maps://"</span>]];</div></pre></td></tr></table></figure><p>调用 Facetime➕自己账户</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意后面加上faceTime的账号</span></div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"facetime://"</span>]];</div></pre></td></tr></table></figure><p>常用的App的URL Schemes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">“QQ”的url是 mqq:// </div><div class="line">  “微信”是 weixin:// </div><div class="line">  “淘宝”是 taobao:// </div><div class="line">  “点评”是 dianping://     dianping://search </div><div class="line">  “微博”是 sinaweibo:// </div><div class="line">  “名片全能王”是 camcard:// </div><div class="line">  “weico微博”是 weico:// </div><div class="line">  “支付宝”是 alipay:// </div><div class="line">  “豆瓣fm”是 doubanradio:// </div><div class="line">  “微盘”是 sinavdisk:// </div><div class="line">  “网易公开课”是 ntesopen://</div><div class="line">  “美团”是 i**:// </div><div class="line">  “京东”是 openapp.jdmoble:// </div><div class="line">  “人人”是 renren:// </div><div class="line">  “我查查”是 wcc:// </div><div class="line">  “1号店”是 wccbyihaodian:// </div><div class="line">  “有道词典”是 yddictproapp:// </div><div class="line">  “知乎”是 zhihu://</div><div class="line">  “优酷”是  youku://</div></pre></td></tr></table></figure><p>跳转到淘宝</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * urlString = <span class="string">@"taobao://"</span>;</div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:urlString] ];</div></pre></td></tr></table></figure><p>ipad版URL Schemes：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">ZAKER ：【zakeripad://】</div><div class="line">  mdict：【mdict://】</div><div class="line">  京东hd：【openApp.jdiPad://】</div><div class="line">  易迅：【wx6964eb0b10aa369b://】；【icson://】；【wap2app://】；【com51buyiPad://】；【sinaweibosso.2217266362://】；【yixunipad://】；</div><div class="line">  wunderlist：【fb208559595824260://】；【wunderlist://】；</div><div class="line">  1password：【db-0bcm217bz8olcxj://】；</div><div class="line">  支付宝：【alipay://】；</div><div class="line">  亚马逊：【fb115829135094686://】；</div><div class="line">  查找朋友：【grenada://】；【findmyfriends://】；【fmf1://】；</div><div class="line">  查找iphone：【fmip1://】；</div><div class="line">  homestyler：【fb110202249127916://】；</div><div class="line">  百度旅游hd：【sinaweibosso.3772466956://】；</div><div class="line">  百度视频hd：【BaiduVideoiPad://】；【baiduvideoipadapp://】；</div><div class="line">  百度相册hd：【BaiDuCloudAlbumHD://】；</div><div class="line">  百度音乐hd：【tencent100518384://】；【QQ05FDC9F0://】；【wxdeda8b7428c87b0b://】；【sinaweibosso.4257500584://】；【BaiduMusicHD://】；</div><div class="line">  百度浏览器hd：【bdbrowser://】；</div><div class="line">  百度文库hd：【bdwenku://】；</div><div class="line">  百度地图hd：【sinaweibosso.675661989://】；</div><div class="line">  百度云：【tencent100312028://】；</div><div class="line">  一个one：【clover-one://】；</div><div class="line">  launchpro：【launch://】；【launchpro://】；【launchpro-light://】；【launchpro-dial://】；【launchpro-tweet://】；【launchpro-brightness://】；【launchpro-messaging://】；【launchpro-email://】；【launchpro-dropbox://】；【launchpro-clipboard://】；【launchpro-facebook://】；【launchpro-sinaweibo://】；【launch-textexpander://】；【db-23algz5zbfx3ocs://】；【launchipad://】；</div><div class="line">  当当hd：【dangdanghd://】；【ddhd://】；</div><div class="line">  大众点评hd：【dianpinghd://】；</div><div class="line">  多看阅读：【duokan-reader://】；</div><div class="line">  艺龙旅行hd：【elongiPad://】；</div><div class="line">  圈点hd：【skitch://】；</div><div class="line">  食记hd：【wxb9a9141190826bd8://】；</div><div class="line">  印象笔记hd：【enx://】；</div><div class="line">  popAgraph：【popagraphtumblr://】；</div><div class="line">  dropbox：【db-auth://】；【dbapi-1://】；【dbapi-2://】；【dbapi-3://】；【fb210019893730://】；</div><div class="line">  goodreader：【ghttp://】；【ghttps://】；【grhttp://】；【grhttps://】；【giwhttp://】；【giwhttps://】；【gropen://】；【com.goodreader.sendtogr://】；</div><div class="line">  houzz：【fb166981393359376://】；</div><div class="line">  ifttt：【ifttt://】；</div><div class="line">  名片全能王hd：【camcard://】；【fb444471182246461hdfull://】；【CamCardHDOpenAPI://】；</div><div class="line">  万年历：【wx5f3a0d4653cd3485://】；</div><div class="line">  拉手团购hd：【LaShouGroupHDPay://】；</div><div class="line">  美团hd：【i**://】；</div><div class="line">  evermemo：【evermemo://】；</div><div class="line">  网易云课堂：【wangyiyunketang://】；</div><div class="line">  网易公开课：【ntesopen://】；</div><div class="line">  订票助手2：【trainassistfree://】；</div><div class="line">  pcalc lite：【pcalc://】；</div><div class="line">  爱奇艺视频：【QIYIHD-iPad://】；</div><div class="line">  documents：【fb435446596521711://】；</div><div class="line">  三国kill：【sgk://】；</div><div class="line">  知乎日报hd：【wb2812384762://】；【wb801442902://】；【wx81bd672c6e11bad0://】；【QQ05FE6368://】；【tencent100557672://】；【pocketapp89757://】；</div><div class="line">  扇贝新闻：【shanbaynews://】；</div><div class="line">  扇贝单词：【shanbay://】；</div><div class="line">  扇贝单词hd：【shanbaywordshd://】；</div><div class="line">  扇贝炼句：【wx6cf98af31a47ba29://】；</div><div class="line">  百词斩：[wxce5d9e837051d623://】；</div><div class="line">  微盘：【sinaweibosso.2938478327://】；【sinavdisksso.2938478327://】；</div><div class="line">  新浪公开课：【wxa376b1970423b610://】；</div><div class="line">  skype：【skype://】；</div><div class="line">  什么值得买hd：【wxed08b6c4003b1fd5://】；</div><div class="line">  搜狐视频hd：【sohu-SViPad://】；【sohuvideohd://】；【wx91d741cfa16379bc://】；</div><div class="line">  teamviewer:【teamviewer8://】；</div><div class="line">  格志：【griddiary://】；【sumi-interactive://】；【db-d7wn1aiwz2ck3tj://】；</div><div class="line">  淘宝hd：【taobao://】；【itaobao://】；【taobaohd://】；【wx25e5e60c1e9fcd97://】；【sinaweibosso.346252009://】；【zhuzhancaipiao4ipad://】；【laiwangc6e34c6bf://】；</div><div class="line">  天猫：【tmall://】；</div><div class="line">  腾讯视频hd：【tenvideohd://】；【tenvideo2://】；</div><div class="line">  qq通讯录：【tencentappqqpim://】；</div><div class="line">  qq：【mqqflyticket://】；</div><div class="line">  微信：【weixin://】；【fb290293790992170://】；【wechat://】；</div><div class="line">  同步推正版HD：【tbtui://】；【tuihd://】；</div><div class="line">  航旅纵横pro：【sinaweibosso.umetrip://】；【umetrippro://】；</div><div class="line">  mathpad：【myscriptmathpad://】；</div><div class="line">  下厨房：【wxd80665a1fc1bf282://】；</div><div class="line">  无忌论坛：【wb801384327://】；【wxe932dc78276c3c24://】；【wb1315970163://】；</div><div class="line">  雅虎天气！：【yweather://】；</div><div class="line">  一号店：【ipadstore://】；</div><div class="line">  优酷hd：【youkuhd://】；</div><div class="line">  知乎日报：【wx841a6aace4a1dca4://】；</div><div class="line">  知乎：【zhihu://】；</div><div class="line">  diesel facts：【dk.publishonline.dieselfacts.china://】；【dps.9aebe5a79fb04d9abddf77d97c6794dc://】；</div><div class="line">  欧陆词典pro：【eudic://】；</div><div class="line">  拓词：【towordsp://】；</div><div class="line">  瘦身旅程：【sina.5253876156240b2daf015c9d://】；</div><div class="line">  词ci：【wx599b00cd734bd4a9://】；</div></pre></td></tr></table></figure><p>参考：<a href="http://www.jianshu.com/p/20ce7f846f75" target="_blank" rel="external">APP跳转 及iOS10跳转在设置页面</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###从APP跳转至设置页面&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>画虚线</title>
    <link href="http://yoursite.com/2017/07/20/%E7%94%BB%E8%99%9A%E7%BA%BF/"/>
    <id>http://yoursite.com/2017/07/20/画虚线/</id>
    <published>2017-07-20T15:41:42.000Z</published>
    <updated>2017-07-20T15:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="通过UIImage的绘图方法来绘制"><a href="#通过UIImage的绘图方法来绘制" class="headerlink" title="通过UIImage的绘图方法来绘制"></a>通过UIImage的绘图方法来绘制</h3><p>绘制一条水平的虚线</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)drawDashLineWithSize:(<span class="built_in">CGSize</span>)size</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(size);</div><div class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    <span class="comment">//设置线条终点形状</span></div><div class="line">    <span class="built_in">CGContextSetLineCap</span>(context, kCGLineCapRound);</div><div class="line">    <span class="comment">// 设置颜色</span></div><div class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0.408</span> alpha:<span class="number">1.000</span>].CGColor);</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> lengths[] = &#123;<span class="number">10</span>,<span class="number">2</span>&#125;;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     CGContextSetLineDash</div><div class="line">     此函数需要四个参数：</div><div class="line">     context – 这个不用多说</div><div class="line">     phase - 表示在第一个虚线绘制的时候跳过多少个点</div><div class="line">     lengths – lengths的值｛10,2｝表示先绘制10个点，再跳过2个点   如果把lengths值改为｛10, 20, 10｝，则表示先绘制10个点，跳过20个点，绘制10个点，跳过10个点，再绘制20个点，如此反复</div><div class="line">     count – lengths数组的长度</div><div class="line">     */</div><div class="line">    <span class="built_in">CGContextSetLineDash</span>(context, <span class="number">0</span>, lengths, <span class="number">2</span>); <span class="comment">//画虚线</span></div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">0.0</span>, <span class="number">2.0</span>); <span class="comment">//开始画线</span></div><div class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, size.width, <span class="number">2.0</span>);</div><div class="line">    <span class="built_in">CGContextStrokePath</span>(context);</div><div class="line">    <span class="comment">// UIGraphicsGetImageFromCurrentImageContext()返回的就是image</span></div><div class="line">    <span class="built_in">UIImage</span> * image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    </div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;通过UIImage的绘图方法来绘制&quot;&gt;&lt;a href=&quot;#通过UIImage的绘图方法来绘制&quot; class=&quot;headerlink&quot; title=&quot;通过UIImage的绘图方法来绘制&quot;&gt;&lt;/a&gt;通过UIImage的绘图方法来绘制&lt;/h3&gt;&lt;p&gt;绘制一条水平的虚线&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>距离传感器、加速计和蓝牙</title>
    <link href="http://yoursite.com/2017/07/12/%E8%B7%9D%E7%A6%BB%E4%BC%A0%E6%84%9F%E5%99%A8%E3%80%81%E5%8A%A0%E9%80%9F%E8%AE%A1%E5%92%8C%E8%93%9D%E7%89%99/"/>
    <id>http://yoursite.com/2017/07/12/距离传感器、加速计和蓝牙/</id>
    <published>2017-07-12T12:00:31.000Z</published>
    <updated>2017-08-12T10:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、距离传感器"><a href="#1、距离传感器" class="headerlink" title="1、距离传感器"></a>1、距离传感器</h4><p><img src="http://oui2ar2u7.bkt.clouddn.com/0cf2403fe38ed88b.png" alt="">  </p><pre><code class="objectivec"> <span class="comment">// 1.开启距离传感器(注意: 默认情况距离传感器是关闭的)</span><span class="comment">//    [UIApplication sharedApplication].proximitySensingEnabled = YES;</span>    <span class="comment">// 只要开启之后, 就开始实时监听</span>    [<span class="built_in">UIDevice</span> currentDevice].proximityMonitoringEnabled = <span class="literal">YES</span>;    <span class="comment">// 2.当监听到有物体靠近设备时系统会发出通知</span>    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(proximityStateDidChange:) name:<span class="built_in">UIDeviceProximityStateDidChangeNotification</span> object:<span class="literal">nil</span>];<span class="comment">// 当监听到有物体靠近设备时调用 </span>- (<span class="keyword">void</span>)proximityStateDidChange:(<span class="built_in">NSNotification</span> *)note{<span class="comment">//    NSLog(@"%@", note);</span>   <span class="keyword">if</span>( [<span class="built_in">UIDevice</span> currentDevice].proximityState)   {       <span class="built_in">NSLog</span>(<span class="string">@"有物体靠近"</span>);   }<span class="keyword">else</span>   {       <span class="built_in">NSLog</span>(<span class="string">@"物体离开"</span>);   }}</code></pre><h4 id="2、加速计-CoreMotion"><a href="#2、加速计-CoreMotion" class="headerlink" title="2、加速计 CoreMotion"></a>2、加速计 CoreMotion</h4><h5 id="加速计的经典应用场景"><a href="#加速计的经典应用场景" class="headerlink" title="加速计的经典应用场景"></a>加速计的经典应用场景</h5><ul><li>摇一摇  </li><li>计步器</li></ul><p><strong>方法1 push （一直在采集）</strong></p><pre><code class="objectivec">- (<span class="keyword">void</span>)push{    <span class="comment">// 1.创建coreMotion管理者</span>    <span class="comment">//    CMMotionManager *mgr = [[CMMotionManager alloc] init];</span>    <span class="keyword">self</span>.mgr = [[<span class="built_in">CMMotionManager</span> alloc] init];    <span class="comment">// 2.判断加速计是否可用</span>    <span class="keyword">if</span> (<span class="keyword">self</span>.mgr.isAccelerometerAvailable) {        <span class="comment">/*         isAccelerometerActive 是否正在采集         accelerometerData 采集到得数据         startAccelerometerUpdates  pull         startAccelerometerUpdatesToQueue  push         stopAccelerometerUpdates 停止采集         accelerometerUpdateInterval 采样时间         */</span>        <span class="comment">// 3.设置采样时间</span>        <span class="keyword">self</span>.mgr.accelerometerUpdateInterval = <span class="number">1</span> / <span class="number">30.0</span>;        <span class="comment">// 4.开始采样</span>        [<span class="keyword">self</span>.mgr startAccelerometerUpdatesToQueue:[<span class="built_in">NSOperationQueue</span> mainQueue] withHandler:^(<span class="built_in">CMAccelerometerData</span> *accelerometerData, <span class="built_in">NSError</span> *error) {            <span class="comment">// 这个block是采集到数据时就会调用</span>            <span class="keyword">if</span> (error) <span class="keyword">return</span> ;            <span class="built_in">CMAcceleration</span> acceleration = accelerometerData.acceleration;            <span class="built_in">NSLog</span>(<span class="string">@"x = %f y = %f z = %f"</span>, acceleration.x, acceleration.y , acceleration.z);        }];    }<span class="keyword">else</span>    {        <span class="built_in">NSLog</span>(<span class="string">@"加速计不可用"</span>);    }}</code></pre><p><strong>方法2 pull （需要时才采集）</strong></p><pre><code class="objectivec"><span class="comment">// 1.创建coreMotion管理者</span>    <span class="keyword">self</span>.mgr = [[<span class="built_in">CMMotionManager</span> alloc] init];     <span class="keyword">if</span> (<span class="keyword">self</span>.mgr.isAccelerometerAvailable) {          <span class="comment">// 3.开始采样</span>         [<span class="keyword">self</span>.mgr startAccelerometerUpdates]; <span class="comment">// pull</span>     }<span class="keyword">else</span>     {         <span class="built_in">NSLog</span>(<span class="string">@"加速计不可用"</span>);     }- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event{    <span class="built_in">CMAcceleration</span> acceleration = <span class="keyword">self</span>.mgr.accelerometerData.acceleration;     <span class="built_in">NSLog</span>(<span class="string">@"x = %f y = %f z = %f"</span>, acceleration.x, acceleration.y , acceleration.z);}</code></pre><h4 id="3、蓝牙"><a href="#3、蓝牙" class="headerlink" title="3、蓝牙"></a>3、蓝牙</h4><h5 id="iOS中提供了4个框架用于实现蓝牙连接"><a href="#iOS中提供了4个框架用于实现蓝牙连接" class="headerlink" title="iOS中提供了4个框架用于实现蓝牙连接"></a>iOS中提供了4个框架用于实现蓝牙连接</h5><p><strong>1、GameKit.framework（用法简单）</strong>  </p><ul><li>只能用于iOS设备之间的连接，多用于游戏（比如五子棋对战），从iOS7开始过期(仅限于沙盒)  </li><li>只能用于iOS设备之间的连接  </li><li>只能用于同一个应用程序之间的连接  </li><li>最好别利用蓝牙发送比较大的数据  </li></ul><pre><code class="objectivec">- (<span class="keyword">IBAction</span>)connect {    <span class="comment">// 1.创建选择其他蓝牙设备的控制器</span>    GKPeerPickerController *peerPk = [[GKPeerPickerController alloc] init];    <span class="comment">// 2.成为该控制器的代理</span>    peerPk.delegate = <span class="keyword">self</span>;    <span class="comment">// 3.显示蓝牙控制器</span>    [peerPk show];}<span class="meta">#pragma mark - GKPeerPickerControllerDelegate</span><span class="comment">// 4.实现dialing方法</span><span class="comment">/** *  当蓝牙设备连接成功就会调用 * *  @param picker  触发时间的控制器 *  @param peerID  连接蓝牙设备的ID *  @param session 连接蓝牙的会话(可用通讯), 以后只要拿到session就可以传输数据 */</span>- (<span class="keyword">void</span>)peerPickerController:(GKPeerPickerController *)picker didConnectPeer:(<span class="built_in">NSString</span> *)peerID toSession:(GKSession *)session{    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, peerID);    <span class="comment">// 1.保存会话</span>    <span class="keyword">self</span>.session = session;    <span class="comment">// 2.设置监听接收传递过来的数据</span>    <span class="comment">/*     Handler: 谁来处理接收到得数据     withContext: 传递数据     */</span>    [<span class="keyword">self</span>.session setDataReceiveHandler:<span class="keyword">self</span> withContext:<span class="literal">nil</span>];    <span class="comment">// 2.关闭显示蓝牙设备控制器</span>    [picker dismiss];}<span class="comment">/** *  接收到其它设备传递过来的数据就会调用 * *  @param data    传递过来的数据 *  @param peer    传递数据设备的ID *  @param session 会话 *  @param context 注册监听时传递的数据 */</span>- (<span class="keyword">void</span>) receiveData:(<span class="built_in">NSData</span> *)data fromPeer:(<span class="built_in">NSString</span> *)peer inSession: (GKSession *)session context:(<span class="keyword">void</span> *)context{<span class="comment">//    NSLog(@"%s", __func__);</span>    <span class="comment">// 1.将传递过来的数据转换为图片(注意: 因为发送的时图片, 所以才需要转换为图片)</span>    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];    <span class="keyword">self</span>.customIV.image = image;}- (<span class="keyword">void</span>)peerPickerControllerDidCancel:(GKPeerPickerController *)picker{} <span class="meta">#pragma mark —- 发送数据</span>- (<span class="keyword">IBAction</span>)send {    <span class="comment">// 利用session发送图片数据即可</span>    <span class="comment">// 1.取出customImageView上得图片, 转换为二进制</span>    <span class="built_in">UIImage</span> *image =  <span class="keyword">self</span>.customIV.image;    <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);    <span class="comment">/*     GKSendDataReliable, 数据安全的发送模式, 慢     GKSendDataUnreliable, 数据不安全的发送模式, 快     */</span>    <span class="comment">/*     data: 需要发送的数据     DataReliable: 是否安全的发送数据(发送数据的模式)     error: 是否监听发送错误     */</span>    [<span class="keyword">self</span>.session sendDataToAllPeers:data withDataMode:GKSendDataReliable error:<span class="literal">nil</span>];}</code></pre><p><strong>2、MultipeerConnectivity.framework</strong><br>只能用于iOS设备之间的连接，从iOS7开始引入，主要用于文件共享（仅限于沙盒的文件）用法跟GameKit类似  </p><p><strong>3、ExternalAccessory.framework</strong><br>可用于第三方蓝牙设备交互，但是蓝牙设备必须经过苹果MFi认证（国内较少）  </p><p><strong>4、CoreBluetooth.framework（时下热门）</strong>            </p><ul><li>可用于第三方蓝牙设备交互，必须要支持蓝牙4.0  </li><li>硬件至少是4s，系统至少是iOS6  </li><li>蓝牙4.0以低功耗著称，一般也叫BLE（Bluetooth Low Energy）  </li><li>目前应用比较多的案例：运动手坏、嵌入式设备、智能家居  </li></ul><p>每个蓝牙4.0设备都是通过服务（Service）和特征（Characteristic）来展示自己的<br>一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征<br>特征是与外界交互的最小单位<br>比如说，一台蓝牙4.0设备，用特征A来描述自己的出厂信息，用特征B来收发数据<br>服务和特征都是用UUID来唯一标识的，通过UUID就能区别不同的服务和特征<br>设备里面各个服务(service)和特征(characteristic)的功能，均由蓝牙设备硬件厂商提供，比如哪些是用来交互(读写)，哪些可获取模块信息(只读)等 </p><p><strong>Core Bluetooth的开发步骤：</strong>  </p><ol><li>建立中心设备  </li><li>扫描外设（Discover Peripheral）  </li><li>连接外设(Connect Peripheral)  </li><li>扫描外设中的服务和特征(Discover Services And Characteristics)  </li><li>利用特征与外设做数据交互(Explore And Interact)<br>断开连接(Disconnect)</li></ol><pre><code class="objectivec"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span><span class="meta">#import <span class="meta-string">&lt;CoreBluetooth/CoreBluetooth.h&gt;</span></span><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">CBCentralManagerDelegate</span>, <span class="title">CBPeripheralDelegate</span>&gt;</span><span class="comment">/** *  外设 */</span><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *peripherals;<span class="comment">/** *  中心管理者 */</span><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) CBCentralManager *mgr;<span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>- (<span class="built_in">NSMutableArray</span> *)peripherals{    <span class="keyword">if</span> (!_peripherals) {        _peripherals = [<span class="built_in">NSMutableArray</span> array];    }    <span class="keyword">return</span> _peripherals;}- (<span class="keyword">void</span>)viewDidLoad {    [<span class="keyword">super</span> viewDidLoad];    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span>    <span class="comment">// 1.创建中心设备</span>    CBCentralManager *mgr = [[CBCentralManager alloc] init];    <span class="keyword">self</span>.mgr = mgr;    <span class="comment">// 设置代理</span>    mgr.delegate = <span class="keyword">self</span>;    <span class="comment">// 2.利用中心设备扫描外部设备</span>    <span class="comment">/*     如果指定数组代表只扫描指定的设备     */</span>    [mgr scanForPeripheralsWithServices:<span class="literal">nil</span> options:<span class="literal">nil</span>];}<span class="meta">#pragma mark - CBCentralManagerDelegate</span>- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(<span class="built_in">NSDictionary</span> *)advertisementData RSSI:(<span class="built_in">NSNumber</span> *)RSSI{    <span class="comment">// 保存扫描到得外部设备</span>    <span class="comment">// 判断如果数组中不包含当前扫描到得外部设置才保存</span>    <span class="keyword">if</span> (![<span class="keyword">self</span>.peripherals containsObject:peripheral]) {        peripheral.delegate = <span class="keyword">self</span>;        [<span class="keyword">self</span>.peripherals addObject:peripheral];    }}<span class="comment">/** *  模拟点击, 然后连接所有的外设 */</span>- (<span class="keyword">void</span>)start{    <span class="keyword">for</span> (CBPeripheral *peripheral <span class="keyword">in</span> <span class="keyword">self</span>.peripherals) {        <span class="comment">/**         *  连接外设         */</span>        [<span class="keyword">self</span>.mgr connectPeripheral:peripheral options:<span class="literal">nil</span>];    }}<span class="comment">/** *  连接外设成功调用 */</span>- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{    <span class="comment">// 扫描外设中得服务</span>    [peripheral discoverServices:<span class="literal">nil</span>];}<span class="comment">/** *  连接外设失败调用 */</span>- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(<span class="built_in">NSError</span> *)error{}<span class="meta">#pragma makr - CBPeripheralDelegate</span><span class="comment">/** *  只要扫描到服务就会调用 * *  @param peripheral 服务所在的外设 */</span>- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(<span class="built_in">NSError</span> *)error{    <span class="comment">// 获取外设中所有扫描到得服务</span>    <span class="built_in">NSArray</span> *services = peripheral.services;    <span class="keyword">for</span> (CBService *service <span class="keyword">in</span> services) {        <span class="comment">// 拿到需要的服务</span>        <span class="keyword">if</span> ([service.UUID.UUIDString isEqualToString:<span class="string">@"123"</span>])        {            <span class="comment">// 从需要的服务中查找需要的特征</span>            <span class="comment">// 从peripheral中得service中扫描特征</span>            [peripheral discoverCharacteristics:<span class="literal">nil</span> forService:service];        }    }}<span class="comment">/** *  只要扫描到特征就会调用 * *  @param peripheral 特征所属的外设 *  @param service    特征所属的服务 */</span>- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(<span class="built_in">NSError</span> *)error{    <span class="comment">// 拿到服务中所有的特征</span>    <span class="built_in">NSArray</span> *characteristics =  service.characteristics;    <span class="comment">// 遍历特征, 拿到需要的特征处理</span>    <span class="keyword">for</span> (CBCharacteristic * characteristic <span class="keyword">in</span> characteristics) {        <span class="keyword">if</span> ([characteristic.UUID.UUIDString isEqualToString:<span class="string">@"8888"</span>]) {            <span class="built_in">NSLog</span>(<span class="string">@"设置闹钟"</span>);        }    }}</code></pre><h4 id="4、陀螺仪与方向感应器"><a href="#4、陀螺仪与方向感应器" class="headerlink" title="4、陀螺仪与方向感应器"></a>4、陀螺仪与方向感应器</h4><p><img src="http://oui2ar2u7.bkt.clouddn.com/6835496cd35f29c6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、距离传感器&quot;&gt;&lt;a href=&quot;#1、距离传感器&quot; class=&quot;headerlink&quot; title=&quot;1、距离传感器&quot;&gt;&lt;/a&gt;1、距离传感器&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://oui2ar2u7.bkt.clouddn.com/0cf2403
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2017/07/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/07/12/正则表达式/</id>
    <published>2017-07-12T11:52:19.000Z</published>
    <updated>2017-07-12T11:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、匹配数字"><a href="#1、匹配数字" class="headerlink" title="1、匹配数字"></a>1、匹配数字</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 1.不能以0开头</div><div class="line">    // 2.全部是数字</div><div class="line">    // 3.5-11位</div><div class="line">    return [self match:@"^[1-9]\\d&#123;4,10&#125;$”];</div><div class="line">   // 1.创建正则表达式</div><div class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</div><div class="line">    // 2.测试字符串</div><div class="line">    NSArray *results = [regex matchesInString:self options:0 range:NSMakeRange(0, self.length)];</div></pre></td></tr></table></figure><h4 id="2、-匹配多个条件，相当于or-或"><a href="#2、-匹配多个条件，相当于or-或" class="headerlink" title="2、| 匹配多个条件，相当于or\或"></a>2、| 匹配多个条件，相当于or\或</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 表情的规则</span></div><div class="line">    <span class="built_in">NSString</span> *emotionPattern = <span class="string">@"\\[[0-9a-zA-Z\\u4e00-\\u9fa5]+\\]"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// @的规则</span></div><div class="line">    <span class="built_in">NSString</span> *atPattern = <span class="string">@"@[0-9a-zA-Z\\u4e00-\\u9fa5]+"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// #话题#的规则</span></div><div class="line">    <span class="built_in">NSString</span> *topicPattern = <span class="string">@"#[0-9a-zA-Z\\u4e00-\\u9fa5]+#"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// url链接的规则</span></div><div class="line">    <span class="built_in">NSString</span> *urlPattern = <span class="string">@"\\b(([\\w-]+://?|www[.])[^\\s()&lt;&gt;]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|/)))"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// | 匹配多个条件,相当于or\或</span></div><div class="line">    <span class="built_in">NSString</span> *pattern = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@|%@|%@|%@"</span>, emotionPattern, atPattern, topicPattern, urlPattern];</div><div class="line">    </div><div class="line">    <span class="built_in">NSRegularExpression</span> *regex = [[<span class="built_in">NSRegularExpression</span> alloc] initWithPattern:pattern options:<span class="number">0</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">// 2.测试字符串</span></div><div class="line">    <span class="built_in">NSArray</span> *results = [regex matchesInString:str options:<span class="number">0</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];</div><div class="line">    </div><div class="line">    <span class="comment">// 3.遍历结果</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *result <span class="keyword">in</span> results) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, <span class="built_in">NSStringFromRange</span>(result.range), [str substringWithRange:result.range]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、匹配数字&quot;&gt;&lt;a href=&quot;#1、匹配数字&quot; class=&quot;headerlink&quot; title=&quot;1、匹配数字&quot;&gt;&lt;/a&gt;1、匹配数字&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>添加3DTouch</title>
    <link href="http://yoursite.com/2017/07/12/%E6%B7%BB%E5%8A%A03DTouch/"/>
    <id>http://yoursite.com/2017/07/12/添加3DTouch/</id>
    <published>2017-07-12T11:34:44.000Z</published>
    <updated>2017-08-12T10:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h3><h4 id="1、纯代码添加"><a href="#1、纯代码添加" class="headerlink" title="1、纯代码添加"></a>1、纯代码添加</h4><pre><code class="objectivec">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions {    <span class="comment">// Override point for customization after application launch.</span>    <span class="keyword">self</span>.window.rootViewController = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:[ViewController new]];    <span class="built_in">UIApplicationShortcutIcon</span> * icon1 = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithTemplateImageName:<span class="string">@"photo_rocket"</span>];    <span class="comment">/**     type 该item唯一表示符     localizedTitle 标题     localizedSubTitle 副标题     icon 图标，可以用系统类型，也可以自定义使用图片     userInfo:用户信息字典，自定义参数，完成具体功能需求     */</span>    <span class="built_in">UIApplicationShortcutItem</span> * item1 = [[<span class="built_in">UIApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"com.3DTouchDemo.item1"</span> localizedTitle:<span class="string">@"windowPhone"</span> localizedSubtitle:<span class="string">@"weiruan"</span> icon:icon1 userInfo:<span class="literal">nil</span>];    <span class="built_in">UIApplicationShortcutIcon</span> * icon2 = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithType:<span class="built_in">UIApplicationShortcutIconTypeBookmark</span>];    <span class="built_in">UIApplicationShortcutItem</span> * item2 = [[<span class="built_in">UIApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"com.3DTouchDemo.Item2"</span> localizedTitle:<span class="string">@"iOS"</span> localizedSubtitle:<span class="string">@"Apple"</span> icon:icon2 userInfo:<span class="literal">nil</span>];    <span class="built_in">UIApplicationShortcutIcon</span> * icon3 = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithType:<span class="built_in">UIApplicationShortcutIconTypeMessage</span>];    <span class="built_in">UIApplicationShortcutItem</span> * item3 = [[<span class="built_in">UIApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"com.3DTouchDemo.Item3"</span> localizedTitle:<span class="string">@"android"</span> localizedSubtitle:<span class="string">@"google"</span> icon:icon3 userInfo:<span class="literal">nil</span>];    <span class="comment">//将Items添加到app图标</span>    application.shortcutItems = @[item2,item3,item1];    <span class="keyword">return</span> <span class="literal">YES</span>;}<span class="meta">#pragma mark - 3D touch 代理方法</span>-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completionHandler{    <span class="keyword">if</span> ([shortcutItem.type isEqualToString:<span class="string">@"com.3DTouchDemo.Item2"</span>])    {    }}</code></pre><h4 id="2、在info-plist上面添加"><a href="#2、在info-plist上面添加" class="headerlink" title="2、在info.plist上面添加"></a>2、在info.plist上面添加</h4><p><img src="http://oui2ar2u7.bkt.clouddn.com/4859e5c9fefd7dfa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;两种方式&quot;&gt;&lt;a href=&quot;#两种方式&quot; class=&quot;headerlink&quot; title=&quot;两种方式&quot;&gt;&lt;/a&gt;两种方式&lt;/h3&gt;&lt;h4 id=&quot;1、纯代码添加&quot;&gt;&lt;a href=&quot;#1、纯代码添加&quot; class=&quot;headerlink&quot; title=&quot;1、纯
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS runtime详解</title>
    <link href="http://yoursite.com/2017/07/03/iOS-runtime%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/07/03/iOS-runtime详解/</id>
    <published>2017-07-03T14:58:22.000Z</published>
    <updated>2017-08-12T10:13:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>runtime是运行时，对于从事iOS开发，想要深入学习OC的人，runtime是必须熟悉掌握的东西。</p><h3 id="runtime的概念"><a href="#runtime的概念" class="headerlink" title="runtime的概念"></a>runtime的概念</h3><p><strong>Objective-C</strong> 是基于 <strong>C</strong> 的，它为 C 添加了<em>面向对象</em>的特性。它将很多静态语言在编译和链接时期做的事放到了<strong>runtime</strong> 运行时来处理，可以说<em>runtime</em>是我们<em>Objective-C</em>幕后工作者。</p><ul><li><strong>runtime</strong>（简称<em>运行时</em>），是一套 <strong>纯C(C和汇编写的)</strong> 的API。而<strong>OC就是运行时机制</strong>，也就是在运行时候的一些机制，其中最主要的是<strong>消息机制</strong>。</li><li>对于 C 语言，<strong>函数的调用在编译的时候会决定调用哪个函数。</strong>  </li><li>OC的函数调用成为消息发送，属于<strong>动态调用过程</strong>。在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。  </li><li>在编译阶段，OC可以<strong>调用任何函数</strong>，即使这个函数并未实现，只要声明过就不会报错，只有当运行的时候才会报错，这是因为OC是运行时动态调用的。而C语言<strong>调用未实现的函数</strong>就会报错。  </li></ul><h3 id="runtime的消息机制"><a href="#runtime的消息机制" class="headerlink" title="runtime的消息机制"></a>runtime的消息机制</h3><ul><li>我们写的<strong>OC代码</strong>在<em>运行</em>的时候也是转换成了<strong>runtime</strong>方式运行的。<strong>任何方法调用本质：就是发送一个消息</strong>（用runtime发送消息，OC底层实现通过<strong>runtime</strong>实现）。</li><li><strong>消息机制原理</strong>：对象根据方法编号SEL去映射表查找对应的方法实现。</li><li>每一个OC的方法，底层必然有一个与之对应的runtime方法。</li></ul><p><strong>简单示例：</strong><br>验证：方法调用，是否真的是转换为消息机制？<br>必须要导入头文件 <code>#import&lt;objc/message.h&gt;</code><br>注解1：我们导入系统的头文件，一般用尖括号。<br>注解2：OC 解决消息机制方法提示步骤【查找build setting -&gt; 搜索msg -&gt; objc_msgSend（YES –&gt; NO）】<br>注解3：最终生成消息机制,编译器做的事情，最终代码，需要把当前代码重新编译，用xcode编译器，【clang -rewrite-objc main.m 查看最终生成代码】，示例：cd main.m –&gt; 输入前面指令，就会生成 .opp文件(C++代码)<br>注解4：这里一般不会直接导入<objc runtime.h=""><br><strong><em>示例代码：OC 方法–&gt;runtime 方法</em></strong></objc></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">说明: eat(无参) 和 run(有参) 是 Person模型类中的私有方法「可以帮我调用私有方法」；</div><div class="line"></div><div class="line"><span class="comment">// Person *p = [Person alloc];</span></div><div class="line"><span class="comment">// 底层的实际写法</span></div><div class="line">Person *p = objc_msgSend(objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>));</div><div class="line"></div><div class="line"><span class="comment">// p = [p init];</span></div><div class="line">p = objc_msgSend(p, sel_registerName(<span class="string">"init"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 调用对象方法（本质：让对象发送消息）</span></div><div class="line"><span class="comment">//[p eat];</span></div><div class="line"></div><div class="line"><span class="comment">// 本质：让类对象发送消息</span></div><div class="line">objc_msgSend(p, <span class="keyword">@selector</span>(eat));</div><div class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(run:),<span class="number">20</span>);</div><div class="line"></div><div class="line"><span class="comment">//--------------------------- &lt;#我是分割线#&gt; ------------------------------//</span></div><div class="line"><span class="comment">// 也许下面这种好理解一点</span></div><div class="line"></div><div class="line"><span class="comment">// id objc = [NSObject alloc];</span></div><div class="line"><span class="keyword">id</span> objc = objc_msgSend([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(alloc));</div><div class="line"></div><div class="line"><span class="comment">// objc = [objc init];</span></div><div class="line">objc = objc_msgSend(objc, <span class="keyword">@selector</span>(init));</div></pre></td></tr></table></figure><h3 id="runtime-方法调用流程「消息机制」"><a href="#runtime-方法调用流程「消息机制」" class="headerlink" title="runtime 方法调用流程「消息机制」"></a>runtime 方法调用流程「消息机制」</h3><h4 id="消息机制方法调用流程"><a href="#消息机制方法调用流程" class="headerlink" title="消息机制方法调用流程"></a>消息机制方法调用流程</h4><p>怎么去调用类方法和实例方法，<strong>实例方法</strong>：(<em>保存到类对象的方法列表</em>) ，<strong>类方法</strong>：(<em>保存到元类(Meta Class)中方法列表</em>)。<br>1.<strong>OC</strong>在向一个对象发送消息时，runtime库会根据对象的<strong>isa指针</strong>找到该对象对应的<strong>类</strong>或其<strong>父类</strong>中查找方法。<br>2.注册方法编号（这里用方法编号的好处，可以快速查找）。<br>3.根据方法编号去查找对应方法。<br>4.找到只是最终函数实现地址，根据地址去方法区调用对应函数。  </p><h4 id="一个objc-对象的-isa-的指针指向什么？有什么作用？"><a href="#一个objc-对象的-isa-的指针指向什么？有什么作用？" class="headerlink" title="一个objc 对象的 isa 的指针指向什么？有什么作用？"></a>一个objc 对象的 isa 的指针指向什么？有什么作用？</h4><p>每一个对象内部都有<strong>一个isa指针</strong>，这个指针是指向它的真实类型，根据这个指针就能知道将来调用哪个类的方法。</p><h3 id="runtime-常见作用"><a href="#runtime-常见作用" class="headerlink" title="runtime 常见作用"></a>runtime 常见作用</h3><ul><li>动态交换两个方法的实现  </li><li>动态添加属性  </li><li>实现字典转模型的自动转换  </li><li>发送消息  </li><li>动态添加方法  </li><li>拦截并替换方法  </li><li>实现 NSCoding 的自动归档和解档</li></ul><h3 id="runtime-常用开发应用场景「工作掌握」"><a href="#runtime-常用开发应用场景「工作掌握」" class="headerlink" title="runtime 常用开发应用场景「工作掌握」"></a>runtime 常用开发应用场景「工作掌握」</h3><h4 id="runtime-交换方法"><a href="#runtime-交换方法" class="headerlink" title="runtime 交换方法"></a>runtime 交换方法</h4><p>应用场景：当第三方框架 或者 系统原生方法功能不能满足我们的时候，我们可以在保持系统原有方法功能的基础上，添加额外的功能。<br>需求：加载一张图片直接用[UIImage imageNamed:@”image”];是无法知道到底有没有加载成功。给系统的imageNamed添加额外功能（是否加载图片成功）。<br>方案一：继承系统的类，重写方法.（弊端：每次使用都需要导入）<br>方案二：使用 runtime，交换方法.<br>实现步骤：<br>1.给系统的方法添加分类<br>2.自己实现一个带有扩展功能的方法<br>3.交换方法,只需要交换一次  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 方案一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span></div><div class="line">    <span class="comment">// 方案二：交换 imageNamed 和 ln_imageNamed 的实现，就能调用 imageNamed，间接调用 ln_imageNamed 的实现。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span> </span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Image</span>)</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> load方法: 把类加载进内存的时候调用,只会调用一次</div><div class="line"> 方法应先交换，再去调用</div><div class="line"> */</div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1.获取 imageNamed方法地址</span></div><div class="line">    <span class="comment">// class_getClassMethod（获取某个类的方法）</span></div><div class="line">    Method imageNamedMethod = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</div><div class="line">    <span class="comment">// 2.获取 ln_imageNamed方法地址</span></div><div class="line">    Method ln_imageNamedMethod = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(ln_imageNamed:));</div><div class="line"></div><div class="line">    <span class="comment">// 3.交换方法地址，相当于交换实现方式;「method_exchangeImplementations 交换两个方法的实现」</span></div><div class="line">    method_exchangeImplementations(imageNamedMethod, ln_imageNamedMethod);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 看清楚下面是不会有死循环的</div><div class="line"> 调用 imageNamed =&gt; ln_imageNamed</div><div class="line"> 调用 ln_imageNamed =&gt; imageNamed</div><div class="line"> */</div><div class="line"><span class="comment">// 加载图片 且 带判断是否加载成功</span></div><div class="line">+ (<span class="built_in">UIImage</span> *)ln_imageNamed:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> ln_imageNamed:name];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runtime添加额外功能--加载成功"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"runtime添加额外功能--加载失败"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super</div><div class="line"> 所以第二步，我们要 自己实现一个带有扩展功能的方法.</div><div class="line"> + (UIImage *)imageNamed:(NSString *)name &#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 打印输出</span></div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-17</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">14.693</span> runtime[<span class="number">12761</span>:<span class="number">543574</span>] runtime添加额外功能--加载成功</div></pre></td></tr></table></figure><p><strong>总结：</strong>我们交换两个方法地址指向，必须在系统的imageNamed:方法调用前，所以讲代码卸载分类的load方法中，最后当运行的时候系统的方法就会去找我们的方法的实现。</p><h4 id="runtime给分类动态添加属性"><a href="#runtime给分类动态添加属性" class="headerlink" title="runtime给分类动态添加属性"></a>runtime给分类动态添加属性</h4><p><strong>原理：</strong>给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。  </p><p><strong>应用场景：</strong>给系统的类添加属性的时候，可以使用runtime动态添加属性方法。<br>注解：系统 NSObject 添加一个分类，我们知道在分类中是不能够添加成员属性的，虽然我们用了@property，但是仅仅会自动生成get和set方法的声明，并没有带下划线的属性和方法实现生成。但是我们可以通过runtime就可以做到给它方法的实现。  </p><p><strong>需求：</strong>给系统 NSObject 类动态添加属性 name 字符串。  </p><p><strong>案例代码：</strong>方法+调用+打印</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></div><div class="line"></div><div class="line"><span class="comment">// @property分类:只会生成get,set方法声明,不会生成实现,也不会生成下划线成员属性</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *height;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line"></div><div class="line">    <span class="comment">// objc_setAssociatedObject（将某个值跟某个对象关联起来，将某个值存储到某个对象中）</span></div><div class="line">    <span class="comment">// object:给哪个对象添加属性</span></div><div class="line">    <span class="comment">// key:属性名称</span></div><div class="line">    <span class="comment">// value:属性值</span></div><div class="line">    <span class="comment">// policy:保存策略</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">@"name"</span>, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">@"name"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">objc.name = <span class="string">@"123"</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"runtime动态添加属性name==%@"</span>,objc.name);</div><div class="line"></div><div class="line"><span class="comment">// 打印输出</span></div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-17</span> <span class="number">19</span>:<span class="number">37</span>:<span class="number">10.530</span> runtime[<span class="number">12761</span>:<span class="number">543574</span>] runtime动态添加属性--name == <span class="number">123</span></div></pre></td></tr></table></figure><p><strong>总结：</strong>给属性赋值的本质其实就是让属性与一个对象产生关联，所以要个NSObject的分类的name属性赋值就是让name和NSObject产生关联，runtime可以做到这一点。  </p><h4 id="runtime字典转模型"><a href="#runtime字典转模型" class="headerlink" title="runtime字典转模型"></a>runtime字典转模型</h4><p>字典转模型的方式:</p><ul><li><p>一个一个给模型属性赋值  </p></li><li><p>字典转模型KVC实现<br>1、KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应<br>2、如果不一致，就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code> 报<code>key</code>找不到的错。<br>3、分析：模型中的属性和字典中的<code>key</code>不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。<br>4、解决：重写对象的<code>setValue:forUndefinedKey:</code>，把系统的方法覆盖，就能继续使用KVC字典转模型。</p></li><li><p>字典转模型Runtime实现<br>思路：利用运行时，遍历模型中的所有属性，根据模型中的属性名，去字典中查找<code>key</code>，取出对应的值，给模型的属性赋值（注：字典中的取值，不一定会全部取出来）。   </p><p>考虑情况：<br>1、当字典中的<code>key</code> 和模型的属性匹配不上。<br>2、模型中嵌套模型（模型属性是另一个模型对象)。<br>3、模型的属性是一个数组，数组中是一个个模型对象。  </p><p>注解：字典中的<code>key</code>和模型的属性不对应的情况有两种，一种是字典的键值对大于模型的属性数量，这时候我们不需要任何处理，因为<code>runtime</code>是先遍历模型所有属性，再去字典中根据属性名找对应的值进行赋值，多余的键值对不需要去看；另外一种情况是模型属性数量大于字典中的键值对，这时候由于属性没有对应值会被赋值为<code>nil</code>，就会导致<code>crash</code>,只需加一个判断即可。  </p><p>实现步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类实现字典转模型。  </p><p><strong>MJExtension</strong>字典转模型实现也是通过底层对runtime进行封装，才可以把模型中所有属性遍历出来。  </p></li></ul><h5 id="字典转模型Runtime方式实现"><a href="#字典转模型Runtime方式实现" class="headerlink" title="字典转模型Runtime方式实现"></a>字典转模型Runtime方式实现</h5><p>1、runtime字典转为模型 – 字典中的key和模型的属性不匹配(模型属性数量大于字典键值对)，代码如下:  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Runtime:根据模型中属性,去字典中取出对应的value给模型属性赋值</span></div><div class="line"><span class="comment">// 思路：遍历模型中所有属性-&gt;使用运行时</span></div><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2.利用runtime给对象中的属性赋值</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     class_copyIvarList: 获取类中的所有成员变量</div><div class="line">     Ivar：成员变量</div><div class="line">     第一个参数：表示获取哪个类中的成员变量</div><div class="line">     第二个参数：表示这个类有多少成员变量，传入一个Int变量地址，会自动给这个变量赋值</div><div class="line">     返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</div><div class="line">     count: 成员变量个数</div><div class="line">     */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 获取类中的所有成员变量</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有成员变量</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">// 根据角标，从数组取出对应的成员变量</span></div><div class="line">        Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">        <span class="comment">// 获取成员变量名字</span></div><div class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">        <span class="comment">// 处理成员变量名-&gt;字典中的key(去掉 _ ,从第一个角标开始截取)</span></div><div class="line">        <span class="built_in">NSString</span> *key = [ivarName substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">        <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line">        <span class="comment">// 【如果模型属性数量大于字典键值对数理，模型属性会被赋值为nil】</span></div><div class="line">        <span class="comment">// 而报错 (could not set nil as the value for the key age.)</span></div><div class="line">        <span class="keyword">if</span> (value) &#123;</div><div class="line">            <span class="comment">// 给模型中属性赋值</span></div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">**注**这里在获取模型类中的所有属性名，是采取 `class_copyIvarList` 先获取成员变量（以下划线开头） ，然后再处理成员变量名-&gt;字典中的key(`去掉 _ ,从第一个角标开始截取`) 得到属性名。  </div><div class="line">原因：  </div><div class="line">`Ivar：成员变量,以下划线开头`，`Property 属性 `   </div><div class="line">获取类里面属性 `class_copyPropertyList`  </div><div class="line">获取类中的所有成员变量 `class_copyIvarList`</div><div class="line"></div><div class="line">```objectivec</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> _a; <span class="comment">// 成员变量</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> attitudes_count; <span class="comment">// 属性</span></div><div class="line"></div><div class="line">这里有成员变量，就不会漏掉属性；如果有属性，可能会漏掉成员变量；</div></pre></td></tr></table></figure><p>使用<code>runtime</code>字典转模型获取模型属性名的时候，最好获取成员属性名<code>Ivar</code>因为可能会有个属性是没有<code>setter</code>和<code>getter</code>方法的。  </p><p>2、runtime字典转模型–模型中嵌套模型(模型属性是另外一个模型对象)，代码如下：  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict2:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2.利用runtime给对象中的属性赋值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 获取类中的所有成员变量</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有成员变量</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">// 根据角标，从数组取出对应的成员变量</span></div><div class="line">        Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">        <span class="comment">// 获取成员变量名字</span></div><div class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">        <span class="comment">// 获取成员变量类型</span></div><div class="line">        <span class="built_in">NSString</span> *ivarType = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line"></div><div class="line">        <span class="comment">// 替换: @\"User\" -&gt; User</span></div><div class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:<span class="string">@"\""</span> withString:<span class="string">@""</span>];</div><div class="line">        ivarType = [ivarType stringByReplacingOccurrencesOfString:<span class="string">@"@"</span> withString:<span class="string">@""</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 处理成员属性名-&gt;字典中的key(去掉 _ ,从第一个角标开始截取)</span></div><div class="line">        <span class="built_in">NSString</span> *key = [ivarName substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">        <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line">        <span class="comment">//--------------------------- &lt;#我是分割线#&gt; ------------------------------//</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class="line">        <span class="comment">// 判断下value是否是字典,并且是自定义对象才需要转换</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp; ![ivarType hasPrefix:<span class="string">@"NS"</span>]) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 字典转换成模型 userDict =&gt; User模型, 转换成哪个模型</span></div><div class="line">            <span class="comment">// 根据字符串类名生成类对象</span></div><div class="line">            Class modelClass = <span class="built_in">NSClassFromString</span>(ivarType);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (modelClass) &#123; <span class="comment">// 有对应的模型才需要转</span></div><div class="line">                <span class="comment">// 把字典转模型</span></div><div class="line">                value = [modelClass modelWithDict2:value];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 给模型中属性赋值</span></div><div class="line">        <span class="keyword">if</span> (value) &#123;</div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line"><span class="number">3</span>、runtime字典转模型--数组中装着模型(模型的属性是一个数组，数组中是字典模型对象)，代码如下：  </div><div class="line"></div><div class="line">```objectivec</div><div class="line"><span class="comment">// Runtime:根据模型中属性,去字典中取出对应的value给模型属性赋值</span></div><div class="line"><span class="comment">// 思路：遍历模型中所有属性-&gt;使用运行时</span></div><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict3:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2.利用runtime给对象中的属性赋值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 获取类中的所有成员变量</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有成员变量</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">// 根据角标，从数组取出对应的成员变量</span></div><div class="line">        Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">        <span class="comment">// 获取成员变量名字</span></div><div class="line">        <span class="built_in">NSString</span> *ivarName = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">        <span class="comment">// 处理成员属性名-&gt;字典中的key(去掉 _ ,从第一个角标开始截取)</span></div><div class="line">        <span class="built_in">NSString</span> *key = [ivarName substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">        <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//--------------------------- &lt;#我是分割线#&gt; ------------------------------//</span></div><div class="line">        <span class="comment">//</span></div><div class="line"></div><div class="line">        <span class="comment">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class="line">        <span class="comment">// 判断值是否是数组</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="comment">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class="line">            <span class="comment">// arrayContainModelClass 提供一个协议，只要遵守这个协议的类，都能把数组中的字典转模型</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 转换成id类型，就能调用任何对象的方法</span></div><div class="line">                <span class="keyword">id</span> idSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 获取数组中字典对应的模型</span></div><div class="line">                <span class="built_in">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">                <span class="comment">// 生成模型</span></div><div class="line">                Class classModel = <span class="built_in">NSClassFromString</span>(type);</div><div class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">                <span class="comment">// 遍历字典数组，生成模型数组</span></div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> value) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="keyword">id</span> model =  [classModel modelWithDict3:dict];</div><div class="line">                    [arrM addObject:model];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 把模型数组赋值给value</span></div><div class="line">                value = arrM;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果模型属性数量大于字典键值对数理，模型属性会被赋值为nil,而报错</span></div><div class="line">        <span class="keyword">if</span> (value) &#123;</div><div class="line">            <span class="comment">// 给模型中属性赋值</span></div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">**总结：**我们既然能获取到属性类型，那就可以拦截到模型的那个数组属性，进而对数组中每个模型遍历并字典转模型，但是我们不知道数组中的模型都是什么类型，我们可以声明一个方法，该方法目的不是让其调用，而是让其实现并返回模型的类型。  </div><div class="line"></div><div class="line"><span class="meta">#### runtime添加方法  </span></div><div class="line">**应用场景:**如果一个类的方法非常多，加载类到内存的时候比较耗资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。  </div><div class="line"></div><div class="line">**注解：**OC中使用的懒加载，当用到的时候才去加载它，实际上只要一个类实现了某个方法，就会被加载到内存。当我们不想加载那么多方法的时候，就可以使用runtime动态的添加方法。</div><div class="line"></div><div class="line">**需求：**runtime动态添加方法处理调用一个未实现的方法和去除报错。  </div><div class="line"></div><div class="line">**案例代码：**方法+调用+打印输出</div><div class="line"></div><div class="line">```objectivec</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];   </div><div class="line">    Person *p = [[Person alloc] init];</div><div class="line">    <span class="comment">// 默认person，没有实现run:方法，可以通过performSelector调用，但是会报错。</span></div><div class="line">    <span class="comment">// 动态添加方法就不会报错</span></div><div class="line">    [p performSelector:<span class="keyword">@selector</span>(run:) withObject:@<span class="number">10</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"><span class="comment">// 没有返回值,1个参数</span></div><div class="line"><span class="comment">// void,(id,SEL)</span></div><div class="line"><span class="keyword">void</span> aaa(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSNumber</span> *meter) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"跑了%@米"</span>, meter);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 任何方法默认都有两个隐式参数,self,_cmd（当前方法的方法编号）</span></div><div class="line"><span class="comment">// 什么时候调用:只要一个对象调用了一个未实现的方法就会调用这个方法,进行处理</span></div><div class="line"><span class="comment">// 作用:动态添加方法,处理未实现</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    <span class="comment">// [NSStringFromSelector(sel) isEqualToString:@"run"];</span></div><div class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"run:"</span>)) &#123;</div><div class="line">        <span class="comment">// 动态添加run方法</span></div><div class="line">        <span class="comment">// class: 给哪个类添加方法</span></div><div class="line">        <span class="comment">// SEL: 添加哪个方法，即添加方法的方法编号</span></div><div class="line">        <span class="comment">// IMP: 方法实现 =&gt; 函数 =&gt; 函数入口 =&gt; 函数名（添加方法的函数实现（函数地址））</span></div><div class="line">        <span class="comment">// type: 方法类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></div><div class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)aaa, <span class="string">"v@:@"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 打印输出</span></div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-17</span> <span class="number">19</span>:<span class="number">05</span>:<span class="number">03.917</span> runtime[<span class="number">12761</span>:<span class="number">543574</span>] runtime动态添加方法--跑了<span class="number">10</span>米</div></pre></td></tr></table></figure><h4 id="动态变量控制"><a href="#动态变量控制" class="headerlink" title="动态变量控制"></a>动态变量控制</h4><p>现在有一个Person的类，创建xiaoming对象  </p><ul><li><p>动态获取xiaoming类中的所有属性(包括私有的)<br><code>Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count);</code>  </p></li><li><p>遍历属性找到对应的name字段<br><code>const char *varName = ivar_getName(var);</code></p></li><li><p>修改对应的字段值为20<br><code>object_setIvar(self.xiaoMing, var, @&quot;20&quot;);</code></p></li><li><p>代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> -(<span class="keyword">void</span>)answer&#123;</div><div class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   Ivar *ivar = class_copyIvarList([<span class="keyword">self</span>.xiaoMing <span class="keyword">class</span>], &amp;count);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</div><div class="line">       Ivar var = ivar[i];</div><div class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *varName = ivar_getName(var);</div><div class="line">       <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:varName];</div><div class="line">       <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"_age"</span>]) &#123;</div><div class="line">           object_setIvar(<span class="keyword">self</span>.xiaoMing, var, <span class="string">@"20"</span>);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"XiaoMing's age is %@"</span>,<span class="keyword">self</span>.xiaoMing.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p> ####实现NSCoding的自动归档和解档<br> 实现自定义的模型持久化的过程，如果一个模型有许多个属性，需要对每个属性都实现一遍<code>encodeObject</code> 和 <code>decodeObjectForKey</code>方法，当遇到这样的模型有很多个，这是一件十分麻烦的事情，下面介绍简单的实现方法。  </p><p> 假设现在有一个Movie类，有3个属性。先看下 .h文件</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Movie.h文件</span></div><div class="line"><span class="comment">//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Movie</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCoding</span>&gt;  </span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *movieId;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *movieName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *pic_url;</div><div class="line"><span class="keyword">@end</span></div><div class="line"> ```  </div><div class="line"> </div><div class="line"> 如果是正常写法， .m 文件应该是这样的：</div><div class="line"> </div><div class="line"> ```objectivec</div><div class="line"> <span class="comment">// Movie.m文件</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Movie</span></span></div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</div><div class="line">&#123;</div><div class="line">    [aCoder encodeObject:_movieId forKey:<span class="string">@"id"</span>];</div><div class="line">    [aCoder encodeObject:_movieName forKey:<span class="string">@"name"</span>];</div><div class="line">    [aCoder encodeObject:_pic_url forKey:<span class="string">@"url"</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">self</span>.movieId = [aDecoder decodeObjectForKey:<span class="string">@"id"</span>];</div><div class="line">        <span class="keyword">self</span>.movieName = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</div><div class="line">        <span class="keyword">self</span>.pic_url = [aDecoder decodeObjectForKey:<span class="string">@"url"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"> ```  </div><div class="line"> 如果这里有<span class="number">100</span>个属性，难道我们也只能把<span class="number">100</span>个属性都给写一遍吗。  </div><div class="line"> 使用runtime让我们有更简便的方法  </div><div class="line"> </div><div class="line"> ```objectivec</div><div class="line"> <span class="meta">#import <span class="meta-string">"Movie.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Movie</span></span></div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)encoder</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    Ivar *ivars = class_copyIvarList([Movie <span class="keyword">class</span>], &amp;count);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</div><div class="line">        <span class="comment">// 取出i位置对应的成员变量</span></div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        <span class="comment">// 查看成员变量</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</div><div class="line">        <span class="comment">// 归档</span></div><div class="line">        <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</div><div class="line">        <span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];</div><div class="line">        [encoder encodeObject:value forKey:key];</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        Ivar *ivars = class_copyIvarList([Movie <span class="keyword">class</span>], &amp;count);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</div><div class="line">        <span class="comment">// 取出i位置对应的成员变量</span></div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        <span class="comment">// 查看成员变量</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</div><div class="line">       <span class="comment">// 归档</span></div><div class="line">       <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</div><div class="line">      <span class="keyword">id</span> value = [decoder decodeObjectForKey:key];</div><div class="line">       <span class="comment">// 设置到成员变量身上</span></div><div class="line">        [<span class="keyword">self</span> setValue:value forKey:key];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"> ```  </div><div class="line"> 这样的方式实现，不管有多少个属性，写这几行代码就搞定了。如果嫌代码有点多，有更加简便的方法：两句代码搞定。</div><div class="line"> </div><div class="line"> ```objectivec</div><div class="line"> <span class="meta">#import <span class="meta-string">"Movie.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#define encodeRuntime(A) \</span></div><div class="line">\</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;\</div><div class="line">Ivar *ivars = class_copyIvarList([A <span class="keyword">class</span>], &amp;count);\</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;\</div><div class="line">Ivar ivar = ivars[i];\</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);\</div><div class="line"><span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];\</div><div class="line"><span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];\</div><div class="line">[encoder encodeObject:value forKey:key];\</div><div class="line">&#125;\</div><div class="line">free(ivars);\</div><div class="line">\</div><div class="line"><span class="meta">#define initCoderRuntime(A) \</span></div><div class="line">\</div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;\</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;\</div><div class="line">Ivar *ivars = class_copyIvarList([A <span class="keyword">class</span>], &amp;count);\</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;\</div><div class="line">Ivar ivar = ivars[i];\</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);\</div><div class="line"><span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];\</div><div class="line"><span class="keyword">id</span> value = [decoder decodeObjectForKey:key];\</div><div class="line">[<span class="keyword">self</span> setValue:value forKey:key];\</div><div class="line">&#125;\</div><div class="line">free(ivars);\</div><div class="line">&#125;\</div><div class="line"><span class="keyword">return</span> <span class="keyword">self</span>;\</div><div class="line">\</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Movie</span></span></div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)encoder</div><div class="line">&#123;</div><div class="line">    encodeRuntime(Movie)</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder</div><div class="line">&#123;</div><div class="line">    initCoderRuntime(Movie)</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p><strong>优化：</strong>上面是encodeWithCoder 和 initWithCoder这两个方法抽成宏。我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。  </p><h3 id="runtime下Class的各项操作"><a href="#runtime下Class的各项操作" class="headerlink" title="runtime下Class的各项操作"></a>runtime下Class的各项操作</h3><p>下面是 runtime 下Class的常见方法 及 带有使用示例代码。各项操作，<a href="http://www.jianshu.com/p/46dd81402f63" target="_blank" rel="external">【转载原著】http://www.jianshu.com/p/46dd81402f63</a>  </p><p><strong>unsigned int count;</strong></p><ul><li>获取属性列表</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">objc_property_t *propertyList = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</div><div class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(propertyList[i]);</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"property----&gt;%@"</span>, [<span class="built_in">NSString</span> stringWithUTF8String:propertyName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>获取方法列表</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Method *methodList = class_copyMethodList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i; i&lt;count; i++) &#123;</div><div class="line">   Method method = methodList[i];</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"method----&gt;%@"</span>, <span class="built_in">NSStringFromSelector</span>(method_getName(method)));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>获取成员变量列表</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ivar *ivarList = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i; i&lt;count; i++) &#123;</div><div class="line">    Ivar myIvar = ivarList[i];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ivarName = ivar_getName(myIvar);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Ivar----&gt;%@"</span>, [<span class="built_in">NSString</span> stringWithUTF8String:ivarName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>获得协议列表</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">unsafe_unretained</span> Protocol **protocolList = class_copyProtocolList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i; i&lt;count; i++) &#123;</div><div class="line">    Protocol *myProtocal = protocolList[i];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocolName = protocol_getName(myProtocal);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"protocol----&gt;%@"</span>, [<span class="built_in">NSString</span> stringWithUTF8String:protocolName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法</p><ul><li>获得类方法</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class PersonClass = object_getClass([Person <span class="keyword">class</span>]);</div><div class="line">SEL oriSEL = <span class="keyword">@selector</span>(test1);</div><div class="line">Method oriMethod = _class_getMethod(xiaomingClass, oriSEL);</div></pre></td></tr></table></figure><ul><li>获得实例方法</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class PersonClass = object_getClass([xiaoming <span class="keyword">class</span>]);</div><div class="line">SEL oriSEL = <span class="keyword">@selector</span>(test2);</div><div class="line">Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);</div></pre></td></tr></table></figure><ul><li>添加方法</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div></pre></td></tr></table></figure><ul><li>替换原方法实现</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div></pre></td></tr></table></figure><ul><li>交换原方法实现</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method_exchangeImplementations(oriMethod, cusMethod);</div></pre></td></tr></table></figure><p>常用方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 得到类的所有方法</span></div><div class="line">    Method *allMethods = class_copyMethodList([Person <span class="keyword">class</span>], &amp;count);</div><div class="line"><span class="comment">// 得到所有成员变量</span></div><div class="line">    Ivar *allVariables = class_copyIvarList([Person <span class="keyword">class</span>], &amp;count);</div><div class="line"><span class="comment">// 得到所有属性</span></div><div class="line">    objc_property_t *properties = class_copyPropertyList([Person <span class="keyword">class</span>], &amp;count);</div><div class="line"><span class="comment">// 根据名字得到类变量的Ivar指针，但是这个在OC中好像毫无意义</span></div><div class="line">Ivar oneCVIvar = class_getClassVariable([Person <span class="keyword">class</span>], name);</div><div class="line"><span class="comment">// 根据名字得到实例变量的Ivar指针</span></div><div class="line">    Ivar oneIVIvar = class_getInstanceVariable([Person <span class="keyword">class</span>], name);</div><div class="line"><span class="comment">// 找到后可以直接对私有变量赋值</span></div><div class="line">    object_setIvar(_per, oneIVIvar, <span class="string">@"Mike"</span>);<span class="comment">//强制修改name属性</span></div><div class="line"><span class="comment">/* 动态添加方法：</span></div><div class="line">     第一个参数表示Class cls 类型；</div><div class="line">     第二个参数表示待调用的方法名称；</div><div class="line">     第三个参数(IMP)myAddingFunction，IMP是一个函数指针，这里表示指定具体实现方法myAddingFunction；</div><div class="line">     第四个参数表方法的参数，0代表没有参数；</div><div class="line">     */</div><div class="line">    class_addMethod([_per <span class="keyword">class</span>], <span class="keyword">@selector</span>(sayHi), (IMP)myAddingFunction, <span class="number">0</span>);</div><div class="line"><span class="comment">// 交换两个方法</span></div><div class="line">    method_exchangeImplementations(method1, method2);</div><div class="line"></div><div class="line"><span class="comment">// 关联两个对象</span></div><div class="line">objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</div><div class="line"><span class="comment">/*</span></div><div class="line"> id object                     :表示关联者，是一个对象，变量名理所当然也是object</div><div class="line"> const void *key               :获取被关联者的索引key</div><div class="line"> id value                      :被关联者，这里是一个block</div><div class="line"> objc_AssociationPolicy policy : 关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC</div><div class="line">*/</div></pre></td></tr></table></figure><h3 id="runtime-几个参数概念"><a href="#runtime-几个参数概念" class="headerlink" title="runtime 几个参数概念"></a>runtime 几个参数概念</h3><p><strong>1、objc_msgSend</strong><br>这是个最基本的用于发送消息的函数<br>其实编译器会根据情况在<code>objc_msgSend</code>， <code>objc_msgSend_stret</code>,<code>objc_msgSendSuper</code>， 或<code>objc_msgSendSuper_stret</code> 四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>Super</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>stret</code>的函数。  </p><p><strong>2、SEL</strong><br><code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector</code>在<strong>Objc</strong>中的表示类型（<strong>Swift</strong>中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的<code>ID</code>，而这个<code>ID</code>的数据结构是<code>SEL</code>:<br><code>typedef struct objc_selector *SEL</code>;<br>其实它就是个映射到方法的C字符串，你可以用<code>Objc</code>编译器命令<code>@selector()</code>或者<code>Runtime</code>系统的<code>sel_registerName</code>函数来获得一个<code>SEL</code>类型的方法选择器。  </p><p><strong>3、id</strong><br><code>objc_msgSend</code>第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针：<br><code>typedef struct objc_object *id;</code><br>那<code>objc_object</code>又是啥呢：<br><code>struct objc_object { Class isa; };</code><br><code>objc_object</code>结构体包含一个<code>isa</code>指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。  </p><p><strong>4、runtime.h中Class的定义</strong>  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;<span class="comment">//每个Class都有一个isa指针</span></div><div class="line"></div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;<span class="comment">//父类</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;<span class="comment">//类名</span></div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;<span class="comment">//类版本</span></div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;<span class="comment">//!*!供运行期使用的一些位标识。如：CLS_CLASS (0x1L)表示该类为普通class; CLS_META(0x2L)表示该类为metaclass等(runtime.h中有详细列出)</span></div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;<span class="comment">//实例大小</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;<span class="comment">//存储每个实例变量的内存地址</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;<span class="comment">//!*!根据info的信息确定是类还是实例，运行什么函数方法等</span></div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;<span class="comment">//缓存</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;<span class="comment">//协议</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure><p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>在objc_class结构体中：<code>ivars</code>是<code>objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改<code>*methodLists</code>的值来添加成员方法，这也是<code>Category</code>实现的原理。  </p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>1、什么是 method swizzling（俗称黑魔法）  </p><ul><li><p>简单说就是进行方法交换</p></li><li><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的</p></li><li><p>每个类都有一个方法列表，存放着方法的名字和方法实现的映射关系，selector的本质其实就是方法名，IMP有点类似函数指针，指向具体的Method实现，通过selector就可以找到对应的IMP。<br><img src="http://oui2ar2u7.bkt.clouddn.com/2d4ed95fd3f04b7217f3f769eafdb8c6.jpeg" alt=""></p></li><li><p>交换方法的几种实现方式  </p><ul><li>利用 method_exchangeImplementations 交换两个方法的实现  </li><li>利用 class_replaceMethod 替换方法的实现  </li><li>利用 method_setImplementation 来直接设置某个方法的IMP。<br><img src="http://oui2ar2u7.bkt.clouddn.com/cf4ae090f0098668a85a731685e2d533.jpeg" alt=""> </li></ul></li></ul><p><strong>参考：</strong><br><a href="http://www.jianshu.com/p/f6dad8e1b848" target="_blank" rel="external">Runtime Method Swizzling开发实例汇总（持续更新中）</a><br>          <a href="http://nshipster.cn/method-swizzling/" target="_blank" rel="external">OC运行时黑魔法 Method Swizzling</a></p><p>2、下面的代码输出什么?</p><pre><code class="objectivec"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">NSObject</span></span>- (<span class="keyword">id</span>)init{    <span class="keyword">self</span> = [<span class="keyword">super</span> init];    <span class="keyword">if</span> (<span class="keyword">self</span>) {        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));    }    <span class="keyword">return</span> <span class="keyword">self</span>;}<span class="keyword">@end</span></code></pre><p>答案：都输出 Son</p><ul><li><p><code>class</code>获取当前方法的调用者的类，<code>superClass</code>获取当前方法的调用者的父类，<code>super</code>仅仅是一个编译指示器，就是给编译器看的，不是一个指针。  </p></li><li><p>本质：只要编译器看到super这个标志，就会让当前对象去调用父类方法，本质还是当前对象在调用这个题目主要是考察关于<code>objc</code>中对<code>self</code>和<code>super</code>的理解：</p></li><li><p><code>self</code>是类的隐藏参数，指向当前调用方法的这个类的实例。而<code>super</code>本质是一个编译器标示符，和<code>self</code>是指向的同一个消息接受者</p></li><li><p>当使用<code>self</code>调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；</p></li><li><p>而当使用<code>super</code>时，则从父类的方法列表中开始找。然后调用父类的这个方法</p></li><li><p>调用<code>[self class]</code>时，会转化成<code>objc_msgSend</code>函数</p></li></ul><pre><code class="objectivec"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)- 调用 `[<span class="keyword">super</span> <span class="keyword">class</span>]`时，会转化成 `objc_msgSendSuper` 函数.<span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)第一个参数是 objc_super 这样一个结构体，其定义如下 <span class="keyword">struct</span> objc_super { __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver; __<span class="keyword">unsafe_unretained</span> Class super_class; };第一个成员是 receiver, 类似于上面的 objc_msgSend函数第一个参数<span class="keyword">self</span>第二个成员是记录当前类的父类是什么，告诉程序从父类中开始找方法，找到方法后，最后内部是使用 objc_msgSend(objc_super-&gt;receiver, <span class="keyword">@selector</span>(<span class="keyword">class</span>))去调用， 此时已经和[<span class="keyword">self</span> <span class="keyword">class</span>]调用相同了，故上述输出结果仍然返回 Sonobjc Runtime 开源代码对- (Class)<span class="keyword">class</span>方法的实现-(Class)<span class="keyword">class</span> { <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>); }</code></pre><h3 id="runtime模块推荐阅读文章"><a href="#runtime模块推荐阅读文章" class="headerlink" title="runtime模块推荐阅读文章"></a>runtime模块推荐阅读文章</h3><p> <a href="http://www.jianshu.com/p/6b905584f536" target="_blank" rel="external">西木 http://www.jianshu.com/p/6b905584f536</a><br> <a href="http://www.jianshu.com/p/9e1bc8d890f9" target="_blank" rel="external">天口三水羊 http://www.jianshu.com/p/9e1bc8d890f9</a><br> <a href="http://www.jianshu.com/p/46dd81402f63" target="_blank" rel="external">夜千寻墨 http://www.jianshu.com/p/46dd81402f63</a><br> <a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="external">袁峥Seemygo http://www.jianshu.com/p/e071206103a4</a><br> <a href="http://www.jianshu.com/p/bd24c3f3cd0a" target="_blank" rel="external">郑钦洪_  http://www.jianshu.com/p/bd24c3f3cd0a</a><br> <a href="http://www.jianshu.com/p/f6300eb3ec3d" target="_blank" rel="external">HenryCheng http://www.jianshu.com/p/f6300eb3ec3d</a>  </p><h3 id="程序员的最爱（不点进去你会后悔的）"><a href="#程序员的最爱（不点进去你会后悔的）" class="headerlink" title="程序员的最爱（不点进去你会后悔的）"></a>程序员的最爱（不点进去你会后悔的）</h3><p> <a href="https://github.com/CustomPBWaters/Apple-OfficialTranslation-SourceAnnotation" target="_blank" rel="external">【译文 &amp; 源码】</a><br> <a href="https://github.com/CustomPBWaters/Framework-Annotations-Tools" target="_blank" rel="external">【工具类】</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引导&quot;&gt;&lt;a href=&quot;#引导&quot; class=&quot;headerlink&quot; title=&quot;引导&quot;&gt;&lt;/a&gt;引导&lt;/h3&gt;&lt;p&gt;runtime是运行时，对于从事iOS开发，想要深入学习OC的人，runtime是必须熟悉掌握的东西。&lt;/p&gt;
&lt;h3 id=&quot;runtim
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo搭建属于自己的博客</title>
    <link href="http://yoursite.com/2017/06/07/hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/06/07/hexo搭建属于自己的博客/</id>
    <published>2017-06-07T13:24:23.000Z</published>
    <updated>2017-08-12T10:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="安装Node（必须）"><a href="#安装Node（必须）" class="headerlink" title="安装Node（必须）"></a>安装Node（必须）</h3><p><strong>作用</strong>：用来生成静态页面的<br>到<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>官网下载相应平台的最新版本，一路安装即可。</p><h3 id="安装Git（必须）"><a href="#安装Git（必须）" class="headerlink" title="安装Git（必须）"></a>安装Git（必须）</h3><p><strong>作用</strong>：把本地的hexo内容提交到github上去.<br>安装<strong>Xcode</strong>就自带有Git，就不多说了。</p><h4 id="申请GitHub（必须）"><a href="#申请GitHub（必须）" class="headerlink" title="申请GitHub（必须）"></a>申请GitHub（必须）</h4><p><strong>作用</strong>：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。  </p><h4 id="注册Github账号-必须"><a href="#注册Github账号-必须" class="headerlink" title="注册Github账号(必须)"></a>注册Github账号(必须)</h4><p>这里我们就不多讲了，小伙伴们可以点击<a href="https://github.com" target="_blank" rel="external">这里</a>，进入官网进行注册。  </p><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>登录账号后，在Github页面的右上方选择New repository进行仓库的创建。<br><img src="http://oui2ar2u7.bkt.clouddn.com/291600-7cec7b9f28359ea5.png" alt=""><br><strong>在仓库名字输入框中输入：<br>你想要的名字.github.io<br>然后点击Create repository即可</strong>  </p><h4 id="生成添加秘钥"><a href="#生成添加秘钥" class="headerlink" title="生成添加秘钥"></a>生成添加秘钥</h4><p>在终端（Terminal）输入：<br>ssh-keygen -t rsa -C “Github的注册邮箱地址”<br>一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入<a href="https://github.com/settings/ssh" target="_blank" rel="external">这里</a><br><img src="http://oui2ar2u7.bkt.clouddn.com/291600-3bff2a591beb2bb6.png" alt=""><br>将复制的内容粘贴到<strong>Key</strong>的输入框，随便写好Title里面的内容，点击<strong>Add SSH key</strong>按钮即可。</p><h3 id="安装Hexo："><a href="#安装Hexo：" class="headerlink" title="安装Hexo："></a>安装Hexo：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字 </div><div class="line">$ hexo init &lt;folder&gt;  </div><div class="line">//进入博客文件夹，&lt;folder&gt;为文件夹的名称  </div><div class="line">$ cd &lt;folder&gt;  </div><div class="line">//node.js的命令，根据博客既定的dependencies配置安装所有的依赖包  </div><div class="line">$ npm install</div></pre></td></tr></table></figure><h4 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置_config.yml文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Site  </div><div class="line">title: blog name#博客名  </div><div class="line">subtitle: Goals determine what you are going to be  #副标题  </div><div class="line">description: Goals determine what you are going to be #用于搜索，没有直观表现  </div><div class="line">author: author name #作者  </div><div class="line">language: zh-CN #语言  </div><div class="line">timezone:   #时区，此处不填写，hexo会以你目前电脑的时区为默认值</div></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy  </div><div class="line">  type: git  </div><div class="line">  repo: ssh://git@github.com/a-stupid-wood/a-stupid-wood.github.io </div><div class="line">  branch: master</div></pre></td></tr></table></figure><h3 id="每次部署的步骤，可按以下三步来进行。"><a href="#每次部署的步骤，可按以下三步来进行。" class="headerlink" title="每次部署的步骤，可按以下三步来进行。"></a>每次部署的步骤，可按以下三步来进行。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean  </div><div class="line">hexo generate   </div><div class="line">hexo deploy</div></pre></td></tr></table></figure><h3 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h3><pre><code class="bash">hexo new<span class="string">"postName"</span> <span class="comment">#新建文章  </span>hexo new page<span class="string">"pageName"</span> <span class="comment">#新建页面  </span>hexo generate <span class="comment">#生成静态页面至public目录  </span>hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）  </span>hexo deploy <span class="comment">#将.deploy目录部署到GitHub  </span>hexo <span class="built_in">help</span> <span class="comment"># 查看帮助  </span>hexo version <span class="comment">#查看Hexo的版本</span></code></pre><h3 id="报错总结"><a href="#报错总结" class="headerlink" title="报错总结"></a>报错总结</h3><p><strong>如发生报错:</strong><br><code>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</code><br><strong>解决方法：</strong>   </p><pre><code class="bash">npm install hexo-deployer-git --save</code></pre><p><strong>如发生报错:</strong><br> <code>ERROR Process failed: layout/.DS_Store</code><br><strong>那么进入主题里面layout和_partial目录下，使用删除命令:</strong>  </p><pre><code class="bash">rm-rf.DS_Store</code></pre><p><strong>如发生报错:</strong><br><code>ERROR Plugin load failed: hexo-server</code><br><strong>原因：</strong><br><em>Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore.</em><br><strong>解决方法，执行命令：</strong>  </p><pre><code class="bash">sudo npm install hexo-server</code></pre><p><strong>如发生报错:</strong><br><code>执行命令hexo server，提示：Usage: hexo ....</code><br><strong>原因：</strong><br><em>应该是没有生成本地服务</em><br><strong>解决方法，执行命令：</strong>  </p><pre><code class="bash">npm install hexo-server --save</code></pre><p><em>提示：hexo-server@0.1.2 node_modules/hexo-server<br>….</em></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h3><p><a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">hexo官方文档</a><br><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">Markdown语法</a><br><a href="http://blog.csdn.net/u011974987/article/details/51331822" target="_blank" rel="external">基于Hexo+GitHub Pages 搭建博客详细教程</a><br><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="external">HEXO+Github,搭建属于自己的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h2&gt;&lt;h3 id=&quot;安装Node（必须）&quot;&gt;&lt;a href=&quot;#安装Node（必须）&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
</feed>
