<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kerwin</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-25T08:46:19.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kerwin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swift项目中Intruments之旅</title>
    <link href="http://yoursite.com/2017/11/24/swift%E9%A1%B9%E7%9B%AE%E4%B8%ADIntruments%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2017/11/24/swift项目中Intruments之旅/</id>
    <published>2017-11-24T07:52:24.000Z</published>
    <updated>2017-11-25T08:46:19.653Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.raywenderlich.com/166125/instruments-tutorial-swift-getting-started" target="_blank" rel="external">建议看原文</a>，因为翻译带有个人的理解。</p><p><img src="https://koenig-media.raywenderlich.com/uploads/2017/09/Instruments-feature-2.png" width="200" height="200" align="center"><br>学习如何使用和Xcode的Intruments工具排除和优化您的代码!</p><p>无论你是已经做了很多个iOS apps还是刚开始接触：毫无疑问，你会想出新的功能，或者想知道你能做些什么来让你的应用程序变得更好。除了通过添加功能来改进你的应用程序之外，还有一件事是所有优秀的应用开发者都应该做的…优化(instrument)他们的代码！<br>这(instruments)优化之旅将会告诉你怎么使用XCode自带的一个叫做Instruments的工具的最重要的属性，它允许您检查代码的性能问题、内存问题、循环引用和其他问题。<br>在这教程中你将学习到：  </p><ul><li>如何使用<strong>时间分析器工具(Time Profiler)</strong>来确定代码中的热点，从而提高代码的效率</li><li>如何使用<strong>分配工具(Allocations)</strong>和<strong>可视化内存调试器(Visual Memory Debugger)</strong>来检测和修复内存管理问题，比如代码中的循环引用。</li></ul><blockquote><p>Note:本教程假设您熟悉Swift和iOS编程。如果你是iOS编程的新手，你可能想看看这个网站上的其他教程。本教程使用了一个storyboard，所以要确保您熟悉这个概念;<a href="https://www.raywenderlich.com/160521/storyboards-tutorial-ios-11-part-1" target="_blank" rel="external">storyboard</a>。  </p></blockquote><p>都准备好了吗?准备好进入迷人的instruments世界吧!:]</p><p>###开始<br>对于本工具教程，您不会从头开始创建应用程序;相反，已经为您提供了一个示例项目。你的任务是通过应用程序来改进它，使用工具作为你的指南——非常类似于你如何优化你自己的应用程序!<br><a href="https://koenig-media.raywenderlich.com/uploads/2017/09/InstrumentsSwift-Starter.zip" target="_blank" rel="external">下载开始项目</a>,然后解压并用Xcode打开它。<br>这个简单的app使用了Flickr API来搜索图片。要使用这个API你需要一个API key。对于演示项目，您可以在Flickr的网站上生成一个示例key。只在<a href="http://www.flickr.com/services/api/explore/?method=flickr.photos.search" target="_blank" rel="external">http://www.flickr.com/services/api/explore/?method=flickr.photos.search</a>执行行任何搜索并从URL中把API key复制出来,把它粘贴到<code>FlickrAPI.swift</code>文件的顶部替代掉已存在的API key。<br>请注意，这个示例API key每天都更改，因此您可能需要重新生成一个新的key。当key不再有效的时候，应用程序会提醒你。<br>构建并运行应用程序，执行搜索，单击结果，您将看到如下内容:<br><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/iOS-Simulator-Screen-Shot-21-Mar-2015-00.01.35-281x500.png" alt=""><br>浏览应用程序并查看基本功能。你可能会想，一旦UI看起来很好，应用程序就可以存储提交了。但是，您将看到使用Instruments可以添加到应用程序中的值。<br>本教程接下来将向您展示如何查找和修复应用程序中仍然存在的问题。您将会看到Instruments是如何使调试问题变得更加容易!:]</p><h3 id="Time-for-Profiling（时间分析）"><a href="#Time-for-Profiling（时间分析）" class="headerlink" title="Time for Profiling（时间分析）"></a>Time for Profiling（时间分析）</h3><p><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/time-profiler-icon.png" alt=""><br>你要看的第一个Instrument是<strong>Time Profiler(时间分析器)</strong>。在测量的间隔内，Instruments将停止程序的执行，并在每个运行的线程上执行堆栈跟踪。可以把它看作是在Xcode的调试器中单击pause按钮。<br>以下是对<strong>Time Profiler</strong>的预览:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/time-profiler-sneak-preview.png" alt=""><br>这个屏幕显示调用树(Call Tree)。调用树(Call Tree)显示了在应用程序中在各种方法中执行的时间量，每一行都是程序执行路径所遵循的不同方法。每个方法中花费的时间可以从每个方法中停止分析器的次数来确定。<br>例如，如果100个样本在1毫秒的间隔内完成，并且一个特定的方法被发现在10个样本的堆栈顶部，那么你就可以推断，在这个方法中花费的总执行时间的大约10%——10毫秒。这是一个相当粗糙的近似，但它确实有效!  </p><blockquote><p>Note:一般来说，你应该在真机上配置你的应用程序，而不是模拟器。iOS模拟器拥有你的Mac电脑的所有马力，而一个真机将拥有移动硬件的所有限制。你的应用程序可能在模拟器上运行得很好，但是当它运行在一个真机上时，可能会出现一个性能问题。  </p></blockquote><p>所以，没有任何的麻烦，时间开始instrumenting<br>在Xcode的菜单栏中，选择Product\Profile或者点击快捷键<code>command + I</code>.<br>这将建立应用程序和发射仪器。您将得到一个选择窗口，看起来像这样:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/time_profiler-650x459.png" alt=""><br>这是Instruments上带的所有不同模板<br>选择Time Profiler工具并单击Choose。这将打开一份新的文书文件。点击左上角的红色记录按钮，开始录制和启动app。你可能会被要求你的密码授权工具来分析其他过程——不要害怕，在这里提供是安全的!:]<br>在仪器窗口中，你可以看到时间在计算，一个小箭头从左到右移动，在屏幕中央的图形上方。这表明应用程序正在运行。<br>现在，开始使用app，搜索一些图片，并深入到一个或多个搜索结果中。你可能已经注意到，进入搜索结果的速度非常慢，而且滚动搜索结果列表也令人难以置信——这是一个非常笨拙的应用程序!<br>好吧，你很幸运，因为你准备开始修理它了!然而，首先你很快就会对在Instruments上看到的东西感到失望。<br>首先，确保工具栏右边的视图两个选择器处于选中状态，像这样:<br> <img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.14.53.png" alt=""><br> 这将确保所有的面板都是打开的。现在研究下面的截图，并解释下面的每个部分:<br> <img src="https://koenig-media.raywenderlich.com/uploads/2017/08/time-profiler-panels.png" alt="">  </p><ol><li>这些是记录控制。红色的“记录”按钮将会停止并启动应用程序，当它被点击时(它在一个记录和停止图标之间切换)。暂停按钮完全按照你的预期执行，并暂停应用程序的当前执行。</li><li>这是运行计时器。计时器计算了app被剖析运行了多长时间，以及它运行了多少次。点击停止按钮，然后重新启动应用程序，你将看到现在显示的显示<strong>Run 2 of 2</strong></li><li>这叫做轨道。在你选择的时间分析器(Time Profile)模板的情况下，只有一个工具，所以只有一条路径。在本教程的后面，您将了解有关图的细节的更多信息。</li><li>这是细节面板。它显示了您正在使用的特定instrument的主要信息。在这种情况下，它显示的方法是“最热的”——也就是说，使用最多CPU时间的方法。<br>单击该区域顶部的bar上的文字Profile，并选择Samples(示例)。这里你可以看到每一个样本。单击一些示例，您将看到捕获的堆栈跟踪出现在右侧的Extended Detail检查器中。完成后切换Profile。</li><li>这是检查器面板。有两个检查器:扩展细节和运行信息。你很快就会学到更多关于这些选项的知识。  </li></ol><h3 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h3><p>执行图像搜索，并深入研究结果。我个人喜欢搜索“猫”，但选择你想要的——你可能是其中的一只猫!:]<br>现在，在列表中上下滚动几次，这样就可以在时间分析器(Time Profile)中获得大量的数据。你应该注意到屏幕中间的数字在变化，图形填入;这告诉您CPU周期正在被使用。<br>没有 table view是准备发送，直到它像黄油一样滚动。<br>为了帮助查明问题，您将设置一些选项。点击停止按钮，在细节面板下方，点击 Call Tree 按钮。在弹出的窗口中，选择Separate by Thread(独立的线程)，Invert Call Tree(倒转调用树)和Hide System Libraries(隐藏系统库)。它看起来是这样的:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/call-tree-options.png" alt=""><br>下面是每个选项对在左表中显示的数据所做的工作:  </p><ul><li>Separate by State：这个选项组是由应用程序的生命周期状态所产生的，这是一种检查应用程序做了多少工作和时间的有用方法。</li><li>Separate by Thread：每个线程都应该单独考虑。这有助于您了解哪个线程占用了最大的CPU使用量。</li><li>Invert Call Tree：有了这个选项，从上倒下跟踪堆栈,这意味着你看到的表中的方法,将已从第0帧开始取样,这通常你是想要的,只有这样你才能看到CPU中话费时间最深的方法.也就是说FuncA{FunB{FunC}} 勾选此项后堆栈以C-&gt;B-A 把调用层级最深的C显示在最外面 </li><li>Hide System Libraries：当选择此选项时，只显示来自您自己应用程序的符号。选择此选项通常很有用，因为通常您只关心CPU在您自己的代码中的花费时间——您不能在系统库使用多少CPU的情况下做很多事情!</li><li>Flatten Recursion：此选项将递归函数(调用自己的函数)作为每个堆栈跟踪中的一个条目，而不是多个。</li><li>Top Functions：启用这一功能，使得工具可以将在函数中使用的总时间看作是函数内的时间之和，包括了函数调用的函数的时间。如果函数A调用B,那么函数A的时间是函数A花费的时间 + 函数B所花费的时间 .这非常有用,因为它可以让你每次下到调用堆栈时挑最大的时间数字，归零在你最耗时的方法。   </li></ul><p>查看结果以确定哪些行在权重列中百分比最高。注意到主线程的行占用了很大一部分CPU周期。通过单击文本左边的小箭头展开这一行，然后向下钻取，直到看到您自己的方法(以“person”符号标记)。虽然有些值可能略有不同，但条目的顺序应该类似于下面的表:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/time-profiler-results.png" alt=""><br>当然，这看起来不太好。绝大多数时间都花在将“Tonal”滤镜应用于缩略图的方法上。这对您来说不应该太过震惊，因为表加载和滚动是UI中最笨拙的部分，而这正是表单元不断更新的时候。<br>要了解该方法中发生的情况，请双击表中的这一行，将会看到下图：<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/Screen-Shot-2017-09-02-at-09.57.35-650x305.png" alt=""><br>这非常有趣，难道不是吗？<code>applyTonalFilter()</code>是个加在<strong>UIImage</strong>扩展上的方法，而且在应用这个滤镜后，大量时间用在调用创建 <strong>CGImage output</strong> 的方法上了<br>要加快这一速度并没有什么可做的:创造图像是一个非常密集的过程，而且要花很长时间。让我们尝试后退一步，看看调用<code>applyTonalFilter()</code>的位置。点击<strong>Root</strong>,回到上一个屏幕: </p><p><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/time-profiler-call-tree-breadcrumb.png" alt=""></p><p>现在点击表格顶部的applyTonalFilter行左边的小箭头。这将显示applyTonalFilter的调用者。你可能需要展开下一行;当对Swift进行分析时，在调用树中有时会有重复的行，前缀为@ objc。你感兴趣的第一行是“person”符号，这表明它属于你的app的目标:  </p><p><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/tonal-filter-call-tree.png" alt=""><br>现在，这一行指向了<code>results collection view’s (_:cellForItemAt:)</code>,双击该行以查看项目中的相关代码。<br>现在你可以看到问题了。看一看74行;应用”tonal”滤镜的方法需要很长时间才能执行，它直接从collectionView(_:cellForItemAt:)调用，它会在每次请求过滤图像时阻塞主线程(以及整个UI)。   </p><h3 id="卸货工作"><a href="#卸货工作" class="headerlink" title="卸货工作"></a>卸货工作</h3><p>要解决这个问题，你讲需要执行两步:首先，将图片加载滤镜卸载到带有<code>DispatchQueue.global().async</code>的后台线程上;然后在生成后缓存每个图像。在starter项目中，有一个小而简单的图片缓存类(带有catchy的名称ImageCache)，它只是将图片存储在内存中，然后用给定的键检索它们。<br>现在你可以切换到Xcode，手动找到你正在查看的文件的源文件，在代码上方的面板中右上角可以找到方便打开Xcode的按钮，单击它:<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/open-in-xcode-button.png" alt=""><br>开始吧!Xcode在正确的位置打开。Boom!<br>现在，在<code>collectionView(_:cellForItemAt:)</code>中，将调用<code>loadThumbnail(for:completion:)</code>替换为如下代码:  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">ImageCache.shared.loadThumbnail(<span class="keyword">for</span>: flickrPhoto) &#123; result <span class="keyword">in</span></div><div class="line"></div><div class="line">  <span class="keyword">switch</span> result &#123;</div><div class="line">          </div><div class="line">    <span class="keyword">case</span> .success(let image):</div><div class="line">          </div><div class="line">      <span class="keyword">if</span> cell.flickrPhoto == flickrPhoto &#123;</div><div class="line">        <span class="keyword">if</span> flickrPhoto.isFavourite &#123;</div><div class="line">          cell.imageView.image = image</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">if</span> let cachedImage = ImageCache.shared.image(forKey: <span class="string">"\(flickrPhoto.id)-filtered"</span>) &#123;</div><div class="line">            cell.imageView.image = cachedImage</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">else</span> &#123;</div><div class="line">             DispatchQueue.global().async &#123;</div><div class="line">               <span class="keyword">if</span> let filteredImage = image.applyTonalFilter() &#123;</div><div class="line">                 ImageCache.shared.set(filteredImage, forKey: <span class="string">"\(flickrPhoto.id)-filtered"</span>)</div><div class="line">                    </div><div class="line">                   DispatchQueue.main.async &#123;</div><div class="line">                     cell.imageView.image = filteredImage</div><div class="line">                   &#125;</div><div class="line">                &#125;</div><div class="line">             &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">          </div><div class="line">  <span class="keyword">case</span> .failure(let error):</div><div class="line">    print(<span class="string">"Error: \(error)"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">这段代码的第一部分与之前的代码是一样的，并关联到从web上加载FlickrPhoto的缩略图。如果照片是受欢迎的，那么单元格显示的是缩略图。然而，如果照片不受欢迎，则应用<span class="string">"tonal"</span>滤镜。  </div><div class="line">这里你可以改变的东西：首先，你检查应用滤镜的图片是否在图片缓存里面，如果是，太好了，展示这图片到imageView上，如果没有，你将发出调用，将<span class="string">"tonal"</span>滤镜应用到后台队列上。这将允许UI在对图片应用滤镜的时候保持响应。当应用完滤镜得到图片，保存图片到缓存，并在主线程更新imageView。  </div><div class="line">这是应用滤镜的图像处理的，但仍然有原始的Flickr缩略图被处理。打开缓存。迅速找到`loadThumbnail(<span class="keyword">for</span>:completion:)`。将其替换为以下内容:  </div><div class="line"></div><div class="line">```objectivec</div><div class="line">func loadThumbnail(<span class="keyword">for</span> photo: FlickrPhoto, completion: @escaping FlickrAPI.FetchImageCompletion) &#123;</div><div class="line">  <span class="keyword">if</span> let image = ImageCache.shared.image(forKey: photo.id) &#123;</div><div class="line">    completion(Result.success(image))</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    FlickrAPI.loadImage(<span class="keyword">for</span>: photo, withSize: <span class="string">"m"</span>) &#123; result <span class="keyword">in</span></div><div class="line">      <span class="keyword">if</span> <span class="keyword">case</span> .success(let image) = result &#123;</div><div class="line">        ImageCache.shared.set(image, forKey: photo.id)</div><div class="line">      &#125;</div><div class="line">     completion(result)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">这与处理应用滤镜的图片的方式非常相似。如果一个图片已经存在于缓存中，那么您就可以直接使用缓存的图片调用完成闭包。否则，您将从Flickr加载图片并将其存储在缓存中。  </div><div class="line">选择Product\Profile或者点击快捷键`command + I`打开Intruments重新运行app   </div><div class="line">注意到这次Xcode并没有要求您使用哪一个工具。这是因为您仍然为这个应用程序打开了一个窗口，而Instruments假设您希望再次运行相同的选项。  </div><div class="line">再执行一些搜索，并注意到这次UI并不那么笨重!现在，图像滤镜被异步应用，图像被缓存在后台，所以它们只需要应用滤镜一次。您将在调用树中看到一些`dispatch_worker_threads`——它们正在处理图片应用滤镜的繁重工作。  </div><div class="line">看起来太棒了!现在该出货了吗?没有!:]  </div><div class="line"></div><div class="line"><span class="meta">### Allocations, Allocations, Allocations(分配，分配，分配)  </span></div><div class="line">那你接下来要追踪什么bug呢?:]  </div><div class="line">这个项目中隐藏着一些你可能不知道的东西。您可能听说过内存泄漏(memory leaks)。但你可能不知道的是实际上有两种泄漏(leaks):  </div><div class="line"><span class="number">1.</span> 真正的内存泄漏是一个对象不再被任何东西引用，但仍分配了内存——这意味着无法重用这部分内存。  </div><div class="line">尽管Swift和ARC帮助我们管理内存，最常见的内存泄露是循环引用。这是两个对象持有彼此的强应用，因此，每个对象都阻止另外一个对象被释放，这意味着它们占用的内存永远不会被释放。</div><div class="line"><span class="number">2.</span> 未绑定内存增长是内存继续被分配的地方，从来没有机会被释放。如果这种情况持续到永远，那么在某些时候系统的内存就会被填满，你就会有一个大的内存问题。在iOS上，这意味着应用程序将被系统杀死。</div><div class="line"></div><div class="line">本教程中介绍的下一个工具是分配(Allocations)工具,这为您提供了关于正在创建的所有对象以及支持它们的内存的详细信息;它还显示了每个对象的引用计数。  </div><div class="line">要重新开始使用一个新的工具配置文件，退出Instruments，不要担心保存这个特定的运行。现在点击**Command + I**,从列表中选择**Allocations**工具,然后单击**Choose**。  </div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2017/08/allocations-1-650x459.png)  </span></div><div class="line">现在你应该进入分配(Allocations)工具面板。看起来是不是很熟悉，没错，因为他看起来跟时间分析器(time profiler)面板很像。  </div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2017/08/allocations_instrument_blank-650x432.png)  </span></div><div class="line">点击左上角的 **Record** 按钮运行app，这时你将注意到有两条路线(track),为了这次教程的目的，你将只需要关注其中一条叫All Heap and Anonymous VM(所有堆和匿名VM)  </div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2017/08/allocations_instrument-650x432.png)  </span></div><div class="line">在应用程序上运行的分配工具，在应用程序中进行五个不同的搜索，但不会深入到结果中。确保搜索有一些结果。现在让应用程序稍微等几秒钟。  </div><div class="line">&lt;img src=<span class="string">"https://koenig-media.raywenderlich.com/uploads/2017/09/five_searches.png"</span> width = <span class="string">"281"</span> height = <span class="string">"500"</span> align=center /&gt; </div><div class="line"></div><div class="line">你应该注意到所有堆和匿名VM(All Heap and Anonymous VM)轨道上的图形都在上升。这告诉你内存正在被分配。这个特性将指导您找到无边界内存增长。  </div><div class="line">你现在要做的是“生成分析”。要做这个，点击详情面板底部的`Mark Generation `按钮：  </div><div class="line"></div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2017/08/mark-generation.png)  </span></div><div class="line"></div><div class="line">点击了之后你将看到一个红色的旗子(red flag)出现在轨道上，像这样:  </div><div class="line"></div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2017/08/generation-flag.png)  </span></div><div class="line"></div><div class="line">生成分析的目的是多次执行一个动作，看看内存是否以无界的方式增长，进入搜索结果中，等待几秒钟的图像加载，然后返回到主页。然后再次标记生成。重复进行不同的搜索。  </div><div class="line">进入几个搜索结果之后，Intrument看起来是这样子：  </div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2017/08/generation-analysis.png)  </span></div><div class="line">在这一点上，你应该开始怀疑了。请注意，蓝色图形是如何随着每次进入不同的搜索结果而上升的。那当然不好。但是等等，关于内存警告呢?你知道的，对吧?内存警告是iOS的一种方式，它告诉一个应用程序，在内存中事情变得紧张，你需要清除一些内存。  </div><div class="line">有可能这种增长不仅仅是由于你的应用程序;它可能是在<span class="built_in">UIKit</span>的深处，保存在内存中。给系统框架和你的应用程序一个机会，先清除他们的记忆，然后再指向任何一个。  </div><div class="line">通过在Instruments菜单栏中选择`Instrument\Simulate Memory Warning`,或者从模拟器的菜单栏中选择`Hardware\Simulate Memory Warning`来模拟内存警告,您会注意到内存使用会减少一点，或者根本不会。当然不会回到应该去的地方。因此，仍有无限的内存增长发生在某处。  </div><div class="line"></div><div class="line"><span class="meta">### Instruments:关于我的生成(Generation)  </span></div><div class="line">在进行搜索的每次迭代之后标记生成的原因是，您可以看到在每次生成之间分配的内存。看一下细节面板，你会看到几次生成。  </div><div class="line">在每一次生成里面，你将看到所有被分配的对象，并在生成标记时仍然驻留在此。随后的几次生成将只包含上次生成后的对象。  </div><div class="line">看一下增长列，你会发现某个地方确实增长，打开其中一个生成，你会看到：  </div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.55.18-480x270.png)  </span></div><div class="line">哇，那可是很多东西啊!你从哪里开始呢?  </div><div class="line">简单，点击Growth用大小来筛选，确保最大的对象在顶部。在每一代的顶部，你会注意到一个被标记为`ImageIO_jpeg_Data`的行,这当然听起来像是在你的应用程序中处理过的事情，点击`ImageIO_jpeg_Data`左边的箭头，显示与这个项目相关的内存地址。选择第一个内存地址，在右边面板的扩展细节检查器中显示关联的堆栈跟踪:  </div><div class="line">![](https:<span class="comment">//koenig-media.raywenderlich.com/uploads/2017/08/problem_with_allocations-650x432.png)  </span></div><div class="line">这个堆栈跟踪显示了这个特定对象创建的时间点。堆栈跟踪的灰色部分是在系统库中;黑色的部分在你的应用程序的代码里。嗯,看起来很熟悉的东西:一些黑色条目显示了您的老朋友`collectionView(_:cellForItemAt:)`。双击任何一个条目，工具将在其上下文中显示代码。  </div><div class="line">看一下方法，你将会看到它在<span class="number">81</span>行调用了`set(_:forKey:)`。记住，这个方法会缓存一个图片，以便于以后在应用程序中再次使用它。哈！好像发现问题在哪了。  </div><div class="line">再次点击 Open <span class="keyword">in</span> Xcode 按钮跳到 Xcode。打开 Cache.swift，看看 `set(_:forKey:)`的实现。  </div><div class="line"></div><div class="line">```objectivec</div><div class="line">  func set(_ image: <span class="built_in">UIImage</span>, forKey key: String) &#123;</div><div class="line">    images[key] = image</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>这会添加一张图片到字典中，key 就是 Flickr 照片的照片 ID。但如果你看过代码，你会发现字典中的图片永远不会被清除！<br>这就是内存无限增长的原因了：什么问题都没有，就是 app 不会清除缓存——它只会添加缓存！<br>要解决这个问题，你只需要让 ImageCache 监听由 UIApplication 发出的内存警告通知。当 ImageCache 收到这个通知，它会规规矩矩地清除缓存。<br>要让 ImageCache 监听这个通知，请打开 Cache.swift，为这个类添加初始化方法和反初始化方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">init() &#123;</div><div class="line">   NotificationCenter.default.addObserver(forName: Notification.Name.UIApplicationDidReceiveMemoryWarning, object: <span class="literal">nil</span>, queue: .main) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] notification <span class="keyword">in</span></div><div class="line">    <span class="keyword">self</span>?.images.removeAll(keepingCapacity: <span class="literal">false</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">deinit &#123;</div><div class="line">  NotificationCenter.default.removeObserver(<span class="keyword">self</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里注册了 UIApplicationDidReceiveMemoryWarningNotification 观察者，用于执行上面的那段闭包，将图片从缓存中删除。<br>闭包中的代码仅仅是移除了缓存中的所有对象，这会让 images 中什么也不剩下，同时它们将会被释放。<br>要测试这段代码，再次打开 Instruments（在 Xcode 中按 cmd+I），并重复之前的步骤。别忘了在最后模拟一个内存警告  </p><blockquote><p>Note:确保你是从 Xcode 中启动，执行一次编译，而不是点击 Instruments 中的红色按钮。这样能确保你使用的是最新代码。你也可以在 Profiling 之前 Build &amp; Run，因为有时候仅仅是 Profile 的话 Xcode 不会更新模拟器中的 app 的 build。 </p></blockquote><p>这次的生成分析应该是这个样子了：<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/working_cache-650x432.png" alt=""><br>你会看到在内存警告之后内存用量会降低。内存涨幅仍然会有一些，但已经之前相比差得很多了。<br>仍然会有一点内存涨幅的原因是系统库，你对此表示无能为力。显然系统库没有释放所有的内存，这可能是故意的，也可能是一个 Bug。所以你只能在你的 app 中尽可能多地释放内存，就像你所做的一样！<br>干得不错！有一个问题解决了！现在来打包吧！哦，稍等——还有另一种内存泄漏问题没有解决（第一种）。  </p><h3 id="强引用循环"><a href="#强引用循环" class="headerlink" title="强引用循环"></a>强引用循环</h3><p>前面提过，当两个对象彼此强引用对方时会导致强引用循环，导致内存无法被释放。你可以采用另外的一种不同的方式提过 Allocations instrument 来检查出引用循环。<br>关闭 Instruments 回到 Xcode。再次点击 Product\Profile，选择 Allocations 模板。<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/allocations_template-650x459.png" alt=""><br>这次不使用世代分析。这次，你将看到内存中有多少不同类型的交缠在一起的对象。点击录制按钮开始运行。你会看到在详情面板中有大量的对象——多的看不过来！要将这些对象缩减到我们的目标对象，在左下角的文本框中输入 Instruments 作为过滤词。<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/little_field_bottom_left_corner-650x432.png" alt=""><br>在 Instruments 中有两列值得注意：# Persistent 和 # Transient。前者记录了当前内存中每种类型的对象数。后者显示曾经存在但已经被释放的对象数。Persistent 对象是正在使用内存的，Transient 对象是已经被释放的。<br>你应该看到这里有一个 ViewController 的 persisent 对象——这是对的，因为它就是你当前正在看的屏幕。此外还有一个 app 的 AppDelegate 实例。<br>回到 app !执行一次搜索并进入精确的结果中。注意在 Instruments 中多出了一堆对象显示：SearchResultsViewController 和 ImageCache。ViewController 对象仍然是 persistent 的，因为它是 navigation controller 要用的。这没问题。<br>现在点击 app 的返回按钮。SearchResultsViewController 现在从导航栈中弹出，它应当被释放。但它仍然有一个 # Persistent 数为 1 的记录在 Allocations Summary 中！怎么回事？<br>在操作两次搜索并在每次搜索后点击返回按钮。出现了 3 个 SearchResultsViewController?! 这些 view controller 都在内存中，说明有什么东西保持了一个对它们的强引用。你制造了一个强引用循环！<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/strong_reference_cycle-650x432.png" alt=""><br>这种情况不仅仅存在于 SearchResultsViewController，也存在于 SearchResultsCollectionViewCell。很可能是这两个类之间出现了引用循环。 </p><p>值得庆幸的是，在 Xcode 8 以后引入了可视化内存调试器，这是一个很好的工具，能够帮助你进一步诊断内存泄漏和引用循环。可视化内存调试器不属于 Xcode Instrument 套件的一部分，但仍然是一个很好用的工具，值得在本教程中介绍。交叉使用 Allocations instrument 和可视化内存调试器能让你的调试工作更加高效。  </p><p>“看见”内存<br>退出 Allocations instrument 和 Instruments 套件。    </p><p>在启动可视化内存调试器之前，先在 Xcode 的 scheme 编辑器中打开 Malloc Stack logging：在窗口左上角点击 Instruments Tutorial scheme(在停止按钮的右边)，选择 Edit Scheme。在弹出界面中，点击 Run 一栏，切换到 Diagnostics 标签页。勾选 Malloc Stack，并选择 Live Allocations Only，然后点击关闭。<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/visual-memory-debugger-scheme-settings2.png" alt="">  </p><p>直接从 Xcode 中打开 app。和之前一样，操作 3 次以上的搜索获得一些数据。<br>然后用这种方式激活可视化内存调试器：<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/visual_memory_debugger.png" alt="">   </p><ol><li>切换到 Debug 导航器。</li><li>点击这个图标，选择弹出菜单中的 View Memory Graph Hierachy。</li><li>点击列表中 SearchResultsCollectionViewCell 这行。</li><li>点击图中的某个对象，然后在检查器面板中查看细节。</li><li>可以从这个地方查看细节。这是 Memory 检查器面板。</li></ol><p>可视化内存调试器会暂停你的 app，显示内存对象中的可视化形式，以及它们之间的引用情况。</p><p>在上图的加亮部分，可视化内存调试器显示了下列信息：</p><ol><li>堆信息 (Debug 导航器面板): 列出所有 app 暂停瞬间内存中分配了的类型和对象的列表。点击类型，可以展开这个类型的所有单个实例。</li><li>内存图（主窗口）：显示对象在内存中的可视化表示。两个对象之间的箭头表示它们的引用关系（强弱引用关系）  </li><li>内存检查器（工具面板）：包含一些细节，比如类名和继承，以及引用是否是强引用还是弱引用。  </li></ol><p>注意在 Debug 导航器中有些行会在一对括号中标注一个数字。这个数字表示这种类型的实例在内存中有多少个。在上图中，你会看到进行几次搜索后，可视化内存调试器会中会看到和在 Allocations instrument 中一样的结果，比如每个 SearchResultsViewController 对象会在内存中产生 20-60 个（如果你滚动到搜索结果的末尾）SearchResultsCollectionViewCell 内存对象。</p><p>通过每行左边的箭头，可以展开这个类型，显示出内存中的每个 SearchResultsViewController 对象。点击每个对象可以在主窗口中显示出这个对象及其引用。<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/visual-memory-debugger-search-results-vc2.png" alt="">  </p><p>注意这些指向了 SearchResultsViewConroller 对象的箭头。好像有几个 Swift 闭包上下文对象引用了同一个 view controller 对象。不敢相信，是吗？来细看一下。选中其中一个箭头，工具面板中查看关于其中一个闭包和 SearchResultsViewController 之间的引用信息。<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/visual-memory-debugger-heart-toggle-handler3.png" alt=""><br>在这个内存检查器中，你可以看到这个 Swift 闭包上下文和这个 SearchResultsViewController 之间的引用是强引用。如果你选择了 SearchResultsCollectionViewCell 和 Swift 闭包上下文之间的引用，你会看到仍然是强引用。你还会看到这个闭包的名字是 heartToggleHandler。哈，它是在 SearchResultsCollectionViewCell 类中定义的嘛！<br>在主窗口中选择 SearchResultsCollectionViewCell 对象，以便在检查器面板中显示更多细节。<br><img src="https://koenig-media.raywenderlich.com/uploads/2017/08/visual-memory-debugger-backtrace1.png" alt=""><br>在调用栈中，你会看到这个 cell 是在 collectionView(_:cellForItemAt:) 方法中实例化的。当你将鼠标放到栈帧中的这一行时，会出现一个小箭头。点击这个小箭头，将会跳转到 Xcode 编辑器中的这个方法上。太棒了！</p><p>在 collectionView(_:cellForItemAt:) 方法中，找到设置 cell 的 heartToggleHandler 属性的地方。你会看到</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cell.heartToggleHandler = &#123; isStarred <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.collectionView.reloadItems(at: [ indexPath ])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 cell 上的心形按钮被点击时，这个闭包会被调用。这里出现了一个强引用循环，但它很难被发现，除非你以前碰到过。但通过可视化内存调试器，你能够沿着蛛丝马迹找到这段代码！<br>在这个闭包中，cell 使用了 self 来引用了 SearchResultsViewController，因此会创建一个强引用。这个闭包会捕获 self。Swift 其实强迫你在闭包中使用 self 一词（反之，如果你引用当前对象的属性和方法时，你通常省略 self）。这会让你更容易意识到你正在捕获它。SearchResultsViewController 也通过 collectionView 对 cell 有一个强引用。  </p><p>要打断强引用循环，你需要在闭包的定义中指定一个捕获列表。所谓捕获列表，允许你声明闭包需要捕获的对象，是以（Weak）还是（unowned）来捕获这些对象： </p><blockquote><p>Weak：当所捕获的引用在未来允许变成 nil 时，可以用 weak。如果它所引用的对象被释放，这个引用会变成 nil。也就是说，它们是可空类型。<br>Unowned：当闭包和它引用的这个对象总是拥有相同的生命周期时，以及在同时释放时，应当使用 unowned 引用。一个 unowned 引用永远不会变成 nil。  </p></blockquote><p>要解决这个强引用循环问题，需要为 heartToggleHandler 添加一个捕获列表：  </p><pre><code class="objectivec">cell.heartToggleHandler = { [<span class="keyword">weak</span> <span class="keyword">self</span>] isStarred <span class="keyword">in</span>        <span class="keyword">self</span>?.collectionView.reloadItems(at: [ indexPath ])}</code></pre><p>将 self 声明为 weak，表明 SearchResultsViewController 会在 collection view cell 仍然引用它的情况下被释放，因为它们之间现在是弱引用关系了。销毁 SearchResultsViewController 就会销毁它的 collection view 及其 cell。  </p><p>在 Xcode 中，用 cmd+I 再次编译并用 Instruments 来运行 app。</p><p>再次像之前一样，用 Allocations instrument 测试 app（记得过滤结果，只显示 starter 项目中的类）。操作一次搜索，进入结果页，然后返回。你会看到 SearchResultsViewController 和它的 cell 现在会在返回时 deallocate 了。它们显示为 transient 对象而不是 persistent 对象。</p><p>循环被打断了，还是打包吧！</p><h3 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h3><p>从<a href="https://koenig-media.raywenderlich.com/uploads/2017/09/InstrumentsSwift-Final.zip" target="_blank" rel="external">这里</a>下载最后优化过的项目代码，感谢 Instruments。</p><p>现在你已经牢牢掌握了本教程中的知识，去 instrument 你自己的代码看看会发生什么有趣的事情！同时，努力将 Instruments 当做你日常开发工作中的一部分。</p><p>你应当经常用 Instruments 来运行你的代码，在发布之前执行一个全面的扫描，确保你尽可能解决了内存问题和性能问题。</p><p>现在，去编写更酷——同时性能更高的 app 吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.raywenderlich.com/166125/instruments-tutorial-swift-getting-started&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;建议看原文&lt;/a&gt;，因为翻译带有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扩大UIButton的点击区域</title>
    <link href="http://yoursite.com/2017/11/19/%E6%89%A9%E5%A4%A7UIButton%E7%9A%84%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2017/11/19/扩大UIButton的点击区域/</id>
    <published>2017-11-19T10:09:00.000Z</published>
    <updated>2017-11-19T10:09:51.778Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span> (<span class="title">EnlargeTouchArea</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setEnlargeEdgeWithTop:(<span class="built_in">CGFloat</span>) top right:(<span class="built_in">CGFloat</span>) right bottom:(<span class="built_in">CGFloat</span>) bottom left:(<span class="built_in">CGFloat</span>) left;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"UIButton+EnlargeTouchArea.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">EnlargeTouchArea</span>)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> topNameKey;</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> rightNameKey;</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> bottomNameKey;</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> leftNameKey;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) setEnlargeEdgeWithTop:(<span class="built_in">CGFloat</span>) top right:(<span class="built_in">CGFloat</span>) right bottom:(<span class="built_in">CGFloat</span>) bottom left:(<span class="built_in">CGFloat</span>) left</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;topNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;rightNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;bottomNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;leftNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>) enlargedRect</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSNumber</span>* topEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;topNameKey);</div><div class="line">    <span class="built_in">NSNumber</span>* rightEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;rightNameKey);</div><div class="line">    <span class="built_in">NSNumber</span>* bottomEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;bottomNameKey);</div><div class="line">    <span class="built_in">NSNumber</span>* leftEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;leftNameKey);</div><div class="line">    <span class="keyword">if</span> (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.bounds.origin.x - leftEdge.floatValue,</div><div class="line">                          <span class="keyword">self</span>.bounds.origin.y - topEdge.floatValue,</div><div class="line">                          <span class="keyword">self</span>.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,</div><div class="line">                          <span class="keyword">self</span>.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bounds;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UIView</span>*) hitTest:(<span class="built_in">CGPoint</span>) point withEvent:(<span class="built_in">UIEvent</span>*) event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGRect</span> rect = [<span class="keyword">self</span> enlargedRect];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectEqualToRect</span>(rect, <span class="keyword">self</span>.bounds))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(rect, point) ? <span class="keyword">self</span> : <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS App上架流程</title>
    <link href="http://yoursite.com/2017/10/22/iOS-App%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/22/iOS-App上架流程/</id>
    <published>2017-10-22T09:40:47.000Z</published>
    <updated>2017-10-22T12:26:39.180Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h4><blockquote><p>1.一个已付费的开发者账号（账号类型分为个人（Individual）、公司（Company）、企业（Enterprise）、高校（University）四种类型，每年资费分别为$99、$99、$299、免费）。<br>2.一个已经开发完成的项目。  </p></blockquote><h4 id="2-生成发布证书"><a href="#2-生成发布证书" class="headerlink" title="2.生成发布证书"></a>2.生成发布证书</h4><blockquote><p>1.打开苹果开发者中心：<a href="https://developer.apple.com" target="_blank" rel="external">https://developer.apple.com</a><br>打开后点击：Account<br><img src="http://oui2ar2u7.bkt.clouddn.com/p118.png" alt=""> </p><p>下面输入已付款过的Apple账号和密码登录<br><img src="http://oui2ar2u7.bkt.clouddn.com/p85.png" alt="">  </p><p>2.点击：Certificates, Identifiers &amp; Profiles (专门生成证书，绑定Bundle Id，绑定device设备，生成描述文件的地方)<br><img src="http://oui2ar2u7.bkt.clouddn.com/p108.png" alt="">  </p><p>3.点击Certificates生成证书</p><blockquote><p>a. 选择iOS, tvOS, watchOS<br>b. 选择All<br>c. 点击右上角新添加证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p139.png" alt=""><br>d. 由于是做App上传，选择生产证书（选择App Store and Ad Hoc）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p84.png" alt=""><br>注意：一个开发者账号只能创建（1-2个开发（测试）证书，2-3个生产（发布）证书），如果你的App Store Ad Hoc 前面的按钮不能选择，则代表你的这个账号无法再创建新的生产证书了。  </p><blockquote><p>解决方法：<br>1.从共同使用这个账号的人电脑上生成.p12文件，导入自己的电脑。（尽量不要执行下面第2步）<br>2.如果你想生成的话，把现有的删除一个（建议删除时间比较靠前的）。注意：如果删除一个证书，那么正在使用这个证书的人将不能再使用了，除非重新生成，然后利用.p12重新导入自己的电脑里！</p><p>注意：如果你想删除证书，执行下面步骤，否则略过。<br><img src="http://oui2ar2u7.bkt.clouddn.com/p137.png" alt="">  </p></blockquote><p>e.生成证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p119.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p146.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p80.png" alt=""><br>f.上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）  </p><blockquote><p>1.在Launchpad的其他里面，点击钥匙串访问弹出如下界面<br><img src="http://oui2ar2u7.bkt.clouddn.com/p88.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p121.png" alt=""><br>2.工具栏选择<strong>钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书…</strong><br><img src="http://oui2ar2u7.bkt.clouddn.com/p97.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p141.png" alt=""><br>3.将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p138.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p96.png" alt=""><br>点击完成<br><img src="http://oui2ar2u7.bkt.clouddn.com/p73.png" alt="">  </p></blockquote><p>g.然后回到浏览器，点击choose File..<br><img src="http://oui2ar2u7.bkt.clouddn.com/p76.png" alt=""><br>h.选择创建好的：CertificateSigningRequest.certSigningRequest 文件，点击选取<br><img src="http://oui2ar2u7.bkt.clouddn.com/p93.png" alt=""><br>点击Generate上传证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p99.png" alt=""><br>i.跳转到如下界面，点击 DownLoad 下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。<br><img src="http://oui2ar2u7.bkt.clouddn.com/p134.png" alt=""><br>下载生成的证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p147.png" alt="">  </p><blockquote><p><strong>注意：</strong>这个证书只能下载一次。点击下载后，关闭页面后就不能再回到下载页面了。<br>如果不需要给别的电脑使用，则直接跳过下面附加项，跳转到第三步（绑定Bundle Identifier）</p></blockquote></blockquote><p>附加项：生成p12文件在其他电脑上使用这个发布证书  </p><blockquote><p>1.双击安装证书后，打开钥匙串访问，选择安装的证书右键单击<br><img src="http://oui2ar2u7.bkt.clouddn.com/p116.png" alt=""><br>注意：如果没有导出，可以把这个证书删除，然后重新双击下载的证书文件安装。 </p><blockquote><p>a. 导出证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p81.png" alt=""><br>b. 存储证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p104.png" alt=""><br><strong>注意</strong>：存储的文件格式一定要是.p12<br>c. 设置密码 (可以为证书设置密码，也可以不设置密码；如果设置了密码，那么别人安装这个证书的时候就要输入密码，否则无法安装。这里就不设置密码了。)<br><img src="http://oui2ar2u7.bkt.clouddn.com/p149.png" alt=""><br>d. 保存导出的证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p143.png" alt="">  </p></blockquote></blockquote></blockquote><h4 id="3-创建App-IDs和绑定你的App的Bundle-Identifier"><a href="#3-创建App-IDs和绑定你的App的Bundle-Identifier" class="headerlink" title="3.创建App IDs和绑定你的App的Bundle Identifier"></a>3.创建App IDs和绑定你的App的Bundle Identifier</h4><blockquote><p>回到刚才的页面：<a href="https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action" target="_blank" rel="external">https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action</a>    </p><ol><li>点击App IDs,进入如下界面，点击右上角的 + 号<br><img src="http://oui2ar2u7.bkt.clouddn.com/p129.png" alt="">  </li></ol><p>2.填写App IDs和Bundle Identifier<br><img src="http://oui2ar2u7.bkt.clouddn.com/p140.png" alt=""><br><strong>注意：</strong><br>a. 上传App使用的Bundle Identifier(不要有-，都是英文+数字)必须是固定的，不能使用占位符。<br>b. 如果你的Bundle Identifier已经在网站上绑定了，如果你又修改了你工程里面这个Bundle Identifier的话，需要重新进入到开发者账号里面绑定。<br><img src="http://oui2ar2u7.bkt.clouddn.com/p68.png" alt=""><br>下面选择App中包含的服务，默认有两项，其余的根据自己项目的需求进行选择<br><img src="http://oui2ar2u7.bkt.clouddn.com/p124.png" alt="">  </p><p>3.点击continue<br><img src="http://oui2ar2u7.bkt.clouddn.com/p109.png" alt="">  </p><p>4.点击Register<br><img src="http://oui2ar2u7.bkt.clouddn.com/p130.png" alt="">  </p><p>5.点击Done<br><img src="http://oui2ar2u7.bkt.clouddn.com/p67.png" alt=""></p></blockquote><h4 id="4-生成描述文件（描述文件的作用就是把证书和Bundle-Identifier关联起来）"><a href="#4-生成描述文件（描述文件的作用就是把证书和Bundle-Identifier关联起来）" class="headerlink" title="4.生成描述文件（描述文件的作用就是把证书和Bundle Identifier关联起来）"></a>4.生成描述文件（描述文件的作用就是把证书和Bundle Identifier关联起来）</h4><blockquote><p>1.找到Provisioning Profiles ，点击All，然后点击右上角 + 号<br><img src="http://oui2ar2u7.bkt.clouddn.com/p111.png" alt="">  </p><p>2.因为是发布，所以选择下面App Store这个描述文件，点击Continue<br><img src="http://oui2ar2u7.bkt.clouddn.com/p87.png" alt="">    </p><p>3.在App ID 这个选项栏里面找到你刚刚创建的：App IDs（Bundle Identifier） 类型的套装，点击Continue<br><img src="http://oui2ar2u7.bkt.clouddn.com/p70.png" alt="">  </p><p>4.选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue<br><img src="http://oui2ar2u7.bkt.clouddn.com/p82.png" alt="">  </p><p>5.在Profile Name栏里输入一个名字（这个是PP文件的名字，可随便输入，在这里用工程名字，便于分别），然后点击Generate<br><img src="http://oui2ar2u7.bkt.clouddn.com/p95.png" alt="">  </p><p>6.Download生成的PP文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p126.png" alt="">  </p><p>Download生成的PP文件(生成的描述文件)<br><img src="http://oui2ar2u7.bkt.clouddn.com/p102.png" alt=""></p></blockquote><h4 id="5-在App-Store开辟空间"><a href="#5-在App-Store开辟空间" class="headerlink" title="5.在App Store开辟空间"></a>5.在App Store开辟空间</h4><blockquote><p>1.回到Member Center，点击iTunes Connect<br><img src="http://oui2ar2u7.bkt.clouddn.com/p78.png" alt=""></p><p>2.回到Member Center，点击iTunes Connect<br><img src="http://oui2ar2u7.bkt.clouddn.com/p128.png" alt=""></p><p>3.登录成功后，点击我的App<br><img src="http://oui2ar2u7.bkt.clouddn.com/p112.png" alt=""></p><p>4.点击左上角那个＋号，点击新建(注意：我们是iOS App开发，不要选Mac App啦）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p101.png" alt="">  </p><p>5.依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建<br><img src="http://oui2ar2u7.bkt.clouddn.com/p131.png" alt=""><br><strong>注意</strong>：如果都填好以后，可能会告诉你，你的App名称已经被占用，那么不好意思，你只能改名了！（而且建议大家起名不要往比较出名的App上靠，否则审核可能会被拒绝）</p><p>6.填写App其它信息<br><img src="http://oui2ar2u7.bkt.clouddn.com/p113.png" alt=""></p><p>7.填写价格和销售范围（由于开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p92.png" alt=""></p><p>8.依次把不同尺寸的App截图拉入到对应的里面<br>需要填写不同尺寸的手机屏幕截图（也就是拿不同尺寸的模拟器运行后，挑出至少3页最多5页进行截图然后拖到响应的区里）（在模拟器Command＋S 就可以保存屏幕截图到桌面了）（注意：如果提示拖进去的图片尺寸不对，则把模拟器弄成100%然后再Command + S) 尺寸参照表在下面<br><img src="http://oui2ar2u7.bkt.clouddn.com/p144.png" alt=""><br>尺寸参照图<br><img src="http://oui2ar2u7.bkt.clouddn.com/p86.png" alt=""></p><p>9.填写App简介<br><img src="http://oui2ar2u7.bkt.clouddn.com/p117.png" alt=""></p><p>10.按提示依次输入<br><img src="http://oui2ar2u7.bkt.clouddn.com/p125.png" alt=""><br>错误提示：如果上传App 图标失败，提示Alpha错误的话，看下面。<br>打开你的图标图片，勾掉这个<br><img src="http://oui2ar2u7.bkt.clouddn.com/p69.png" alt=""></p><p>11.点击分级后面的编辑，如实填写后，点击完成<br><img src="http://oui2ar2u7.bkt.clouddn.com/p127.png" alt=""></p><p>12.填写审核信息<br><img src="http://oui2ar2u7.bkt.clouddn.com/p136.png" alt=""><br>版本发布就是：（然后最下面选择自动发布的话就是如果审核通过，就自动上传到App Store供人下载）</p><p>13.此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。<br><strong>注意</strong>：填写完一定要点击右上角的保存。</p></blockquote><h4 id="6-在Xcode中打包工程"><a href="#6-在Xcode中打包工程" class="headerlink" title="6.在Xcode中打包工程"></a>6.在Xcode中打包工程</h4><blockquote><p><strong>找到你刚刚下载的发布证书（后缀为.cer）或者p12文件，和PP文件，双击，看起来没反应，但是他们已经加入到你的钥匙串中。</strong><br>1.在Xcode中选择iOS Device(这里不能选择模拟器)，按照下图提示操作<br><img src="http://oui2ar2u7.bkt.clouddn.com/p145.png" alt=""></p><p>2.如果你的应用不支持横屏，把这两个勾去掉<br><img src="http://oui2ar2u7.bkt.clouddn.com/p66.png" alt=""></p><p>3.查看版本号和构建版本号<br><img src="http://oui2ar2u7.bkt.clouddn.com/p110.png" alt=""></p><p>4.配置发布证书(ps:截图时选择的证书是错误的，大家注意一下，要选择发布证书)<br><img src="http://oui2ar2u7.bkt.clouddn.com/p123.png" alt=""><br><strong>注意</strong>：如果这里没有黄色叹号，代表你的配置没问题，如果有，那就是证书和描述文件不匹配，或者描述文件里刚才选的Bundle和现在的工程的Bundle Identifier不一致，去develop.apple.com 上找到你的描述文件在确认下绑定的bundle Identifier和你工程是不是一样的？<br><img src="http://oui2ar2u7.bkt.clouddn.com/p107.png" alt=""></p><p>5.将<strong>断点、全局断点，僵尸模式</strong>等都要去掉。<br><img src="http://oui2ar2u7.bkt.clouddn.com/p122.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p133.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p148.png" alt=""></p><p>6.设置Release模式（Debug是测试的，Release是发布用的）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p91.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p90.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p120.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p106.png" alt=""> </p><p>7.选择 Xcode下 Product 下 Archive（专门用于传项目，或者打包项目）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p114.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p98.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/p79.png" alt=""></p><p>8.出现下图说明你没有添加开发者账号，点击右下脚Add… 按钮就可以添加<br><img src="http://oui2ar2u7.bkt.clouddn.com/p150.png" alt="">  </p><p>9.输入付费的开发者账号<br><img src="http://oui2ar2u7.bkt.clouddn.com/p89.png" alt=""><br>可能会弹出下面这个界面，如果不弹出，按Command加。<br><img src="http://oui2ar2u7.bkt.clouddn.com/p83.png" alt=""></p><p>10.然后回到Archive(选择已付费的账号)，然后点击Choose<br><img src="http://oui2ar2u7.bkt.clouddn.com/p135.png" alt=""><br>然后等待<br><img src="http://oui2ar2u7.bkt.clouddn.com/p142.png" alt="">  </p><p>11.选择Upload提交<br><img src="http://oui2ar2u7.bkt.clouddn.com/p132.png" alt=""></p><p>12.如下就代表上传成功，如果出错，请参照<a href="http://www.jianshu.com/p/9195cd991fc7" target="_blank" rel="external">iOS App上传项目遇到的问题</a><br><img src="http://oui2ar2u7.bkt.clouddn.com/p94.png" alt=""></p><p>13.返回ItunesConnect网站上你自己的App信息中查看一下<br><img src="http://oui2ar2u7.bkt.clouddn.com/p105.png" alt=""></p><p>14.在这个构建版本这里就可以添加代码<br><img src="http://oui2ar2u7.bkt.clouddn.com/p151.png" alt=""><br>点击＋号之后选择代码版本<br><img src="http://oui2ar2u7.bkt.clouddn.com/p103.png" alt="">  </p><p>15.提交以供审核<br><img src="http://oui2ar2u7.bkt.clouddn.com/p72.png" alt=""></p><p>16.App已经从准备提交，变成正在等待审核状态<br><img src="http://oui2ar2u7.bkt.clouddn.com/p100.png" alt=""></p><p>17.等待苹果的审核…</p></blockquote><h4 id="7-补充"><a href="#7-补充" class="headerlink" title="7.补充"></a>7.补充</h4><blockquote><p><strong>1、构建版本的方法有两种，一种是使用 Xcode(上面已经介绍了)，另一种就是使用一个叫 Application Loader 这个软件：</strong><br><img src="http://oui2ar2u7.bkt.clouddn.com/p115.png" alt=""></p><blockquote><p>1.使用Xcode构建版本：<br>上面已经介绍（已经Archive的话，可以在Xcode: Window -&gt; Organizer 进入）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p77.png" alt=""><br>2.使用Application Loader 构建版本：</p><ul><li>如上图，点击“Export…”，导出一个ipa文件（ps:为了保险起见、让苹果审核顺利一点，这里可以先点击“Validate…”来验证一下，这里就懒得验证了）</li><li>Application Loader下载Xcode的时候就已经下载了（没有的请自行下载），Xcode 右键弹出下面界面<br><img src="http://oui2ar2u7.bkt.clouddn.com/p75.png" alt=""><br>打开Application Loader（如果没有登录，会提示你登录你的开发者账号）<br><img src="http://oui2ar2u7.bkt.clouddn.com/p152.png" alt=""><br>选取你导出的ipa文件（或者双击“交付您的应用程序”选取ipa文件），之后按提示操作就行，上传完毕没有报错的话，过几分钟左右就可以在iTunes Connect 里面就可以看到你上传的这个版本了。<br><img src="http://oui2ar2u7.bkt.clouddn.com/p103.png" alt="">  </li></ul><blockquote><p>建议构建版本使用Application Loader上传</p></blockquote></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-准备&quot;&gt;&lt;a href=&quot;#1-准备&quot; class=&quot;headerlink&quot; title=&quot;1.准备&quot;&gt;&lt;/a&gt;1.准备&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1.一个已付费的开发者账号（账号类型分为个人（Individual）、公司（Company）、企业
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发证书总结</title>
    <link href="http://yoursite.com/2017/10/22/iOS%E5%BC%80%E5%8F%91%E8%AF%81%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/22/iOS开发证书总结/</id>
    <published>2017-10-22T08:17:53.000Z</published>
    <updated>2017-10-22T12:29:09.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS证书"><a href="#iOS证书" class="headerlink" title="iOS证书"></a>iOS证书</h3><h4 id="iOS开发者账号的分类"><a href="#iOS开发者账号的分类" class="headerlink" title="iOS开发者账号的分类"></a>iOS开发者账号的分类</h4><blockquote><p>iOS开发者帐号分为两种： </p><ul><li>1.个人帐号／公司帐号：$99/年，能够上传App Store，不能够打包直接在设备上运行。（公司帐号可以创建多个子账号，其他和个人帐号没有区别）。</li><li>2.企业帐号：$299/年，不能上传到App Store，可以在企业内部分发(用这种证书打出来的包能在任何iOS设备上运行，不需要苹果的验证、签名)。</li></ul></blockquote><h4 id="iOS应用发布方式"><a href="#iOS应用发布方式" class="headerlink" title="iOS应用发布方式"></a>iOS应用发布方式</h4><blockquote><ul><li>1、App Store：苹果应用商店，普通iOS用户都可以在App Store上下载应用。  </li><li>2、In-House:企业内部分发，通过企业证书打包并选择In-House方式打包，可以将打包完的ipa装到任意符合应用安装要求的设备上，不需要苹果的验证和签名。  </li><li>3、AD-Hoc:两种开发这帐号均可以选择AD-Hoc方式打包，可以将打包完的ipa装到任意符合应用安装要求的设备上。和In-House方式不同，这种方式限定安装设备的数量，并且设备需要在开发这帐号中注册。  </li></ul></blockquote><h4 id="证书成员介绍"><a href="#证书成员介绍" class="headerlink" title="证书成员介绍"></a>证书成员介绍</h4><blockquote><p><strong>1.Certification(证书)</strong>  </p><blockquote><p>证书是对电脑开发资格的认证，每个开发者帐号有一套，分为两种：<br>1)Developer Certification(开发证书)  </p><blockquote><p>安装在电脑上提供权限：开发人员通过设备进行真机测试。<br>可以生成副本供多台电脑安装；</p></blockquote><p>2)Distribution Certification(发布证书)</p><blockquote><p>安装在电脑上提供发布iOS程序的权限：开发人员可以制做测试版和发布版的程序。不可生成副本，仅有配置该证书的电脑才可使用；  </p></blockquote></blockquote><p><strong>2.Provisioning Profile(授权文件)</strong>  </p><blockquote><p>授权文件是对设备如iPod Touch、iPad、iPhone的授权，文件内记录的是设备的UDID和程序的App Id，即：使被授权的设备可以安装或调试Bundle identifier与授权文件中记录的App Id对应的程序。<br>开发者帐号在创建授权文件时候会选择App Id，（开发者帐号下App Id中添加，单选）和UDID（开发者帐号下Devices中添加最多100个，多选）。<br>授权文件分为两种，对应相应的证书使用：<br>1)Developer Provisioning Profile(开发授权文件)  </p><blockquote><p>在装有开发证书或副本的电脑上使用，开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中，即可进行真机测试。<br>注意：确保电脑有权限真机调试，即安装了开发证书或副本；在开发工具中程序的Bundle identifier和选中使用的授权文件的App Id要一致；连接调试的设备的UDID在选中的授权文件中有记录。 </p></blockquote><p>2)Distribution Provisioning Profile(发布授权文件)   </p><blockquote><p>在装有发布证书的电脑上（即配置证书的电脑，只有一台）制做测试版和发布版的程序。<br>发布版就是发布到App Store上的程序文件，开发者帐号创建授权文件时选择store选项，选择App Id，无需选择UDID；<br>测试版就是在发布之前交给测试人员可同步到设备上的程序文件，开发者帐号创建授权文件时选择AdHoc，选择App Id和UDID；只有选中的UDID对应的设备才可能安装上通过该授权文件制做的程序。 </p></blockquote></blockquote><p><strong>3. Keychain(开发密钥)</strong></p><blockquote><p>安装证书成功的情况下证书下都会生成Keychain，上面提到的证书副本（导出证书重新命名）就是通过配置证书的电脑导出Keychain（就是.p12文件）安装到其他机子上，让其他机子得到证书对应的权限。Developer Certification就可以制做副本Keychain分发到其他电脑上安装，使其可以进行真机测试。<br>注意：Distribution Certification只有配置证书的电脑才可使用，因此即使导出导出Keychain安装到其他电脑上，其他电脑也不可能具有证书的权限。  </p></blockquote></blockquote><h4 id="证书申请流程"><a href="#证书申请流程" class="headerlink" title="证书申请流程"></a>证书申请流程</h4><blockquote><p>1、登录（99美元账号）<a href="https://developer.apple.com" target="_blank" rel="external">https://developer.apple.com</a><br><img src="http://oui2ar2u7.bkt.clouddn.com/p61.jpeg" alt=""></p><blockquote><p>1) 登录成功后在页面右侧选择“Certificates”：<br><img src="http://oui2ar2u7.bkt.clouddn.com/p48.png" alt="">  </p><p>2)打开之后可以看到面板：<br><img src="http://oui2ar2u7.bkt.clouddn.com/p62.png" alt=""></p></blockquote><p>2、生成CSR文件</p><blockquote><p>1) 打开 -&gt;钥匙串访问<br><img src="http://oui2ar2u7.bkt.clouddn.com/p65.png" alt="">  </p><p>2）打开右上方钥匙串访问栏-&gt;证书助理-&gt;从证书颁发机构请求证书…<br><img src="http://oui2ar2u7.bkt.clouddn.com/p56.png" alt="">  </p><p>3) 用户邮件地址填写开发者账号的邮箱地址，CA地址不填，选择“存储到磁盘”，点击继续，完成了。<br><img src="http://oui2ar2u7.bkt.clouddn.com/p51.png" alt=""><br>申请成功后的文件：<br><img src="http://oui2ar2u7.bkt.clouddn.com/p58.png" alt=""> </p></blockquote><p>3、注册 App ID 流程</p><blockquote><p>1) 点面板中的App IDs 右上角的加号。然后填写App ID的名字：<br><img src="http://oui2ar2u7.bkt.clouddn.com/p60.png" alt=""> </p><p>2) 填写bundle ID:<br><img src="http://oui2ar2u7.bkt.clouddn.com/p53.png" alt=""> </p><p>3)选择App需要支持的服务，（如：app耍要推送服务，就勾选Push Notifications)<br><img src="http://oui2ar2u7.bkt.clouddn.com/p49.png" alt=""> </p><p>4)最后会有一个详细的内容列表，对应无误后，提交完成。  </p></blockquote><p>4、证书申请</p><blockquote><p>1) 选择证书的类型，下面罗列我们iOS开发常用的证书类型<br><img src="http://oui2ar2u7.bkt.clouddn.com/p54.png" alt="">  </p><p>2) 如果是申请推送证书，则会关联一个App ID<br><img src="http://oui2ar2u7.bkt.clouddn.com/p57.png" alt=""></p><p>3) 上传我们之前建好的CSR文件<br><img src="http://oui2ar2u7.bkt.clouddn.com/p59.png" alt="">  </p><p>到此为止，你完成了证书的申请，简单吧。</p></blockquote><p>5、授权文件申请（Provisioning Profile）  </p><blockquote><p>1) 选择授权文件类型，下面罗列了iOS常的授权文件类型<br><img src="http://oui2ar2u7.bkt.clouddn.com/p50.png" alt="">  </p><p>2)选择关联App ID<br><img src="http://oui2ar2u7.bkt.clouddn.com/p55.png" alt="">  </p><p>3)选择关联的证书<br><img src="http://oui2ar2u7.bkt.clouddn.com/p52.png" alt="">  </p><p>4）选择授权的设备（通过 UDID），除了企业证书（inHouse）外，只有你添加的设备才能进行调度或测试<br><img src="http://oui2ar2u7.bkt.clouddn.com/p63.png" alt="">  </p><p>5) 给授权文件命一个能和其它授权文件区分的名字<br><img src="http://oui2ar2u7.bkt.clouddn.com/p64.png" alt=""></p><p>到此为止，授权文件申请完成了，简单吧。</p></blockquote></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1) Development是调试证书， Production是发布证书<br>2)成功安装测试证书的条件：a).开发者证书+私钥。 b).授权文件。<br>3)如果你想通过证书进行真机调试，请选择开发版证书(Development Certificate)，和相应的授权文件(Development Provisioning Profile) 。<br>4)如果你想让更多的开发者能进行真机调试，请先对需要真机调试的设备进行授权，然后将开发版证书(Development Certificate)下载到本机安装后导出为带私的.p12的文件，和相应的授权文件(Development Provisioning Profile)交由开发者安装，成功后即可进行真机调试。<br>5)如果你想让更多的机子进行真机测试，请先对需要测试的设备进行授权，然后选择生产版证书(<code>Distribution Ad_hoc Certificate</code>)和相应的授权文件(<code>Distribution Ad_hoc Provisioning Profile</code>)打包后分发给要测试的设备即可。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iOS证书&quot;&gt;&lt;a href=&quot;#iOS证书&quot; class=&quot;headerlink&quot; title=&quot;iOS证书&quot;&gt;&lt;/a&gt;iOS证书&lt;/h3&gt;&lt;h4 id=&quot;iOS开发者账号的分类&quot;&gt;&lt;a href=&quot;#iOS开发者账号的分类&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Quartz2D绘图演练</title>
    <link href="http://yoursite.com/2017/10/21/Quartz2D%E7%BB%98%E5%9B%BE%E6%BC%94%E7%BB%83/"/>
    <id>http://yoursite.com/2017/10/21/Quartz2D绘图演练/</id>
    <published>2017-10-21T15:51:42.000Z</published>
    <updated>2017-10-22T04:11:27.703Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是Quartz2D-二维的绘图引擎"><a href="#1、什么是Quartz2D-二维的绘图引擎" class="headerlink" title="1、什么是Quartz2D?二维的绘图引擎"></a>1、什么是Quartz2D?二维的绘图引擎</h4><blockquote><p>Quartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统，用Quartz2D写的同一份代码，既可以运行在iphone上又可以运行在mac上，可以跨平台开发。 开发中比较常用的是截屏/裁剪/自定义UI控件。 Quartz2D在iOS开发中的价值就是自定义UI控件。</p></blockquote><h4 id="2、Quartz-2D能完成的工作"><a href="#2、Quartz-2D能完成的工作" class="headerlink" title="2、Quartz 2D能完成的工作"></a>2、Quartz 2D能完成的工作</h4><blockquote><p>绘制图形 : 线条\三角形\矩形\圆\弧等<br>绘制文字<br>绘制\生成图片(图像)<br>读取\生成PDF<br>截图\裁剪图片<br>自定义UI控件… …  </p></blockquote><h4 id="3、图形上下文的数据类型"><a href="#3、图形上下文的数据类型" class="headerlink" title="3、图形上下文的数据类型"></a>3、图形上下文的数据类型</h4><blockquote><p>图形上下文（Graphics Context）：是一个<strong>CGContextRef</strong>类型的数据</p></blockquote><h4 id="4、图形上下文的作用"><a href="#4、图形上下文的作用" class="headerlink" title="4、图形上下文的作用"></a>4、图形上下文的作用</h4><blockquote><p>保存绘图信息、绘图状态<br>决定绘制的输出目标（绘制到什么地方去？）<br>(输出目标可以是PDF文件、Bitmap或者显示器的窗口上)</p></blockquote><h4 id="5、有多少种上下文。"><a href="#5、有多少种上下文。" class="headerlink" title="5、有多少种上下文。"></a>5、有多少种上下文。</h4><blockquote><p>Bitmap Graphics Context<br>PDF Graphics Context<br>Window Graphics Context<br>Layer Graphics Context<br>Printer Graphics Context  </p></blockquote><h4 id="6、只有在drawRect-方法中才能获取到上下文，当你视图第一次显示的时候就会调用-当你要手动刷新屏幕的时候，执行-self-setNeedsDisplay-就会调用drawRect"><a href="#6、只有在drawRect-方法中才能获取到上下文，当你视图第一次显示的时候就会调用-当你要手动刷新屏幕的时候，执行-self-setNeedsDisplay-就会调用drawRect" class="headerlink" title="6、只有在drawRect:方法中才能获取到上下文，当你视图第一次显示的时候就会调用;当你要手动刷新屏幕的时候，执行[self setNeedsDisplay]就会调用drawRect."></a>6、只有在drawRect:方法中才能获取到上下文，当你视图第一次显示的时候就会调用;当你要手动刷新屏幕的时候，执行<code>[self setNeedsDisplay]</code>就会调用drawRect.</h4><h4 id="7、Quartz2D绘图演练"><a href="#7、Quartz2D绘图演练" class="headerlink" title="7、Quartz2D绘图演练"></a>7、Quartz2D绘图演练</h4><blockquote><p>绘制线段  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.获取上下文</span></div><div class="line"><span class="comment">// CGContextRef CG CoreGraphics Ref 引用</span></div><div class="line"><span class="comment">// 目前学的上下文都跟UIGraphics有关，以后想直接获取上下文，直接敲一个UIGraphics</span></div><div class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line"><span class="comment">// 2.设置绘图信息(拼接路径)</span></div><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line"><span class="comment">// 设置起点</span></div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>)];</div><div class="line">    </div><div class="line"><span class="comment">// 添加一条线到某个点</span></div><div class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>, <span class="number">125</span>)];</div><div class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">240</span>, <span class="number">10</span>)];</div><div class="line"><span class="comment">// 3.把路径添加到上下文</span></div><div class="line"><span class="comment">// 直接把UIKit的路径转换成CoreGraphics，CG开头就能转</span></div><div class="line"><span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line"><span class="comment">// 4.把上下文渲染到视图</span></div><div class="line"><span class="comment">// Stroke描边</span></div><div class="line"><span class="built_in">CGContextStrokePath</span>(ctx);</div></pre></td></tr></table></figure><p>画文字  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">NSString</span> *text = <span class="string">@"hello motolosdmotolosdmotolosdmotolosdmotolosdmotolosdmotolosdmotolosdmotolosdmotolosdmotolosdmotolosdmotolosd"</span>;</div><div class="line"><span class="built_in">CGRect</span> textFrame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">250</span>, <span class="number">250</span>);</div><div class="line">    </div><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">20</span>],<span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor],<span class="built_in">NSStrokeWidthAttributeName</span> : @<span class="number">5</span>&#125;;</div><div class="line"><span class="comment">//UIRectFill(textFrame);</span></div><div class="line"><span class="comment">//[text drawInRect:textFrame withAttributes:dict];</span></div><div class="line">    </div><div class="line"><span class="comment">/*</span></div><div class="line">  text drawInRect:textFrame withAttributes:dict]; 会自动换行</div><div class="line">  [text drawAtPoint:CGPointZero withAttributes:dict]; 不会自动换行</div><div class="line">*/</div><div class="line">[text drawAtPoint:<span class="built_in">CGPointZero</span> withAttributes:dict];</div></pre></td></tr></table></figure><p>画图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Drawing code</span></div><div class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"头像"</span>];</div><div class="line">    </div><div class="line"><span class="comment">//[image drawAtPoint:CGPointZero];</span></div><div class="line">    </div><div class="line"><span class="comment">//[image drawInRect:CGRectMake(0, 0, 100, 100)];</span></div><div class="line">    </div><div class="line"><span class="comment">// 设置裁剪区域，超出裁剪区域的都会被裁剪掉</span></div><div class="line"><span class="built_in">UIRectClip</span>(<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>));</div><div class="line">    </div><div class="line"><span class="built_in">UIImage</span> *pImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"001"</span>];</div><div class="line">[pImage drawAsPatternInRect:rect];</div></pre></td></tr></table></figure><p>画曲线  3个点，起点，终点，控制点。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// 1.获取上下文</span></div><div class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line"><span class="comment">// 2.拼接路径</span></div><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line"><span class="built_in">CGPoint</span> startP = <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">125</span>);</div><div class="line"><span class="built_in">CGPoint</span> endP = <span class="built_in">CGPointMake</span>(<span class="number">240</span>, <span class="number">125</span>);</div><div class="line"><span class="built_in">CGPoint</span> controlP = <span class="built_in">CGPointMake</span>(<span class="number">125</span>, <span class="number">0</span>);</div><div class="line">[path moveToPoint:startP];</div><div class="line">[path addQuadCurveToPoint:endP controlPoint:controlP];</div><div class="line">    </div><div class="line"><span class="comment">// 3.把路径添加到上下文</span></div><div class="line"><span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line"><span class="comment">// 4.渲染上下文到视图</span></div><div class="line"><span class="built_in">CGContextStrokePath</span>(ctx);</div></pre></td></tr></table></figure></blockquote><h4 id="8、CADisplayLink"><a href="#8、CADisplayLink" class="headerlink" title="8、CADisplayLink"></a>8、CADisplayLink</h4><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iphone每秒刷新60次</span></div><div class="line"><span class="comment">// 屏幕刷新的时候就会触发</span></div><div class="line"><span class="built_in">CADisplayLink</span> *link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setNeedsDisplay)];</div><div class="line">    </div><div class="line">[link addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div></pre></td></tr></table></figure></blockquote><h4 id="9、图形上下文的栈"><a href="#9、图形上下文的栈" class="headerlink" title="9、图形上下文的栈"></a>9、图形上下文的栈</h4><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.获取上下文</span></div><div class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line"><span class="comment">// 把ctx拷贝一份放在栈中</span></div><div class="line"><span class="built_in">CGContextSaveGState</span>(ctx);</div><div class="line">    </div><div class="line"><span class="comment">// 2.拼接路径（绘图的信息）</span></div><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">125</span>)];</div><div class="line">[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">240</span>, <span class="number">125</span>)];</div><div class="line">    </div><div class="line"><span class="comment">// 3.路径添加到上下文</span></div><div class="line"><span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line"><span class="comment">// 设置绘图的状态</span></div><div class="line">[[<span class="built_in">UIColor</span> redColor] set];</div><div class="line"><span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">10</span>);</div><div class="line"><span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);</div><div class="line">    </div><div class="line"><span class="comment">// 4.渲染</span></div><div class="line"><span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment">// 第二根线</span></div><div class="line"><span class="built_in">UIBezierPath</span> *path1 = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">[path1 moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>, <span class="number">10</span>)];</div><div class="line">[path1 addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>, <span class="number">240</span>)];</div><div class="line"><span class="built_in">CGContextAddPath</span>(ctx, path1.CGPath);</div><div class="line">    </div><div class="line"><span class="comment">// 把栈顶上下文取出来，替换当前上下文</span></div><div class="line"><span class="built_in">CGContextRestoreGState</span>(ctx);</div><div class="line">    </div><div class="line"><span class="comment">// 设置绘图的状态</span></div><div class="line"><span class="comment">//[[UIColor blackColor] set];</span></div><div class="line"><span class="comment">//CGContextSetLineWidth(ctx, 1);</span></div><div class="line"><span class="comment">//CGContextSetLineCap(ctx, kCGLineCapButt);</span></div><div class="line">    </div><div class="line"><span class="comment">// 4.渲染</span></div><div class="line"><span class="built_in">CGContextStrokePath</span>(ctx);</div></pre></td></tr></table></figure></blockquote><h4 id="10、图形上下文的矩阵操作"><a href="#10、图形上下文的矩阵操作" class="headerlink" title="10、图形上下文的矩阵操作"></a>10、图形上下文的矩阵操作</h4><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.获取上下文</span></div><div class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line"><span class="comment">// 注意：你的路径一定放在上下文矩阵操作之后</span></div><div class="line"><span class="comment">// 平移上下文</span></div><div class="line"><span class="built_in">CGContextTranslateCTM</span>(ctx, <span class="number">50</span>, <span class="number">100</span>);</div><div class="line">    </div><div class="line"><span class="comment">// 旋转上下文</span></div><div class="line"><span class="built_in">CGContextRotateCTM</span>(ctx, M_PI_4);</div><div class="line">    </div><div class="line"><span class="comment">// 缩放上下文</span></div><div class="line"><span class="built_in">CGContextScaleCTM</span>(ctx, <span class="number">0.5</span>, <span class="number">1.2</span>);</div><div class="line">    </div><div class="line"><span class="comment">// 2.拼接路径</span></div><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">-50</span>, <span class="number">-100</span>, <span class="number">150</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line"><span class="comment">// 3.把路径添加到上下文</span></div><div class="line"><span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">       </div><div class="line">[[<span class="built_in">UIColor</span> yellowColor] set];</div><div class="line">    </div><div class="line"><span class="comment">// 4.渲染</span></div><div class="line"><span class="built_in">CGContextFillPath</span>(ctx);</div></pre></td></tr></table></figure></blockquote><h4 id="11、图片裁剪"><a href="#11、图片裁剪" class="headerlink" title="11、图片裁剪"></a>11、图片裁剪</h4><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)imageWithName:(<span class="built_in">NSString</span> *)name border:(<span class="built_in">CGFloat</span>)border borderColor:(<span class="built_in">UIColor</span> *)color</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 圆环的宽度</span></div><div class="line">    <span class="built_in">CGFloat</span> borderW = border;</div><div class="line">    </div><div class="line">    <span class="comment">// 加载旧的图片</span></div><div class="line">    <span class="built_in">UIImage</span> *oldImage =  [<span class="built_in">UIImage</span> imageNamed:name];</div><div class="line">    </div><div class="line">    <span class="comment">// 新的图片尺寸</span></div><div class="line">    <span class="built_in">CGFloat</span> imageW = oldImage.size.width + <span class="number">2</span> * borderW;</div><div class="line">    <span class="built_in">CGFloat</span> imageH = oldImage.size.height + <span class="number">2</span> * borderW;</div><div class="line">    </div><div class="line">    <span class="comment">// 设置新的图片尺寸</span></div><div class="line">    <span class="built_in">CGFloat</span> circirW = imageW &gt; imageH ? imageH : imageW;</div><div class="line">    </div><div class="line">    <span class="comment">// 开启上下文</span></div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSizeMake</span>(circirW, circirW), <span class="literal">NO</span>, <span class="number">0.0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 画大圆</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, circirW, circirW)];</div><div class="line">    </div><div class="line">    <span class="comment">// 获取当前上下文</span></div><div class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 添加到上下文</span></div><div class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line">    <span class="comment">// 设置颜色</span></div><div class="line">    [color set];</div><div class="line">    </div><div class="line">    <span class="comment">// 渲染</span></div><div class="line">    <span class="built_in">CGContextFillPath</span>(ctx);</div><div class="line">    </div><div class="line">    <span class="built_in">CGRect</span> clipR = <span class="built_in">CGRectMake</span>(borderW, borderW, oldImage.size.width, oldImage.size.height);</div><div class="line">    </div><div class="line">    <span class="comment">// 画圆：正切于旧图片的圆</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *clipPath = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:clipR];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置裁剪区域</span></div><div class="line">    [clipPath addClip];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 画图片</span></div><div class="line">    [oldImage drawAtPoint:<span class="built_in">CGPointMake</span>(borderW, borderW)];</div><div class="line">    </div><div class="line">    <span class="comment">// 获取新的图片</span></div><div class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 关闭上下文</span></div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> newImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h4 id="12、屏幕截屏"><a href="#12、屏幕截屏" class="headerlink" title="12、屏幕截屏"></a>12、屏幕截屏</h4><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 开启上下文</span></div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.view.bounds.size, <span class="literal">NO</span>, <span class="number">0.0</span>);</div><div class="line">    </div><div class="line"><span class="comment">// 获取上下文</span></div><div class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line"><span class="comment">// 渲染控制器view的图层到上下文</span></div><div class="line"><span class="comment">// 图层只能用渲染不能用draw</span></div><div class="line">[<span class="keyword">self</span>.view.layer renderInContext:ctx];</div><div class="line">    </div><div class="line"><span class="comment">// 获取截屏图片</span></div><div class="line"><span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    </div><div class="line"><span class="comment">// 关闭上下文</span></div><div class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    </div><div class="line"><span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(newImage);</div><div class="line">    </div><div class="line">[data writeToFile:<span class="string">@"/Users/apple/Desktop/layer.png"</span> atomically:<span class="literal">YES</span>];</div></pre></td></tr></table></figure></blockquote><h4 id="13、给图片添加水印"><a href="#13、给图片添加水印" class="headerlink" title="13、给图片添加水印"></a>13、给图片添加水印</h4><blockquote><pre><code class="objectivec"><span class="built_in">UIImage</span> *oldImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"img"</span>];<span class="comment">// 开启上下文</span><span class="comment">// size 新的图片大小</span><span class="comment">// opaque YES 不透明 NO 透明   UIGraphicsBeginImageContextWithOptions(oldImage.size, NO, 0.0);</span>[oldImage drawAtPoint:<span class="built_in">CGPointZero</span>];   <span class="built_in">NSString</span> *text =  <span class="string">@"我要高薪 ！"</span>;<span class="built_in">NSDictionary</span> *dict = @{<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>],<span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor]};[text drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">120</span>, <span class="number">170</span>) withAttributes:dict];  <span class="comment">// 获取新的图片</span><span class="built_in">UIImage</span> *newImage =  <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();    <span class="comment">// 关闭上下文</span><span class="built_in">UIGraphicsEndImageContext</span>();   _imageView.image = newImage;  <span class="comment">// 把图片转换成png格式的二进制数据</span><span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(newImage);<span class="comment">// 写入桌面</span>[data writeToFile:<span class="string">@"/Users/apple/Desktop/newImage.png"</span> atomically:<span class="literal">YES</span>];</code></pre></blockquote><h4 id="14-其他"><a href="#14-其他" class="headerlink" title="14.其他"></a>14.其他</h4><blockquote><ul><li>画路线是不用获取context   </li><li>注意：如果view类中没有设置过backgroundcolor，再在drawRect中绘制就会重叠。或者更改颜色，如：[[UIColor whiteColor] set];也会有问题。先设置一下该view的backgroundcolor问题解决了。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、什么是Quartz2D-二维的绘图引擎&quot;&gt;&lt;a href=&quot;#1、什么是Quartz2D-二维的绘图引擎&quot; class=&quot;headerlink&quot; title=&quot;1、什么是Quartz2D?二维的绘图引擎&quot;&gt;&lt;/a&gt;1、什么是Quartz2D?二维的绘图引擎&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Core Animation 核心动画</title>
    <link href="http://yoursite.com/2017/10/21/Core-Animation-%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/10/21/Core-Animation-核心动画/</id>
    <published>2017-10-21T15:32:50.000Z</published>
    <updated>2017-10-21T16:26:27.566Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、position-anchorPoint"><a href="#1、position-anchorPoint" class="headerlink" title="1、position anchorPoint"></a>1、position anchorPoint</h4><blockquote><p>CALayer有2个非常重要的属性：position和anchorPoint  </p><blockquote><p>@property CGPoint position;  </p><blockquote><p>用来设置CALayer在父层中的位置<br>以父层的左上角为原点(0, 0)  </p></blockquote><p>@property CGPoint anchorPoint;  </p><blockquote><p>称为“定位点”、“锚点”<br>决定着CALayer身上的哪个点会在position属性所指的位置<br>以自己的左上角为原点(0, 0)<br>它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间<br>锚点所指的点就是position的位置  </p></blockquote></blockquote></blockquote><h4 id="2、CATransform3DMakeRotation-angle-x-y-z"><a href="#2、CATransform3DMakeRotation-angle-x-y-z" class="headerlink" title="2、CATransform3DMakeRotation(angle, x, y, z)"></a>2、CATransform3DMakeRotation(angle, x, y, z)</h4><blockquote><p>x、y、z的取值范围是[0,1]<br>设置了之后layer就会以原点与(x,y,z)的线为轴旋转angle的角度</p></blockquote><h4 id="3、CABasicAnimation"><a href="#3、CABasicAnimation" class="headerlink" title="3、CABasicAnimation"></a>3、CABasicAnimation</h4><blockquote><p>fillMode的作用就是决定当前对象过了非active时间段的行为. 比如动画开始之前,动画结束之后。如果是一个动画CAAnimation,则需要将其removedOnCompletion设置为NO,要不然fillMode不起作用.   </p><p><strong>各个fillMode的意义 </strong><br><strong>kCAFillModeRemoved</strong> 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态<br><strong>kCAFillModeForwards</strong> 当动画结束后,layer会一直保持着动画最后的状态<br><strong>kCAFillModeBackwards</strong> 这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初始状态<br><strong>kCAFillModeBoth</strong> 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建动画对象</span></div><div class="line"><span class="built_in">CABasicAnimation</span> *anim = [<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    </div><div class="line"><span class="comment">// 设置动画的属性</span></div><div class="line">anim.keyPath = <span class="string">@"transform.scale"</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 设置属性改变的值</span></div><div class="line">anim.toValue = @<span class="number">0.5</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 设置动画时长</span></div><div class="line">anim.duration = <span class="number">0.25</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 取消反弹</span></div><div class="line"><span class="comment">// 动画执行完毕之后不要把动画移除</span></div><div class="line">anim.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 保持最新的位置</span></div><div class="line">anim.fillMode = kCAFillModeForwards;</div><div class="line">    </div><div class="line"><span class="comment">// 重复动画的次数</span></div><div class="line">anim.repeatCount = MAXFLOAT;</div><div class="line">    </div><div class="line"><span class="comment">// 给图层添加了动画</span></div><div class="line">[_layer addAnimation:anim forKey:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></blockquote><h4 id="4、CAKeyframeAnimation"><a href="#4、CAKeyframeAnimation" class="headerlink" title="4、CAKeyframeAnimation"></a>4、CAKeyframeAnimation</h4><blockquote><p>a、设置几个点，在这几个点之间的动画  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置动画属性</span></div><div class="line">anim.keyPath = <span class="string">@"position"</span>;</div><div class="line">    </div><div class="line"><span class="built_in">NSValue</span> *v1 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointZero</span>];</div><div class="line">    </div><div class="line"><span class="built_in">NSValue</span> *v2 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">160</span>)];</div><div class="line">    </div><div class="line"><span class="built_in">NSValue</span> *v3 = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">270</span>, <span class="number">0</span>)];</div><div class="line">    </div><div class="line">anim.values = @[v1,v2,v3];</div><div class="line">    </div><div class="line">anim.duration = <span class="number">2</span>;</div><div class="line">    </div><div class="line">[_redView.layer addAnimation:anim forKey:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></blockquote><p>b、沿着路径动画</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CAKeyframeAnimation</span> *anim = [<span class="built_in">CAKeyframeAnimation</span> animation];</div><div class="line">    </div><div class="line"><span class="comment">// 设置动画属性</span></div><div class="line">anim.keyPath = <span class="string">@"position"</span>;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">anim.path = path.CGPath;</div><div class="line">    </div><div class="line">anim.duration = <span class="number">0.25</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 取消反弹</span></div><div class="line">anim.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">anim.fillMode = kCAFillModeForwards;</div><div class="line">    </div><div class="line">anim.repeatCount = MAXFLOAT;</div><div class="line">    </div><div class="line">[_redView.layer addAnimation:anim forKey:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></blockquote><h4 id="5、CATransition-转场动画"><a href="#5、CATransition-转场动画" class="headerlink" title="5、CATransition 转场动画"></a>5、CATransition 转场动画</h4><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CATransition</span> *anim = [<span class="built_in">CATransition</span> animation];</div><div class="line">    </div><div class="line">anim.type = <span class="string">@"pageCurl"</span>;</div><div class="line">    </div><div class="line">anim.subtype = kCATransitionFromLeft;</div><div class="line"><span class="comment">//anim.startProgress = 0.5;</span></div><div class="line">    </div><div class="line">anim.duration = <span class="number">2</span>;</div><div class="line">    </div><div class="line">[_imageView.layer addAnimation:anim forKey:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></blockquote><h4 id="6、CAAnimationGroup-动画组"><a href="#6、CAAnimationGroup-动画组" class="headerlink" title="6、CAAnimationGroup 动画组"></a>6、CAAnimationGroup 动画组</h4><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CABasicAnimation</span> *rotation = [<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    </div><div class="line">rotation.keyPath = <span class="string">@"transform.rotation"</span>;</div><div class="line">    </div><div class="line">rotation.toValue = @M_PI_2;</div><div class="line">    </div><div class="line"><span class="built_in">CABasicAnimation</span> *position = [<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    </div><div class="line">position.keyPath = <span class="string">@"position"</span>;</div><div class="line">    </div><div class="line">position.toValue = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">250</span>)];</div><div class="line">    </div><div class="line"><span class="built_in">CABasicAnimation</span> *scale = [<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    </div><div class="line">scale.keyPath = <span class="string">@"transform.scale"</span>;</div><div class="line">    </div><div class="line">scale.toValue = @<span class="number">0.5</span>;</div><div class="line"> </div><div class="line">    </div><div class="line"><span class="built_in">CAAnimationGroup</span> *group = [<span class="built_in">CAAnimationGroup</span> animation];</div><div class="line">    </div><div class="line">group.animations = @[rotation,position,scale];</div><div class="line">    </div><div class="line">group.duration = <span class="number">2</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 取消反弹</span></div><div class="line">group.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">group.fillMode = kCAFillModeForwards;</div><div class="line">    </div><div class="line">[_redView.layer addAnimation:group forKey:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、position-anchorPoint&quot;&gt;&lt;a href=&quot;#1、position-anchorPoint&quot; class=&quot;headerlink&quot; title=&quot;1、position anchorPoint&quot;&gt;&lt;/a&gt;1、position anchorPoi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-开发：自定义framework并打包</title>
    <link href="http://yoursite.com/2017/10/21/iOS-%E5%BC%80%E5%8F%91%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89framework%E5%B9%B6%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2017/10/21/iOS-开发：自定义framework并打包/</id>
    <published>2017-10-21T14:41:34.000Z</published>
    <updated>2017-10-21T15:05:47.817Z</updated>
    
    <content type="html"><![CDATA[<p>首先，新建一个工程,在进入页面之后,选择Framework &amp; Libray 选项中的 Cocoa Touch Framework.<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_46cb132fc307080dd51feee2694cabc9.png" alt="">   </p><p>因为要打包所需的文件,创建了CveniEs.h,CveniEs.m文件,并且自定义了一个初始化方法,在,初始化方法中调用了 - (void)getString:(NSString *)string方法,并且打印了一句话,为了证明生成framework之后确实走了该方法;在实际工作过程中,直接把需要打包的所有文件拖到该工程中即可,<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_d4dba5ca06891ccff84ce57388ce3957.png" alt="">  </p><p>然后选中Target,选中Build Phases -&gt; Headers,可以看出有三个选项,分别是Public,Private,Project;把需要暴露给别人的.h文件拖到Public中,剩下的不要暴露的,即为隐藏的文件,放在Project中,<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_de9b4c2b530de143de4ef2974dc493d3.png" alt="">   </p><p>完成上述步骤之后,在littleCveniEs.h文件中,把所有需要暴露的.h文件都用#import <littlecvenies publicheader.h="">引入,记住一定要将所有的需要暴露的.h文件都写在给定位置,不然编译后生成的.framework在引用的时候会有警告;<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_1833cdd43cc63b8029d8d0563d1ae967.png" alt="">  </littlecvenies></p><p>新建一个Target,选择Other - &gt;Aggregate,重命名<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_de489449e19c950f3b2909072427ca8f.png" alt=""></p><p>选中新建的Target,点击Build Pharas ,选中左上角的+,New Run Script Phase<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_2167f867c4c7404e05471dd491be7dff.png" alt="">  </p><p>点开Run Script,添加如下的脚本<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_3156a83c42a931dbf97d844d283be622.png" alt=""><br>脚本内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># Sets the target folders and the final framework product.</div><div class="line"># 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME</div><div class="line"># 例如: FMK_NAME = &quot;MyFramework&quot;</div><div class="line">FMK_NAME=$&#123;PROJECT_NAME&#125;</div><div class="line"># Install dir will be the final output to the framework.</div><div class="line"># The following line create it in the root folder of the current project.</div><div class="line">INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;FMK_NAME&#125;.framework</div><div class="line"># Working dir will be deleted after the framework creation.</div><div class="line">WRK_DIR=build</div><div class="line">DEVICE_DIR=$&#123;WRK_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.framework</div><div class="line">SIMULATOR_DIR=$&#123;WRK_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework</div><div class="line"># -configuration $&#123;CONFIGURATION&#125;</div><div class="line"># Clean and Building both architectures.</div><div class="line">xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build</div><div class="line">xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build</div><div class="line"># Cleaning the oldest.</div><div class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</div><div class="line">then</div><div class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</div><div class="line">fi</div><div class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</div><div class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</div><div class="line"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</div><div class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;&quot;</div><div class="line">rm -r &quot;$&#123;WRK_DIR&#125;&quot;</div><div class="line"></div><div class="line">open &quot;$&#123;INSTALL_DIR&#125;&quot;</div></pre></td></tr></table></figure><p>选中Targets中的第一个Target,也就是littleCveniEs,点击Build Setting -&gt; Mach-O Type,选择Static Library,到这里会有一个问题存在,就是无法在iPhone5c上使用.framework,这是我们需要在Build Setting -&gt; Architectures -&gt;Architectures中添加armv7s<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_f3758d27e6487f8918d1255b99d9364d.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_81265144d1d6820d189a8679c4b36ab8.png" alt="">  </p><p>我们已经完成了所有的工作,可以选择Command + B,不过编译之前,按照下图选择正确的Target,编译完成后会自动弹出已经创建完成的.framework<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_864dc5ede2994d9817e09e0772f01bba.png" alt="">  </p><p>到这里,我们已经完成了百分之九十九的步骤了,导入自己创建的.framework可以实现方法的调用,不过,如果你需要隐藏的文件中含有通过Category创建的类,当你运行程序的时候会发现出现崩溃的现象,如下图,我在创建自己的.framework的时候随便写了一个NSString的Category,并且在初始化方法中调用了Category中的方法,程序直接出现了Unrecognized selector sent to instance 0x10008c098的错误,这时我们需要在引用我们.framework的工程中设置 Build Pharse -&gt; Other Linker Flags中加上 -all_load 就OK了,再次运行工程,可以完成所有的打印过程.<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_4528c31871076da964e3bdd2c7badd40.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_91fae2a786ae7b38be0ca8bd5dc01dfb.png" alt=""><br>最后一张图是输出结果,可以看出所有我想要的打印都生成了,我们的.framework也完成了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，新建一个工程,在进入页面之后,选择Framework &amp;amp; Libray 选项中的 Cocoa Touch Framework.&lt;br&gt;&lt;img src=&quot;http://oui2ar2u7.bkt.clouddn.com/cid_46cb132fc307080d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Xcode 创建静态库封装自己的SDK</title>
    <link href="http://yoursite.com/2017/10/21/Xcode-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%BA%93%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84SDK/"/>
    <id>http://yoursite.com/2017/10/21/Xcode-创建静态库封装自己的SDK/</id>
    <published>2017-10-21T14:40:27.000Z</published>
    <updated>2017-10-21T15:29:31.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在自己的iOS工程中创建并使用一个SDK-俗称-a文件"><a href="#在自己的iOS工程中创建并使用一个SDK-俗称-a文件" class="headerlink" title="在自己的iOS工程中创建并使用一个SDK,俗称.a文件"></a>在自己的iOS工程中创建并使用一个SDK,俗称.a文件</h3><p>1、创建一个静态库工程  </p><blockquote><p>打开Xcode，点击File\New\Project，选择iOS\Framework and Library\Cocoa Touch Static Library新建一个静态库工程.<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_30a6980484d820941e3d302a993ab9ee.jpeg" alt=""><br>将工程命名为GGTestSDK，然后将工程保存到一个空目录下。<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_f6e3af72d8d96b32a5be2681c6809adc.jpeg" alt=""><br>一个静态库工程由头文件和实现文件组成，这些文件将被编译为库本身。<br>当创建静态库工程时，Xcode会自动添加GGTestSDK.h和GGTestSDK.m。你不需要实现文件，因此右键单击GGTestSDK.m选择delete，将它删除到废纸篓中。<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_a07287c1099a9f400fc6385946f1fb73.jpeg" alt="">  </p></blockquote><p>2、创建一个AlertView控件</p><blockquote><p>其实当前的工程就已经可以用了，是时候为你的库添加一些功能了。由于本篇教程的关键在于教你怎么样创建一个GGTestSDK.a，而不是怎么样构建一个UI控件，这里你可以使用你自己封装好的控件。将你的控件从Finder中拖到Xcode下GGTestSDK目录下。<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_49792af36e757b825a02fb0d95b11f23.jpeg" alt=""><br>这里有一点要注意了，这里一定要勾选以下三个选项：<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_aa63e8f72be068e5b3be8e3fdbcd111c.jpeg" alt=""><br>然后点击 Finish 进入工程：<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_7b57602036475780077f596c3ebd995c.jpeg" alt=""><br>对你的控件的头文件需要做的另一件事是将其添加到库的主头文件GGTestSDK.h中。在这个主头文件的帮助下，开发者使用你的库仅仅需要导入一个头文件，如下面的代码一样，而不是自己去选择自己需要的一块导入。<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_70fa59ad9ed8bc8639a4aa5116285a11.jpeg" alt="">  </p></blockquote><p>3、接下来生成静态库</p><blockquote><p>1、静态库分为手机和模拟器两种（手机端的只有手机能调用，模拟器的只有模拟器能调用）。<br>首先，构建模拟器的静态库，如图<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_a6272064ec64eb10997a09e46e56f72b.jpeg" alt=""><br>然后show in Finder<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_278f271933aca1c3cd8c1b45938c7649.jpeg" alt=""><br>之后我拿到这个.a文件 还有和他相关的所有.h文件，存放在一个新的文件夹里（随便起名越屌越好）如下<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_613942bef26e3cbb208bd636a9171ced.jpeg" alt=""><br>现在呢，你就可以拿着这个文件夹去挥霍了。将他拖到你要应用了工程中<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_fd86e83841889bde535df7a1ba6d31a3.jpeg" alt=""><br>上面已经提到了，只能在模拟器上运行，如果我们链接手机：<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_7dfe87fcfb2b5350cfb7ff956052f077.jpeg" alt=""><br>构建真机的静态库，如图<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_e094a1a624358dc9d4fc65895bd4a250.jpeg" alt=""><br>改成Device 构建构成（command + B）你就会发现   libGGTestSDK.a 变黑了。<br>重复之前的步骤 就可以在手机上运行了（但是，模拟器又不能用了。。。。<br>接下来，我们就来生成一个双方都能用的libGGTestSDK.a<br>将模拟器.a文件和设备真机.a文件合成一个文件 首先找到对应项目的模拟器.a文件和真机.a文件（show in finder 可以看到有的两个文件夹)如下图<br><img src="http://oui2ar2u7.bkt.clouddn.com/cid_85a58696fa4621890ad8f6f2acac1299.png" alt=""><br>在终端输入 <code>lipo -create  模拟器.a文件的路径 真机.a文件的路径 -output 合并后的保存路径</code><br>我们就得到合并之后的.a文件 eg.   </p><blockquote><p>lipo -create<br>/Users/mac/Library/Developer/Xcode/DerivedData/KKTestSDK-ewtpefavdqrcdjcssbyvdjyevumn/Build/Products/Debug-iphoneos/libKKTestSDK.a /Users/mac/Library/Developer/Xcode/DerivedData/KKTestSDK-ewtpefavdqrcdjcssbyvdjyevumn/Build/Products/Debug-iphonesimulator/libKKTestSDK.a -output /Users/mac/Desktop/libKKTestSDK.a  </p></blockquote><p>静态库的使用:新建文件夹命名为<code>logNewsSDK</code>,把我们获得的.a文件和我们需要显示的.h文件拷贝进去,就<br>行了，然后直接拉到我们需要用到的工程里面去就行了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在自己的iOS工程中创建并使用一个SDK-俗称-a文件&quot;&gt;&lt;a href=&quot;#在自己的iOS工程中创建并使用一个SDK-俗称-a文件&quot; class=&quot;headerlink&quot; title=&quot;在自己的iOS工程中创建并使用一个SDK,俗称.a文件&quot;&gt;&lt;/a&gt;在自己的i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2017/10/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/21/多线程/</id>
    <published>2017-10-21T13:45:57.000Z</published>
    <updated>2017-10-21T14:28:13.593Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程的注意点"><a href="#线程的注意点" class="headerlink" title="线程的注意点"></a>线程的注意点</h4><blockquote><p>1.不要同时开太多的线程（1~3条线程即可，不要超过5条）<br>2.线程概念 </p><ul><li>1)主线程 ： UI线程，显示、刷新UI界面，处理UI控件的事件  </li><li>2)子线程 ： 后台线程，异步线程  </li></ul><p>3.不要把耗时的操作放在主线程，要放在子线程中执行</p></blockquote><h4 id="iOS的三种多线程技术"><a href="#iOS的三种多线程技术" class="headerlink" title="iOS的三种多线程技术"></a>iOS的三种多线程技术</h4><blockquote><p>NSThread  </p><blockquote><ul><li>使用NSThread对象建立一个线程非常方便</li><li>但是！要使用NSThread管理多个线程非常困难，不推荐使用</li><li>技巧！使用[NSThread currentThread]跟踪任务所在线程，适用于这三种技术  </li></ul></blockquote><p>NSOperation/NSOperationQueue</p><blockquote><ul><li>是使用GCD实现的一套Objective-C的API</li><li>是面向对象的线程技术</li><li>提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系</li></ul></blockquote><p>GCD —— Grand Central Dispatch   </p><blockquote><ul><li>是基于C语言的底层API</li><li>用Block定义任务，使用起来非常灵活便捷</li><li>提供了更多的控制能力以及操作队列中所不能使用的底层函数</li></ul></blockquote></blockquote><h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><blockquote><p>1.创建和启动线程的3种方式  </p><blockquote><p>1)先创建，后启动   </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 </span></div><div class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download:) object:<span class="literal">nil</span>];</div><div class="line"><span class="comment">// 启动</span></div><div class="line">[thread start];</div></pre></td></tr></table></figure><p>2)创建完自动启动</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(download:) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</div></pre></td></tr></table></figure><p>3)隐式创建（自动启动）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(download:) withObject:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></blockquote><p>2.常见方法</p><blockquote><p>1)获得当前线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSThread</span> *)currentThread;</div></pre></td></tr></table></figure><p>2)获得主线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSThread</span> *)mainThread;</div></pre></td></tr></table></figure><p>3)睡眠（暂停）线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</div><div class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</div></pre></td></tr></table></figure><p>4)设置线程的名字</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)n;</div><div class="line">- (<span class="built_in">NSString</span> *)name;</div></pre></td></tr></table></figure></blockquote></blockquote><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><blockquote><p>1.实质：为了防止多个线程抢夺同一个资源造成的数据安全问题</p><p>2.实现：给代码加一个互斥锁（同步锁）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">    <span class="comment">// 被锁住的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h4 id="GCD（Grand-Central-Dispatch）"><a href="#GCD（Grand-Central-Dispatch）" class="headerlink" title="GCD（Grand Central Dispatch）"></a>GCD（Grand Central Dispatch）</h4><blockquote><p>1.队列和任务  </p><blockquote><p>1)任务 ：需要执行什么操作</p><blockquote><p>用block来封装任务</p></blockquote><p>2)队列 ：存放任务</p><blockquote><p>全局的并发队列 ： 可以让任务并发执行</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div></pre></td></tr></table></figure><p>自己创建的串行队列 ： 让任务一个接着一个执行</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"cn.heima.queue"</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure><p>主队列 ： 让任务在主线程执行</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure></blockquote></blockquote><p>2.执行任务的函数</p><blockquote><p>1)同步执行 : 不具备开启新线程的能力<br><code>dispatch_sync...</code><br>2)异步执行 : 具备开启新线程的能力<br><code>dispatch_async...</code></p></blockquote><p>3.常见的组合</p><blockquote><p>1)<code>dispatch_async</code> + 全局并发队列<br>2)<code>dispatch_async</code> + 自己创建的串行队列</p></blockquote><p>4.线程间的通信</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">   <span class="comment">// 执行耗时的异步操作... </span></div><div class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">       <span class="comment">// 回到主线程，执行UI刷新操作</span></div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></blockquote><p>5.GCD的所有API都在libdispatch.dylib，Xcode会自动导入这个库</p><blockquote><p>主头文件 ： <code>#import &lt;dispatch/dispatch.h&gt;</code></p></blockquote><p>6.延迟执行</p><blockquote><p>1) <code>perform....</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 3秒后自动回到当前线程调用self的download:方法，并且传递参数：@"http://555.jpg"</span></div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(download:) withObject:<span class="string">@"http://555.jpg"</span> afterDelay:<span class="number">3</span>];</div></pre></td></tr></table></figure><p>2) <code>dispatch_after...</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 任务放到哪个队列中执行</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="keyword">double</span> delay = <span class="number">3</span>; <span class="comment">// 延迟多少秒</span></div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class="line">    <span class="comment">// 3秒后需要执行的任务</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></blockquote><p>7.一次性代码</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    <span class="comment">// 这里面的代码，在程序运行过程中，永远只会执行1次</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></blockquote></blockquote><h4 id="单例模式-懒汉式"><a href="#单例模式-懒汉式" class="headerlink" title="单例模式(懒汉式)"></a>单例模式(懒汉式)</h4><p>1.ARC</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HMDataTool</span> : <span class="title">NSObject</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)sharedDataTool;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HMDataTool</span></span></div><div class="line"><span class="comment">// 用来保存唯一的单例对象</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instace;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _instace = [<span class="keyword">super</span> allocWithZone:zone];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _instace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)sharedDataTool</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _instace = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _instace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _instace;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>2.MRC</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HMDataTool</span> : <span class="title">NSObject</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)sharedDataTool;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HMDataTool</span></span></div><div class="line"><span class="comment">// 用来保存唯一的单例对象</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instace;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _instace = [<span class="keyword">super</span> allocWithZone:zone];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _instace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)sharedDataTool</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _instace = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _instace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _instace;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)autorelease &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><h4 id="NSOperation和NSOperationQueue"><a href="#NSOperation和NSOperationQueue" class="headerlink" title="NSOperation和NSOperationQueue"></a>NSOperation和NSOperationQueue</h4><blockquote><p>1.队列的类型</p><blockquote><p>1) 主队列</p><blockquote><p>[NSOperationQueue mainQueue]<br>添加到”主队列”中的操作，都会放到主线程中执行</p></blockquote><p>2) 非主队列</p><blockquote><p>[[NSOperationQueue alloc] init]<br>添加到”非主队列”中的操作，都会放到子线程中执行</p></blockquote></blockquote><p>2.队列添加任务</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addOperation:(<span class="built_in">NSOperation</span> *)op;</div><div class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure></blockquote><p>3.常见用法</p><blockquote><p>1) 设置最大并发数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)maxConcurrentOperationCount;</div><div class="line">- (<span class="keyword">void</span>)setMaxConcurrentOperationCount:(<span class="built_in">NSInteger</span>)cnt;</div></pre></td></tr></table></figure><p>2) 队列的其他操作</p><blockquote><p>取消所有的操作<br><code>- (void)cancelAllOperations;</code></p><p>暂停所有的操作<br><code>[queue setSuspended:YES];</code></p><p>恢复所有的操作<br><code>[queue setSuspended:NO];</code></p></blockquote></blockquote><p>4.操作之间的依赖</p><blockquote><p>NSOperation之间可以设置依赖来保证执行顺序<br>[operationB addDependency:operationA];  </p><blockquote><p>操作B依赖于操作A，等操作A执行完毕后，才会执行操作B。<br>注意：不能相互依赖，比如A依赖B，B依赖A；可以在不同queue的NSOperation之间创建依赖关系</p></blockquote></blockquote><p>5.线程之间的通信</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">[queue addOperationWithBlock:^&#123;</div><div class="line">    <span class="comment">// 1.执行一些比较耗时的操作</span></div><div class="line">    <span class="comment">// 2.回到主线程</span></div><div class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">        <span class="comment">//主线程操作</span></div><div class="line">    &#125;];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></blockquote></blockquote><h4 id="从其他线程回到主线程的方式"><a href="#从其他线程回到主线程的方式" class="headerlink" title="从其他线程回到主线程的方式"></a>从其他线程回到主线程的方式</h4><blockquote><p>1.<code>perform...</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelectorOnMainThread:&lt;<span class="meta">#(SEL)#&gt; withObject:<span class="meta-string">&lt;#(id)#&gt;</span> waitUntilDone:<span class="meta-string">&lt;#(BOOL)#&gt;</span>];</span></div></pre></td></tr></table></figure><p>2.<code>GCD</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line"><span class="comment">//主线程操作</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>3.NSOperationQueue</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">    <span class="comment">//主线程操作</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;线程的注意点&quot;&gt;&lt;a href=&quot;#线程的注意点&quot; class=&quot;headerlink&quot; title=&quot;线程的注意点&quot;&gt;&lt;/a&gt;线程的注意点&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1.不要同时开太多的线程（1~3条线程即可，不要超过5条）&lt;br&gt;2.线程概念 &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQLite</title>
    <link href="http://yoursite.com/2017/10/20/SQLite/"/>
    <id>http://yoursite.com/2017/10/20/SQLite/</id>
    <published>2017-10-20T14:12:37.000Z</published>
    <updated>2017-10-20T16:54:55.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><h4 id="一、iOS中的数据存储方式"><a href="#一、iOS中的数据存储方式" class="headerlink" title="一、iOS中的数据存储方式"></a>一、iOS中的数据存储方式</h4><blockquote><ul><li>Plist（NSArray\NSDictionary）  </li><li>Preference（偏好设置\NSUserDefaults）  </li><li>NSCoding（NSKeyedArchiver\NSkeyedUnarchiver  ）</li><li>SQLite3  </li><li>Core Data  </li></ul></blockquote><h4 id="二、什么是SQLite"><a href="#二、什么是SQLite" class="headerlink" title="二、什么是SQLite"></a>二、什么是SQLite</h4><blockquote><ul><li>SQLite是一款轻型的嵌入式数据库  </li><li>它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了  </li><li>它的处理速度比Mysql、PostgreSQL这两款著名的数据库都还快  </li></ul></blockquote><h4 id="三、什么是数据库"><a href="#三、什么是数据库" class="headerlink" title="三、什么是数据库"></a>三、什么是数据库</h4><blockquote><ul><li>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库  </li><li>数据库可以分为2大种类<br>1&gt; 关系型数据库（主流）<br>2&gt; 对象型数据库</li></ul></blockquote><h4 id="四、常用关系型数据库"><a href="#四、常用关系型数据库" class="headerlink" title="四、常用关系型数据库"></a>四、常用关系型数据库</h4><blockquote><ul><li>PC端：Oracle、MySQL、SQL Server、Access、DB2、Sybase</li><li>嵌入式\移动客户端：SQLite</li></ul></blockquote><h4 id="五、数据库存储数据的步骤"><a href="#五、数据库存储数据的步骤" class="headerlink" title="五、数据库存储数据的步骤"></a>五、数据库存储数据的步骤</h4><blockquote><ol><li>新建一张表（table）  </li><li>添加多个字段（column，列，属性）  </li><li>添加多行记录（row，record，每行存放多个字段对应的值）  </li></ol></blockquote><h4 id="六、SQL语句"><a href="#六、SQL语句" class="headerlink" title="六、SQL语句"></a>六、SQL语句</h4><blockquote><ul><li><p>SQL语句的特点</p><blockquote><p>不区分大小写（比如数据库认为user和UsEr是一样的）<br>每条语句都必须以分号 ; 结尾</p></blockquote></li><li><p>SQL中的常用关键字有</p><blockquote><p>select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index等等</p></blockquote></li><li><p>数据库中不可以使用关键字来命名表、字段</p></li></ul></blockquote><h4 id="七、SQL语句的种类"><a href="#七、SQL语句的种类" class="headerlink" title="七、SQL语句的种类"></a>七、SQL语句的种类</h4><blockquote><ul><li>数据定义语句（DDL：Data Definition Language）</li></ul><blockquote><p>包括create和drop等操作<br>在数据库中创建新表或删除表（create table或 drop table）</p></blockquote><ul><li>数据操作语句（DML：Data Manipulation Language）</li></ul><blockquote><p>包括insert、update、delete等操作<br>上面的3种操作分别用于添加、修改、删除表中的数据</p></blockquote><ul><li>数据查询语句（DQL：Data Query Language）</li></ul><blockquote><p>可以用于查询获得表中的数据<br>关键字select是DQL（也是所有SQL）用得最多的操作<br>其他DQL常用的关键字有where，order by，group by和having</p></blockquote></blockquote><h4 id="八、SQL语句对数据的具体操作"><a href="#八、SQL语句对数据的具体操作" class="headerlink" title="八、SQL语句对数据的具体操作"></a>八、SQL语句对数据的具体操作</h4><blockquote><ul><li>创表 </li></ul><blockquote><p>格式<br>create table 表名 (字段名1 字段类型1, 字段名2 字段类型2, …) ;<br>create table if not exists 表名 (字段名1 字段类型1, 字段名2 字段类型2, …) ;<br>示例<br>create table t_student (id integer, name text, age inetger, score real) ;</p></blockquote><ul><li>字段类型</li></ul><blockquote><ol><li><p>SQLite将数据划分为以下几种存储类型：<br>integer : 整型值<br>real : 浮点值<br>text : 文本字符串<br>blob : 二进制数据（比如文件）  </p></li><li><p>实际上SQLite是无类型的<br>就算声明为integer类型，还是能存储字符串文本（主键除外）<br>建表时声明啥类型或者不声明类型都可以，也就意味着创表语句可以这么写：<br>create table t_student(name, age);  </p></li><li><p>为了保持良好的编程规范、方便程序员之间的交流，编写建表语句的时候最好加上每个字段的具体类型</p></li></ol></blockquote><ul><li>删表</li></ul><blockquote><p>格式<br>drop table 表名 ;<br>drop table if exists 表名 ;<br>示例<br>drop table t_student ;  </p></blockquote><ul><li>插入数据（insert）</li></ul><blockquote><p>格式<br>insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …) ;<br>示例<br>insert into t_student (name, age) values (‘mj’, 10) ;<br>注意<br>数据库中的字符串内容应该用单引号 ’ 括住  </p></blockquote><ul><li>更新数据（update）</li></ul><blockquote><p>格式<br>update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, … ;<br>示例<br>update t_student set name = ‘jack’, age = 20 ;<br>注意<br>上面的示例会将<code>t_student</code>表中所有记录的name都改为jack，age都改为20  </p></blockquote><ul><li>删除数据（delete）</li></ul><blockquote><p>格式<br>delete from 表名 ;<br>示例<br>delete from t_student ;<br>注意<br>上面的示例会将<code>t_student</code>表中所有记录都删掉  </p></blockquote><ul><li>条件语句</li></ul><blockquote><p>条件语句的常见格式<br>where 字段 = 某个值 ;   // 不能用两个 =<br>where 字段 is 某个值 ;   // is 相当于 =<br>where 字段 != 某个值 ;<br>where 字段 is not 某个值 ;   // is not 相当于 !=<br>where 字段 &gt; 某个值 ;<br>where 字段1 = 某个值 and 字段2 &gt; 某个值 ;  // and相当于C语言中的 &amp;&amp;<br>where 字段1 = 某个值 or 字段2 = 某个值 ;  //  or 相当于C语言中的 ||  </p><p>示例<br>将<code>t_student</code>表中年龄大于10 并且 姓名不等于jack的记录，年龄都改为 5<br>update <strong>t_student</strong> set age = 5 where age &gt; 10 and name != ‘jack’ ;<br>删除<code>t_student</code>表中年龄小于等于10 或者 年龄大于30的记录<br>delete from <strong>t_student</strong> where age &lt;= 10 or age &gt; 30 ;<br>猜猜下面语句的作用<br>update <strong>t_student</strong> set score = age where name = ‘jack’ ;<br>将<code>t_student</code>表中名字等于jack的记录，score字段的值 都改为 age字段的值  </p></blockquote><ul><li>查找（DQL语句）</li></ul><blockquote><p>格式<br>select 字段1, 字段2, … from 表名 ;<br>select <code>*</code> from 表名;   //  查询所有的字段<br>示例<br>select name, age from <strong>t_student</strong> ;<br>select <code>*</code> from <strong>t_student</strong> ;<br>select <code>*</code> from <strong>t_student</strong> where age &gt; 10 ;  //  条件查询  </p></blockquote><ul><li>起别名</li></ul><blockquote><p>格式(字段和表都可以起别名)<br>select 字段1 别名 , 字段2 别名 , … from 表名 别名 ;<br>select 字段1 别名, 字段2 as 别名, … from 表名 as 别名 ;<br>select 别名.字段1, 别名.字段2, … from 表名 别名 ;<br>示例<br>select name myname, age myage from <strong>t_student</strong> ;<br>给name起个叫做myname的别名，给age起个叫做myage的别名<br>select s.name, s.age from <strong>t_student</strong> s ;<br>给<code>t_student</code>表起个别名叫做s，利用s来引用表中的字段  </p></blockquote><ul><li>计算记录的数量</li></ul><blockquote><p>格式<br>select count (字段) from 表名 ;<br>select count ( <code>*</code>) from 表名 ;<br>示例<br>select count (age) from <strong>t_student</strong> ;<br>select count ( <code>*</code> ) from <strong>t_student</strong> where score &gt;= 60;  </p></blockquote><ul><li>排序</li></ul><blockquote><p>查询出来的结果可以用order by进行排序<br>select <code>*</code> from <strong>t_student</strong> order by 字段 ;<br>select <code>*</code> from <strong>t_student</strong> order by age ;<br>默认是按照升序排序（由小到大），也可以变为降序（由大到小）<br>select <code>*</code> from <strong>t_student</strong> order by age desc ;  //降序<br>select <code>*</code> from <strong>t_student</strong> order by age asc ;   // 升序（默认）<br>也可以用多个字段进行排序<br>select <code>*</code> from t_student order by age asc, height desc ;<br>先按照年龄排序（升序），年龄相等就按照身高排序（降序）  </p></blockquote><ul><li>limit</li></ul><blockquote><p>使用limit可以精确地控制查询结果的数量，比如每次只查询10条数据<br>格式<br>select <code>*</code> from 表名 limit 数值1, 数值2 ;<br>示例<br>select <code>*</code> from <strong>t_student</strong> limit 4, 8 ;<br>可以理解为：跳过最前面4条语句，然后取8条记录<br>limit常用来做分页查询，比如每页固定显示5条数据，那么应该这样取数据<br>第1页：limit 0, 5<br>第2页：limit 5, 5<br>第3页：limit 10, 5<br>…<br>第n页：limit 5<em>(n-1), 5<br>猜猜下面语句的作用<br>select `</em><code>from **t_student** limit 7 ;  相当于select</code>*` from t_student limit 0, 7 ;<br>表示取最前面的7条记录  </p></blockquote><ul><li>简单约束 </li></ul><blockquote><p>建表时可以给特定的字段设置一些约束条件，常见的约束有<br>not null ：规定字段的值不能为null<br>unique ：规定字段的值必须唯一<br>default ：指定字段的默认值<br>（建议：尽量给字段设定严格的约束，以保证数据的规范性）<br>示例<br>create table <strong>t_student</strong> (id integer, name text not null unique, age integer not null default 1) ;<br>name字段不能为null，并且唯一<br>age字段不能为null，并且默认为1   </p></blockquote><ul><li>主键约束 </li></ul><blockquote><p>如果<code>t_student</code>表中就name和age两个字段，而且有些记录的name和age字段的值都一样时，那么就没法区分这些数据，造成数据库的记录不唯一，这样就不方便管理数据<br>良好的数据库编程规范应该要保证每条记录的唯一性，为此，增加了主键约束<br>也就是说，每张表都必须有一个主键，用来标识记录的唯一性<br>什么是主键<br>主键（Primary Key，简称PK）用来唯一地标识某一条记录<br>例如<code>t_student</code>可以增加一个id字段作为主键，相当于人的身份证<br>主键可以是一个字段或多个字段   </p></blockquote><ul><li>主键设计原则 </li></ul><blockquote><p>主键应当是对用户没有意义的<br>永远也不要更新主键<br>主键不应包含动态变化的数据<br>主键应当由计算机自动生成  </p></blockquote><ul><li>主键的声明</li></ul><blockquote><p>在创表的时候用primary key声明一个主键<br>create table <strong>t_student</strong> (id integer primary key, name text, age integer) ;<br>integer类型的id作为<code>t_student</code>表的主键<br>主键字段<br>只要声明为primary key，就说明是一个主键字段<br>主键字段默认就包含了not null 和 unique 两个约束<br>如果想要让主键自动增长（必须是integer类型），应该增加autoincrement<br>create table <strong>t_student</strong> (id integer primary key autoincrement, name text, age integer) ;  </p></blockquote><ul><li>外键约束</li></ul><blockquote><p>利用外键约束可以用来建立表与表之间的联系<br>外键的一般情况是：一张表的某个字段，引用着另一张表的主键字段<br>新建一个外键<br>create table <strong>t_student</strong> (id integer primary key autoincrement, name text, age integer, <strong>class_id</strong> integer, constraint <strong>fk_student**</strong>_class<strong> foreign key (</strong>class_id<strong>) references </strong>t_class (id)<strong>);  </strong>t_student<strong>表中有一个叫做</strong>fk_t<strong><strong>_student</strong></strong>_class<strong><strong>_id</strong></strong>_t<strong><strong>_class</strong></strong>_id**的外键<br>这个外键的作用是用t_student表中的class_id字段引用t_class表的id字段</p></blockquote><ul><li>表连接查询</li></ul><blockquote><p>什么是表连接查询<br>需要联合多张表才能查到想要的数据<br>表连接的类型<br>内连接：inner join 或者 join  （显示的是左右表都有完整字段值的记录）<br>左外连接：left outer join （保证左表数据的完整性）<br>示例<br>查询0316iOS班的所有学生<br>select s.name,s.age from <strong>t_student</strong> s, <strong>t_class</strong> c where s.<strong>class_id</strong> = c.<strong>id</strong> and c.name = ‘0316iOS’;</p></blockquote></blockquote><h4 id="九、在iOS中使用SQLite3"><a href="#九、在iOS中使用SQLite3" class="headerlink" title="九、在iOS中使用SQLite3"></a>九、在iOS中使用SQLite3</h4><blockquote><ul><li>在iOS中使用SQLite3，首先要添加库文件libsqlite3.dylib和导入主头文件</li><li>创建、打开、关闭数据库  </li></ul><blockquote><p>创建或打开数据库</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// path是数据库文件的存放路径</span></div><div class="line">sqlite3 *db = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">int</span> result = sqlite3_open([path UTF8String], &amp;db);</div></pre></td></tr></table></figure><blockquote><p>代码解析：<br><code>sqlite3_open()</code>将根据文件路径打开数据库，如果不存在，则会创建一个新的数据库。如果result等于常量<code>SQLITE_OK</code>，则表示成功打开数据库<br>sqlite3 *db：一个打开的数据库实例<br>数据库文件的路径必须以C字符串(而非NSString)传入<br>关闭数据库：<code>sqlite3_close(db)</code>; </p></blockquote></blockquote><ul><li>执行创表语句</li></ul><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *errorMsg = <span class="literal">NULL</span>;  <span class="comment">// 用来存储错误信息</span></div><div class="line"><span class="keyword">char</span> *sql = <span class="string">"create table if not exists t_person(id integer primary key autoincrement, name text, age integer);"</span>;</div><div class="line"><span class="keyword">int</span> result = sqlite3_exec(db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errorMsg);</div></pre></td></tr></table></figure><blockquote><p>代码解析：<br><code>sqlite3_exec()</code>可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据<br><code>sqlite3_exec()</code>还可以执行的语句：<br>开启事务：begin transaction;<br>回滚事务：rollback;<br>提交事务：commit;  </p></blockquote></blockquote><ul><li>带占位符插入数据</li></ul><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *sql = <span class="string">"insert into t_person(name, age) values(?, ?);"</span>;</div><div class="line">sqlite3_stmt *stmt;</div><div class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</div><div class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, <span class="string">"母鸡"</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    sqlite3_bind_int(stmt, <span class="number">2</span>, <span class="number">27</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (sqlite3_step(stmt) != SQLITE_DONE) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"插入数据错误"</span>);</div><div class="line">&#125;</div><div class="line">sqlite3_finalize(stmt);</div></pre></td></tr></table></figure><blockquote><p>代码解析：<br><code>sqlite3_prepare_v2()</code>返回值等于<code>SQLITE_OK</code>，说明SQL语句已经准备成功，没有语法问题<br><code>sqlite3_bind_text()</code>：大部分绑定函数都只有3个参数<br>第1个参数是<code>sqlite3_stmt *</code>类型<br>第2个参数指占位符的位置，第一个占位符的位置是1，不是0<br>第3个参数指占位符要绑定的值<br>第4个参数指在第3个参数中所传递数据的长度，对于C字符串，可以传递-1代替字符串的长度<br>第5个参数是一个可选的函数回调，一般用于在语句执行后完成内存清理工作<br><code>sqlite_step()</code>：执行SQL语句，返回<code>SQLITE_DONE</code>代表成功执行完毕<br><code>sqlite_finalize()</code>：销毁<code>sqlite3_stmt *</code>对象  </p></blockquote></blockquote><ul><li>查询数据  </li></ul><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *sql = <span class="string">"select id,name,age from t_person;"</span>;</div><div class="line">sqlite3_stmt *stmt;</div><div class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</div><div class="line">    <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</div><div class="line">        <span class="keyword">int</span> _<span class="keyword">id</span> = sqlite3_column_int(stmt, <span class="number">0</span>);</div><div class="line">        <span class="keyword">char</span> *_name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">1</span>);</div><div class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:_name];</div><div class="line">        <span class="keyword">int</span> _age = sqlite3_column_int(stmt, <span class="number">2</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"id=%i, name=%@, age=%i"</span>, _<span class="keyword">id</span>, name, _age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">sqlite3_finalize(stmt);</div></pre></td></tr></table></figure><blockquote><p>代码解析<br><code>sqlite3_step()</code>返回<code>SQLITE_ROW</code>代表遍历到一条新记录<br><code>sqlite3_column_*()</code>用于获取每个字段对应的值，第2个参数是字段的索引，从0开始  </p></blockquote></blockquote></blockquote><h4 id="十、FMDB"><a href="#十、FMDB" class="headerlink" title="十、FMDB"></a>十、FMDB</h4><blockquote><ul><li>核心类</li></ul><blockquote><p>FMDB有三个主要的类<br><code>FMDatabase</code><br>一个FMDatabase对象就代表一个单独的SQLite数据库用来执行SQL语句<br><code>FMResultSet</code><br>使用FMDatabase执行查询后的结果集<br><code>FMDatabaseQueue</code><br>用于在多线程中执行多个查询或更新，它是线程安全的 </p></blockquote><ul><li>打开数据库 </li></ul><blockquote><p>通过指定SQLite数据库文件路径来创建FMDatabase对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FMDatabase *db = [FMDatabase databaseWithPath:path];</div><div class="line"><span class="keyword">if</span> (![db open]) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数据库打开失败！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>文件路径有三种情况  </p><blockquote><ul><li>具体文件路径<br>如果不存在会自动创建  </li><li>空字符串@””<br>会在临时目录创建一个空的数据库,当FMDatabase连接关闭时，数据库文件也被删除  </li><li>nil<br>会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li></ul></blockquote></blockquote><ul><li>执行更新</li></ul><blockquote><p>在FMDB中，除查询以外的所有操作，都称为“更新”<br>create、drop、insert、update、delete等<br>使用executeUpdate:方法执行更新  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdateWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div></pre></td></tr></table></figure><p>示例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[db executeUpdate:<span class="string">@"UPDATE t_student SET age = %@ WHERE name = %@;"</span>, @<span class="number">20</span>, <span class="string">@"Jack"</span>]</div></pre></td></tr></table></figure></blockquote><ul><li>执行查询</li></ul><blockquote><p>查询方法  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (FMResultSet *)executeQueryWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span> *)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div></pre></td></tr></table></figure><p>示例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查询数据</span></div><div class="line">FMResultSet *rs = [db executeQuery:<span class="string">@"SELECT * FROM t_student"</span>];</div><div class="line"><span class="comment">// 遍历结果集</span></div><div class="line"><span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">    <span class="built_in">NSString</span> *name = [rs stringForColumn:<span class="string">@"name"</span>];</div><div class="line">    <span class="keyword">int</span> age = [rs intForColumn:<span class="string">@"age"</span>];</div><div class="line">    <span class="keyword">double</span> score = [rs doubleForColumn:<span class="string">@"score"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><ul><li>FMDatabaseQueue</li></ul><blockquote><p>FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题<br>为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue类<br>FMDatabaseQueue的创建  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:path];</div></pre></td></tr></table></figure><p>简单使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[queue inDatabase:^(FMDatabase *db) &#123;</div><div class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jack"</span>];</div><div class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Rose"</span>];</div><div class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jim"</span>];</div><div class="line">    FMResultSet *rs = [db executeQuery:<span class="string">@"select * from t_student"</span>];</div><div class="line">    <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">        <span class="comment">// …</span></div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></blockquote><p>使用事务</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[queue inTransaction:^(FMDatabase *db, <span class="built_in">BOOL</span> *rollback) &#123;</div><div class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jack"</span>];</div><div class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Rose"</span>];</div><div class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jim"</span>];</div><div class="line">    FMResultSet *rs = [db executeQuery:<span class="string">@"select * from t_student"</span>];</div><div class="line">    <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">        <span class="comment">// …</span></div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"><span class="comment">//事务回滚</span></div><div class="line">*rollback = <span class="literal">YES</span></div></pre></td></tr></table></figure></blockquote></blockquote><h4 id="十一、SQLite函数总结"><a href="#十一、SQLite函数总结" class="headerlink" title="十一、SQLite函数总结"></a>十一、SQLite函数总结</h4><blockquote><ul><li>打开数据库</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_open(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filename,   <span class="comment">// 数据库的文件路径</span></div><div class="line">    sqlite3 **ppDb          <span class="comment">// 数据库实例</span></div><div class="line">);</div></pre></td></tr></table></figure><ul><li>执行任何SQL语句  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_exec(</div><div class="line">    sqlite3*,                                  <span class="comment">// 一个打开的数据库实例</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sql,                           <span class="comment">// 需要执行的SQL语句</span></div><div class="line">    <span class="keyword">int</span> (*callback)(<span class="keyword">void</span>*,<span class="keyword">int</span>,<span class="keyword">char</span>**,<span class="keyword">char</span>**),  <span class="comment">// SQL语句执行完毕后的回调</span></div><div class="line">    <span class="keyword">void</span> *,                                    <span class="comment">// 回调函数的第1个参数</span></div><div class="line">    <span class="keyword">char</span> **errmsg                              <span class="comment">// 错误信息</span></div><div class="line">);</div></pre></td></tr></table></figure><ul><li>3.检查SQL语句的合法性（查询前的准备）  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_prepare_v2(</div><div class="line">    sqlite3 *db,            <span class="comment">// 数据库实例</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *zSql,       <span class="comment">// 需要检查的SQL语句</span></div><div class="line">    <span class="keyword">int</span> nByte,              <span class="comment">// SQL语句的最大字节长度</span></div><div class="line">    sqlite3_stmt **ppStmt,  <span class="comment">// sqlite3_stmt实例，用来获得数据库数据</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **pzTail</div><div class="line">);</div></pre></td></tr></table></figure><ul><li>查询一行数据</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_step(sqlite3_stmt*); <span class="comment">// 如果查询到一行数据，就会返回SQLITE_ROW</span></div></pre></td></tr></table></figure><ul><li>利用stmt获得某一字段的值（字段的下标从0开始）</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> sqlite3_column_double(sqlite3_stmt*, <span class="keyword">int</span> iCol);  <span class="comment">// 浮点数据</span></div><div class="line"><span class="keyword">int</span> sqlite3_column_int(sqlite3_stmt*, <span class="keyword">int</span> iCol); <span class="comment">// 整型数据</span></div><div class="line">sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, <span class="keyword">int</span> iCol); <span class="comment">// 长整型数据</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *sqlite3_column_blob(sqlite3_stmt*, <span class="keyword">int</span> iCol); <span class="comment">// 二进制文本数据</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sqlite3_column_text(sqlite3_stmt*, <span class="keyword">int</span> iCol);  <span class="comment">// 字符串数据</span></div></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SQLite&quot;&gt;&lt;a href=&quot;#SQLite&quot; class=&quot;headerlink&quot; title=&quot;SQLite&quot;&gt;&lt;/a&gt;SQLite&lt;/h3&gt;&lt;h4 id=&quot;一、iOS中的数据存储方式&quot;&gt;&lt;a href=&quot;#一、iOS中的数据存储方式&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO的实现原理</title>
    <link href="http://yoursite.com/2017/10/20/KVO%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/20/KVO的实现原理/</id>
    <published>2017-10-20T14:12:17.000Z</published>
    <updated>2017-10-20T14:18:31.916Z</updated>
    
    <content type="html"><![CDATA[<h4 id="KVO的具体实现"><a href="#KVO的具体实现" class="headerlink" title="KVO的具体实现"></a>KVO的具体实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="comment">/** p1 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Person *p1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 1.什么是通知</span></div><div class="line">    </div><div class="line">    <span class="comment">// 3个对象</span></div><div class="line">    <span class="keyword">self</span>.p1 = [[Person alloc] init];</div><div class="line">    <span class="keyword">self</span>.p1.name = <span class="string">@"p1"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// KVO是监听对象的属性值的改变的</span></div><div class="line">    [<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">self</span>.p1.name = <span class="string">@"123"</span>;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这个方法时属于 NSObject 类的，任何对象都可以作为观察者</span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到了%@的%@属性发生了改变"</span>, object, keyPath);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><h4 id="KVO是基于运行时实现的"><a href="#KVO是基于运行时实现的" class="headerlink" title="KVO是基于运行时实现的"></a>KVO是基于运行时实现的</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isa Class <span class="built_in">NSKVONotifying_Person</span>  <span class="number">0x000001a12de2f545</span></div></pre></td></tr></table></figure><p>上述例子中，当 p1.name 的值改变时，p1对象的 isa 指针会指向 <code>NSKVONotifying_Person</code>，意味着，在程序运行时，会动态生成一个 <code>NSKVONotifying_Person</code> 类，该类继承于 Person，而且该类中也有个  <code>-setName:</code> 方法，方法中在设置 <code>name</code> 的同时实现了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">   [<span class="keyword">super</span> setName:name];</div><div class="line"></div><div class="line">   <span class="comment">// 这两个方法底层会调用observer的- (void)observeValueForKeyPath: ofObject: change: context:这个方法</span></div><div class="line">   [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"age"</span>];</div><div class="line">   [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"age"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;KVO的具体实现&quot;&gt;&lt;a href=&quot;#KVO的具体实现&quot; class=&quot;headerlink&quot; title=&quot;KVO的具体实现&quot;&gt;&lt;/a&gt;KVO的具体实现&lt;/h4&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发ARC内存管理技术</title>
    <link href="http://yoursite.com/2017/10/20/iOS%E5%BC%80%E5%8F%91ARC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2017/10/20/iOS开发ARC内存管理技术/</id>
    <published>2017-10-20T14:12:01.000Z</published>
    <updated>2017-10-20T15:39:17.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS开发ARC内存管理技术"><a href="#iOS开发ARC内存管理技术" class="headerlink" title="iOS开发ARC内存管理技术"></a>iOS开发ARC内存管理技术</h3><p><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">苹果ARC官方文档</a></p><h4 id="ARC的本质"><a href="#ARC的本质" class="headerlink" title="ARC的本质"></a>ARC的本质</h4><blockquote><p>ARC是编译器（时）特性，而不是运行时特性，更不是垃圾回收器(GC)。  </p><blockquote><p>Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications.</p></blockquote><p>ARC只是相对于MRC（Manual Reference Counting或称为非ARC，下文中我们会一直使用MRC来指代非ARC的管理方式）的一次改进，但它和之前的技术本质上没有区别。具体信息可以参考<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">ARC编译器官方文档</a>。</p></blockquote><h4 id="ARC的开启与关闭"><a href="#ARC的开启与关闭" class="headerlink" title="ARC的开启与关闭"></a>ARC的开启与关闭</h4><blockquote><p>如果需要对特定文件开启或关闭ARC，可以在工程选项中选择Targets -&gt; Compile Phases -&gt; Compile Sources，在里面找到对应文件，添加flag:  </p><blockquote><ul><li>打开ARC：-fobjc-arc</li><li>关闭ARC：-fno-objc-arc</li></ul></blockquote><p>如图：<br><img src="http://oui2ar2u7.bkt.clouddn.com/1423188104210850.png" alt=""></p></blockquote><h4 id="ARC的修饰符"><a href="#ARC的修饰符" class="headerlink" title="ARC的修饰符"></a>ARC的修饰符</h4><blockquote><p>ARC主要提供了4种修饰符，他们分别是:<code>__strong</code>,<code>__weak</code>,<code>__autoreleasing</code>,<code>__unsafe_unretained</code>。 </p><p><code>__strong</code><br>表示引用为强引用。对应在定义property时的”strong”。所有对象只有当没有任何一个强引用指向时，才会被释放。<br>注意：如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置nil。</p><p><code>__weak</code><br>表示引用为弱引用。对应在定义property时用的”weak”。弱引用不会影响对象的释放，即只要对象没有任何强引用指向，即使有100个弱引用对象指向也没用，该对象依然会被释放。不过好在，对象在被释放的同时，指向它的弱引用会自动被置nil，这个技术叫zeroing weak pointer。这样有效得防止无效指针、野指针的产生。__weak一般用在delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑与生成的UI控件。  </p><p><code>__autoreleasing</code><br>表示在autorelease pool中自动释放对象的引用，和MRC时代autorelease的用法相同。定义property时不能使用这个修饰符，任何一个对象的property都不应该是autorelease型的。<br>一个常见的误解是，在ARC中没有autorelease，因为这样一个“自动释放”看起来好像有点多余。这个误解可能源自于将ARC的“自动”和autorelease“自动”的混淆。其实你只要看一下每个iOS App的main.m文件就能知道，autorelease不仅好好的存在着，并且变得更fashion了：不需要再手工被创建，也不需要再显式得调用[drain]方法释放内存池。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以下两行代码的意义是相同的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *str = [[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"hehe"</span>] autorelease]; <span class="comment">// MRC</span></div><div class="line"><span class="built_in">NSString</span> *__autoreleasing str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"hehe"</span>]; <span class="comment">// ARC</span></div></pre></td></tr></table></figure><p>关于autoreleasepool的详细地信息可以参考官方文档。<br> <code>__autoreleasing</code>在ARC中主要用在<strong>参数传递返回值（out-parameters）</strong>和<strong>引用传递参数（pass-by-reference）</strong>的情况下。  </p><blockquote><p>__autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return.  </p></blockquote><p>比如常用的NSError的使用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *__autoreleasing error; </div><div class="line"><span class="keyword">if</span>(![data writeToFile:filename options:<span class="built_in">NSDataWritingAtomic</span> error:&amp;error]) </div><div class="line">&#123; </div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（在上面的writeToFile方法中error参数的类型为(NSError <em> <code>__autoreleasing</code> </em>)）<br>注意，如果你的error定义为了strong型，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个__autoreleasing类型的引用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error; </div><div class="line"><span class="built_in">NSError</span> *__autoreleasing tempError = error; <span class="comment">// 编译器添加 </span></div><div class="line"><span class="keyword">if</span> (![data writeToFile:filename options:<span class="built_in">NSDataWritingAtomic</span> error:&amp;tempError]) </div><div class="line">&#123; </div><div class="line">    error = tempError; <span class="comment">// 编译器添加 </span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以为了提高效率，避免这种情况，我们一般在定义error的时候将其（老老实实地）声明为__autoreleasing类型的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *__autoreleasing error;</div></pre></td></tr></table></figure><p>在这里，加上__autoreleasing之后，相当于在MRC中对返回值error做了如下事情：  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*error = [[[<span class="built_in">NSError</span> alloc] init] autorelease];</div></pre></td></tr></table></figure><p><code>*error</code>指向的对象在创建出来后，被放入到了autoreleasing pool中，等待使用结束后的自动释放，函数外error的使用者并不需要关心 <code>*error</code>指向对象的释放。<br>另外一点，在ARC中，所有这种指针的指针 （NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为__autoreleasing类型。<br>比如下面的两段代码是等同的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)doSomething:(<span class="built_in">NSNumber</span> **)value</div><div class="line">&#123;</div><div class="line"><span class="comment">// do something </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)doSomething:(<span class="built_in">NSNumber</span> * __autoreleasing *)value</div><div class="line">&#123;</div><div class="line"><span class="comment">// do something </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除非你显式得给value声明了<code>__strong</code>，否则value默认就是<code>__autoreleasing</code>的。<br>最后一点，某些类的方法会隐式地使用自己的autorelease pool，在这种时候使用<code>__autoreleasing</code>类型要特别小心。<br>比如NSDictionary的[enumerateKeysAndObjectsUsingBlock]方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</div><div class="line">&#123;</div><div class="line">   [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</div><div class="line">     <span class="comment">// do stuff </span></div><div class="line">     <span class="keyword">if</span> (error != <span class="literal">nil</span>)</div><div class="line">     &#123;</div><div class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"MyError"</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</div><div class="line">     &#125;</div><div class="line">   &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>会隐式地创建一个autorelease pool，上面代码实际类似于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</div><div class="line">&#123;</div><div class="line">   [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> <span class="comment">// 被隐式创建</span></div><div class="line">    &#123;</div><div class="line">       <span class="keyword">if</span> (there is some error &amp;&amp; error != <span class="literal">nil</span>)</div><div class="line">      &#123;</div><div class="line">          *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"MyError"</span> ?code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"><span class="comment">// *error 在这里已经被dict的做枚举遍历时创建的autorelease pool释放掉了  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了能够正常的使用*error，我们需要一个strong型的临时引用，在dict的枚举Block中是用这个临时引用，保证引用指向的对象不会在出了dict的枚举Block后被释放，正确的方式如下：  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</div><div class="line">&#123;</div><div class="line">   __block <span class="built_in">NSError</span>* tempError; <span class="comment">// 加__block保证可以在Block内被修改 </span></div><div class="line">   [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)</div><div class="line">   &#123; </div><div class="line">      <span class="keyword">if</span> (there is some error) </div><div class="line">     &#123; </div><div class="line">       *tempError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"MyError"</span> ?code:<span class="number">1</span> userInfo:<span class="literal">nil</span>]; </div><div class="line">     &#125;  </div><div class="line">   &#125;] </div><div class="line">   <span class="keyword">if</span> (error != <span class="literal">nil</span>) </div><div class="line">   &#123; </div><div class="line">      *error = tempError; </div><div class="line">   &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>__unsafe_unretained</code><br>ARC是在iOS 5引入的，而这个修饰符主要是为了在ARC刚发布时兼容iOS 4以及版本更低的设备，因为这些版本的设备没有weak pointer system，简单的理解这个系统就是我们上面讲weak时提到的，能够在weak引用指向对象被释放后，把引用值自动设为nil的系统。这个修饰符在定义property时对应的是”unsafe_unretained”，实际可以将它理解为MRC时代的assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然原原本本地指向原来被释放的对象（所在的内存区域）。所以非常不安全。<br>现在可以完全忽略掉这个修饰符了，因为iOS 4早已退出历史舞台很多年。</p><p><strong>使用修饰符的正确姿势（方式）</strong><br>苹果的文档中明确地写道：  </p><blockquote><p>You should decorate variables correctly. When using qualifiers in an object variable declaration,<br>the correct format is:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClassName * qualifier variableName;</div></pre></td></tr></table></figure></blockquote><p>按照这个说明，要定义一个weak型的NSString引用，它的写法应该是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * __<span class="keyword">weak</span> str = <span class="string">@"hehe"</span>; <span class="comment">// 正确！</span></div></pre></td></tr></table></figure><p>而不应该是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *str = <span class="string">@"hehe"</span>; <span class="comment">// 错误！</span></div></pre></td></tr></table></figure><p>既然文档说上面的错误的，那为什么编译器不报错呢？文档又解释道：</p><blockquote><p>Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, see <a href="https://cdecl.org/" target="_blank" rel="external">http://cdecl.org/</a>.</p></blockquote><p>Apple考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误：）虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符，如果你以前也常常用错误的写法，那看到这里记得以后不要这么写了，哪天编译器怒了，再不支持错误的写法，就要郁闷了。<br>无论是被strong，weak还是autoreleasing修饰，声明在栈中的指针默认值都会是nil。所有这类型的指针不用再初始化的时候置nil了。虽然好习惯是最重要的，但是这个特性更加降低了“野指针”出现的可能性。<br>在ARC中，以下代码会输出null而不是crash:)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)myMethod </div><div class="line">&#123;</div><div class="line">   <span class="built_in">NSString</span> *name;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h4 id="ARC与Block"><a href="#ARC与Block" class="headerlink" title="ARC与Block"></a>ARC与Block</h4><blockquote><p>在MRC时代，Block会隐式地对进入其作用域内的对象（或者说被Block捕获的指针指向的对象）加retain，来确保Block使用到该对象时，能够正确的访问。<br>这件事情在下面代码展示的情况中要更加额外小心。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MyViewController *myController = [[MyViewController alloc] init…];</div><div class="line"><span class="comment">// 隐式地调用[myController retain];造成循环引用</span></div><div class="line">myController.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</div><div class="line">  [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;;</div><div class="line">[<span class="keyword">self</span> presentViewController:myController animated:<span class="literal">YES</span> completion:^&#123;</div><div class="line">   [myController release]; <span class="comment">// 注意，这里调用[myController release];是在MRC中的一个常规写法，并不能解决上面循环引用的问题</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure><p>在这段代码中，myController的completionHandler调用了myController的方法[dismissViewController…]，这时completionHandler会对myController做retain操作。而我们知道，myController对completionHandler也至少有一个retain（一般准确讲是copy），这时就出现了在内存管理中最糟糕的情况：循环引用！简单点说就是：myController retain了completionHandler，而completionHandler也retain了myController。循环引用导致了myController和completionHandler最终都不能被释放。我们在delegate关系中，对delegate指针用weak就是为了避免这种问题。<br>对这种情况，我们一般用如下方法解决：给要进入Block的指针加一个<strong>block修饰符。<br>这个</strong>block在MRC时代有两个作用：</p><blockquote><ul><li>说明变量可改</li><li>说明指针指向的对象不做这个隐式的retain操作</li></ul></blockquote><p>一个变量如果不加<code>__block</code>，是不能在Block里面修改的，不过这里有一个例外：static的变量和全局变量不需要加<code>__block</code>就可以在Block中修改。<br>使用这种方法，我们对代码做出修改，解决了循环引用的问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MyViewController * __block myController = [[MyViewController alloc] init…];</div><div class="line"><span class="comment">// ...</span></div><div class="line">myController.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</div><div class="line">  [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//之后正常的release或者retain</span></div></pre></td></tr></table></figure><p>在ARC引入后，没有了retain和release等操作，情况也发生了改变：在任何情况下，<strong>block修饰符的作用只有上面的第一条：说明变量可改。即使加上了</strong>block修饰符，一个被block捕获的强引用也依然是一个强引用。这样在ARC下，如果我们还按照MRC下的写法，completionHandler对myController有一个强引用，而myController对completionHandler有一个强引用，这依然是循环引用，没有解决问题:于是我们还需要对原代码做修改。简单的情况我们可以这样写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block MyViewController * myController = [[MyViewController alloc] init…];</div><div class="line"><span class="comment">// ...</span></div><div class="line">myController.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</div><div class="line">   [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">   myController = <span class="literal">nil</span>; <span class="comment">// 注意这里，保证了block结束myController强引用的解除</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在completionHandler之后将myController指针置nil，保证了completionHandler对myController强引用的解除，不过也同时解除了myController对myController对象的强引用。这种方法过于简单粗暴了，在大多数情况下，我们有更好的方法。<br>这个更好的方法就是使用weak。为了保证completionHandler这个Block对myController没有强引用，我们可以定义一个临时的弱引用weakMyViewController来指向原myController的对象，并把这个弱引用传入到Block内，这样就保证了Block对myController持有的是一个弱引用，而不是一个强引用。如此，我们继续修改代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MyViewController *myController = [[MyViewController alloc] init…];</div><div class="line"><span class="comment">// ...</span></div><div class="line">MyViewController * __<span class="keyword">weak</span> weakMyViewController = myController;</div><div class="line">myController.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</div><div class="line">   [weakMyViewController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这样循环引用的问题就解决了，但是却不幸地引入了一个新的问题：由于传入completionHandler的是一个弱引用，那么当myController指向的对象在completionHandler被调用前释放，那么completionHandler就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。<br>为了保证在Block内能够访问到正确的myController，我们在block内新定义一个强引用strongMyController来指向weakMyController指向的对象，这样多了一个强引用，就能保证这个myController对象不会在completionHandler被调用前释放掉了。于是，我们对代码再次做出修改：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyViewController *myController = [[MyViewController alloc] init…];</div><div class="line"><span class="comment">// ...</span></div><div class="line">MyViewController * __<span class="keyword">weak</span> weakMyController = myController;</div><div class="line">myController.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</div><div class="line">   MyViewController *strongMyController = weakMyController;</div><div class="line">   <span class="keyword">if</span> (strongMyController) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    [strongMyController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Probably nothing...</span></div><div class="line">    &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure><p>到此，一个完善的解决方案就完成了<br>可能有人会有疑问，不是说不希望Block对原myController对象增加强引用么，这里为什么堂而皇之地在Block内新定义了一个强引用，这个强引用不会造成循环引用么？理解这个问题的关键在于理解被Block捕获的引用和在Block内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block的实现原理，详细的内容可以参考<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">唐巧的文章</a>,<a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="external">正确使用Block</a>和<a href="http://blog.csdn.net/hherima/article/details/38586101" target="_blank" rel="external">【block第四篇】实现</a>。<br>为了更清楚地说明问题，这里用一个简单的程序举例。比如我们有如下程序:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include <span class="meta-string">&lt; stdio.h&gt;</span></span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</div><div class="line">  <span class="keyword">int</span> *a = &amp;b;</div><div class="line">  <span class="keyword">void</span> (^blockFunc)() = ^()&#123;</div><div class="line">    <span class="keyword">int</span> *c = a;</div><div class="line">  &#125;;</div><div class="line">  blockFunc();</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序中，同为int型的指针，a是被Block捕获的变量，而c是在Block内定义的变量。我们用clang -rewrite-objc处理后，可以看到如下代码：<br>原main函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</div><div class="line">  <span class="keyword">int</span> *a = &amp;b;</div><div class="line">  <span class="keyword">void</span> (*blockFunc)() = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);</div><div class="line">  ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blockFunc)-&gt;FuncPtr)((__block_impl *)blockFunc);</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Block的结构：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">int</span> *a; <span class="comment">// 被捕获的引用 a 出现在了block的结构体里面</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>实际执行的函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">  <span class="keyword">int</span> *a = __cself-&gt;a; <span class="comment">// bound by copy</span></div><div class="line">  <span class="keyword">int</span> *c = a; <span class="comment">// 在block中声明的引用 c 在函数中声明，存在于函数栈上</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以清楚得看到，a和c存在的位置完全不同，如果Block存在于堆上（在ARC下Block默认在堆上），那么a作为Block结构体的一个成员，也自然会存在于堆上，而c无论如何，永远位于Block内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c在Block的函数运行完毕，即会被释放，而a呢，只有在Block被从堆上释放的时候才会释放。<br>回到我们的MyViewController的例子中，同上理，如果我们直接让Block捕获我们的myController引用，那么这个引用会被复制后（引用类型也会被复制）作为Block的成员变量存在于其所在的堆空间中，也就是为Block增加了一个指向myController对象的强引用，这就是造成循环引用的本质原因。对于MyViewController的例子，Block的结构体可以理解是这个样子：（准确的结构体肯定和以下这个有区别，但也肯定是如下这种形式:)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  MyViewController * __<span class="keyword">strong</span> myController; <span class="comment">// 被捕获的强引用myController</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>而反观给Block传入一个弱引用weakMyController，这时我们Block的结构：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  MyViewController * __<span class="keyword">weak</span> weakMyController; <span class="comment">// 被捕获的弱引用weakMyController</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>再看在Block内声明的强引用strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，所以myController对象也一直存在，但是当函数执行完毕，strongMyController即被销毁，于是它对myController对象的强引用也被解除，这时Block对myController对象就不存在强引用关系了！加入了strongMyController的函数大体会是这个样子：  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">   MyViewController * __<span class="keyword">strong</span> strongMyController = __cself-&gt;weakMyController; </div><div class="line">   <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>综上所述，在ARC下（在MRC下会略有不同），Block捕获的引用和Block内声明的引用无论是存在空间与生命周期都是截然不同的，也正是这种不同，造成了我们对他们使用方式的区别。<br>最后再提一点，在ARC中，对Block捕获对象的内存管理已经简化了很多，由于没有了retain和release等操作，实际只需要考虑循环引用的问题就行了。比如下面这种，是没有内存泄露的问题的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TestObject *aObject = [[TestObject alloc] init];</div><div class="line">aObject.name = <span class="string">@"hehe"</span>;</div><div class="line"><span class="keyword">self</span>.aBlock = ^()&#123;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"aObject's name = %@"</span>,aObject.name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面提到的解决方案，只是针对Block产生循环引用的问题，而不是说所有的Block捕获引用都要这么处理，一定要注意！</p></blockquote><h4 id="ARC与Toll-Free-Bridging"><a href="#ARC与Toll-Free-Bridging" class="headerlink" title="ARC与Toll-Free Bridging"></a>ARC与Toll-Free Bridging</h4><blockquote><blockquote><p>There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message.  </p></blockquote><p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。详细的内容可参考<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="external">官方文档</a>。以下是官方文档中给出的一些例子： </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLocale</span> *gbNSLocale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_GB"</span>];</div><div class="line"><span class="built_in">CFLocaleRef</span> gbCFLocale = (<span class="built_in">CFLocaleRef</span>) gbNSLocale;</div><div class="line"><span class="built_in">CFStringRef</span> cfIdentifier = <span class="built_in">CFLocaleGetIdentifier</span> (gbCFLocale);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cfIdentifier: %@"</span>, (<span class="built_in">NSString</span> *)cfIdentifier);</div><div class="line"><span class="comment">// logs: "cfIdentifier: en_GB"</span></div><div class="line"><span class="built_in">CFRelease</span>((<span class="built_in">CFLocaleRef</span>) gbNSLocale);</div><div class="line"><span class="built_in">CFLocaleRef</span> myCFLocale = <span class="built_in">CFLocaleCopyCurrent</span>();</div><div class="line"><span class="built_in">NSLocale</span> * myNSLocale = (<span class="built_in">NSLocale</span> *) myCFLocale;</div><div class="line">[myNSLocale autorelease];</div><div class="line"><span class="built_in">NSString</span> *nsIdentifier = [myNSLocale localeIdentifier];</div><div class="line"><span class="built_in">CFShow</span>((<span class="built_in">CFStringRef</span>) [<span class="string">@"nsIdentifier: "</span> stringByAppendingString:nsIdentifier]);</div><div class="line"><span class="comment">// logs identifier for current locale</span></div></pre></td></tr></table></figure><p>在MRC时代，由于Objective-C类型的对象和Core Foundation类型的对象都是相同的release和retain操作规则，所以Toll-Free Bridging的使用比较简单，但是自从ARC加入后，Objective-C类型的对象内存管理规则改变了，而Core Foundation依然是之前的机制，换句话说，Core Foundation不支持ARC。<br>这个时候就必须要要考虑一个问题了，在做Core Foundation与Objective-C类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用Objective-C（也就是ARC）的规则，哪些对象用Core Foundation的规则（也就是MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership的改变。</p><blockquote><p>If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined inNSObject.h)  </p></blockquote><p>于是苹果在引入ARC之后对Toll-Free Bridging的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。<br>这些方法和修饰符分别是：<br><code>__bridge</code>（修饰符）<br>只是声明类型转变，但是不做内存管理规则的转变。<br>比如：  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> s1 = (__bridge <span class="built_in">CFStringRef</span>) [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello, %@!"</span>, name];</div></pre></td></tr></table></figure><p>只是做了NSString到CFStringRef的转化，但管理规则未变，依然要用Objective-C类型的ARC来管理s1，你不能用CFRelease()去释放s1。</p><p><code>__bridge_retained</code>（修饰符） or <code>CFBridgingRetain</code>（函数）<br>表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *s1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello, %@!"</span>, name];</div><div class="line"><span class="built_in">CFStringRef</span> s2 = (__bridge_retained <span class="built_in">CFStringRef</span>)s1;</div><div class="line"><span class="comment">// do something with s2</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="built_in">CFRelease</span>(s2); <span class="comment">// 注意要在使用结束后加这个</span></div></pre></td></tr></table></figure><p>我们在第二行做了转化，这时内存管理规则由ARC变为了MRC，我们需要手动的来管理s2的内存，而对于s1，我们即使将其置为nil，也不能释放内存。<br>等同的，我们的程序也可以写成：  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *s1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello, %@!"</span>, name];</div><div class="line"><span class="built_in">CFStringRef</span> s2 = (<span class="built_in">CFStringRef</span>)<span class="built_in">CFBridgingRetain</span>(s1);</div><div class="line"><span class="comment">// do something with s2</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="built_in">CFRelease</span>(s2); <span class="comment">// 注意要在使用结束后加这个</span></div></pre></td></tr></table></figure><p><code>__bridge_transfer</code>（修饰符） or <code>CFBridgingRelease</code>（函数）<br>这个修饰符和函数的功能和上面那个<code>__bridge_retained</code>相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。<br>比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> result = <span class="built_in">CFURLCreateStringByAddingPercentEscapes</span>(. . .);</div><div class="line"><span class="built_in">NSString</span> *s = (__bridge_transfer <span class="built_in">NSString</span> *)result;</div><div class="line"><span class="comment">//or NSString *s = (NSString *)CFBridgingRelease(result);</span></div><div class="line"><span class="keyword">return</span> s;</div></pre></td></tr></table></figure><p>这里我们将result的管理责任交给了ARC来处理，我们就不需要再显式地将CFRelease()了。<br>对了，这里你可能会注意到一个细节，和ARC中那个4个主要的修饰符（<strong>strong,</strong>weak,…）不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但看官方的头文件可以知道。小伙伴们，记得别把位置写错哦<br><img src="http://oui2ar2u7.bkt.clouddn.com/1423188109714234.png" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iOS开发ARC内存管理技术&quot;&gt;&lt;a href=&quot;#iOS开发ARC内存管理技术&quot; class=&quot;headerlink&quot; title=&quot;iOS开发ARC内存管理技术&quot;&gt;&lt;/a&gt;iOS开发ARC内存管理技术&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://devel
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CALayer 和UIView的区别和联系</title>
    <link href="http://yoursite.com/2017/10/20/CALayer-%E5%92%8CUIView%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
    <id>http://yoursite.com/2017/10/20/CALayer-和UIView的区别和联系/</id>
    <published>2017-10-20T14:11:46.000Z</published>
    <updated>2017-11-12T13:24:05.091Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CALayer-和UIView的区别和联系"><a href="#CALayer-和UIView的区别和联系" class="headerlink" title="CALayer 和UIView的区别和联系"></a>CALayer 和UIView的区别和联系</h4><blockquote><ul><li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li><li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li><li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li><li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;CALayer-和UIView的区别和联系&quot;&gt;&lt;a href=&quot;#CALayer-和UIView的区别和联系&quot; class=&quot;headerlink&quot; title=&quot;CALayer 和UIView的区别和联系&quot;&gt;&lt;/a&gt;CALayer 和UIView的区别和联系&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小知识点2</title>
    <link href="http://yoursite.com/2017/10/20/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B92/"/>
    <id>http://yoursite.com/2017/10/20/小知识点2/</id>
    <published>2017-10-20T14:11:20.000Z</published>
    <updated>2017-10-20T14:17:02.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><blockquote><p>进程（process）是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。 进程中所包含的一个或多个执行单元称为线程（thread）。进程还拥有一个私有的虚拟地址空间，该空间仅能被它所包含的线程访问。 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。 在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。 由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.一个程序就是一个进程，而一个程序中的多个任务则被称为线程。 线程只能归属于一个进程并且它只能访问该进程所拥有的资源。当操作系统创建一个进程后，该进程会自动申请一个名为主线程或首要线程的线程。应用程序（application）是由一个或多个相互协作的进程组成的。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p></blockquote><h4 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h4><blockquote><p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。 程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p></blockquote><h3 id="socket连接和http连接"><a href="#socket连接和http连接" class="headerlink" title="socket连接和http连接"></a>socket连接和http连接</h3><h4 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h4><blockquote><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中。 http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 HTTP协议的主要特点可概括如下： 1 支持客户/服务器模式。 2 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p></blockquote><h4 id="socket连接和http连接的区别"><a href="#socket连接和http连接的区别" class="headerlink" title="socket连接和http连接的区别"></a>socket连接和http连接的区别</h4><blockquote><p>简单说，你浏览的网页（网址以<a href="http://开头)都是http协议传输到你的浏览器的" target="_blank" rel="external">http://开头)都是http协议传输到你的浏览器的</a>, 而http是基于socket之上的。socket是一套完成tcp，udp协议的接口。 HTTP协议：简单对象访问协议，对应于应用层 ，HTTP协议是基于TCP连接的 tcp协议：对应于传输层 ip协议：对应于网络层 TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。 Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 http连接：http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉； socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据的传输，那么为了维持连接需要发送心跳消息~~具体心跳消息格式是开发者自己定义的 我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。 1)Socket是一个针对TCP和UDP编程的接口，你可以借助它建立TCP连接等等。而TCP和UDP协议属于传输层 。 而http是个应用层的协议，它实际上也建立在TCP协议之上。 (HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。) 2）Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h3&gt;&lt;h4 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件上传与下载</title>
    <link href="http://yoursite.com/2017/10/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2017/10/20/文件上传与下载/</id>
    <published>2017-10-20T14:11:06.000Z</published>
    <updated>2017-10-20T15:55:03.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><h4 id="如果文件比较小，下载方式会比较多"><a href="#如果文件比较小，下载方式会比较多" class="headerlink" title="如果文件比较小，下载方式会比较多"></a>如果文件比较小，下载方式会比较多</h4><blockquote><ul><li>直接用NSData的+ (id)dataWithContentsOfURL:(NSURL *)url;</li><li>利用NSURLConnection发送一个HTTP请求去下载</li><li>如果是下载图片，还可以利用<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>框架</li></ul></blockquote><h4 id="大文件下载"><a href="#大文件下载" class="headerlink" title="大文件下载"></a>大文件下载</h4><blockquote><ul><li>方案一：利用NSURLConnection和它的代理方法  </li></ul><blockquote><p>1.发送一个请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.URL</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://localhost:8080/MJServer/resources/videos.zip"</span>];</div><div class="line"><span class="comment">// 2.请求</span></div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line"><span class="comment">// 3.下载(创建完conn对象后，会自动发起一个异步请求)</span></div><div class="line">[<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</div></pre></td></tr></table></figure><p>2.在代理方法中处理服务器返回的数据  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 在接收到服务器的响应时：</div><div class="line"> 1.创建一个空的文件</div><div class="line"> 2.用一个句柄对象关联这个空的文件，目的是：方便后面用句柄对象往文件后面写数据</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 文件路径</span></div><div class="line">    <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *filepath = [caches stringByAppendingPathComponent:<span class="string">@"videos.zip"</span>];</div><div class="line">    <span class="comment">// 创建一个空的文件 到 沙盒中</span></div><div class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    [mgr createFileAtPath:filepath contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">// 创建一个用来写数据的文件句柄</span></div><div class="line">    <span class="keyword">self</span>.writeHandle = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:filepath];</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> 在接收到服务器返回的文件数据时，利用句柄对象往文件的最后面追加数据</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 移动到文件的最后面</span></div><div class="line">    [<span class="keyword">self</span>.writeHandle seekToEndOfFile];</div><div class="line">    <span class="comment">// 将数据写入沙盒</span></div><div class="line">    [<span class="keyword">self</span>.writeHandle writeData:data];</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> 在所有数据接收完毕时，关闭句柄对象</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 关闭文件</span></div><div class="line">    [<span class="keyword">self</span>.writeHandle closeFile];</div><div class="line">    <span class="keyword">self</span>.writeHandle = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意点：千万不能用NSMutableData来拼接服务器返回的数据 </p><p>3.断点续传  </p><blockquote><p>通过设置请求头Range可以指定每次从网路下载数据包的大小<br>Range示例<br>bytes=0-499  从0到499的头500个字节<br>bytes=500-999  从500到999的第二个500字节<br>bytes=500-  从500字节以后的所有字节  </p><p>bytes=-500  最后500个字节<br>bytes=500-599,800-899  同时指定几个范围<br>Range小结:<br><strong>-</strong>用于分隔,前面的数字表示起始字节数,后面的数组表示截止字节数，没有表示到末尾,用于分组，可以一次指定多个Range，不过很少用  </p></blockquote></blockquote><ul><li>方案二：NSURLConnection发送异步请求的方法</li></ul><blockquote><p>1.block形式 - 除开大文件下载以外的操作，都可以用这种形式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:&lt;<span class="meta">#(NSURLRequest *)#&gt; queue:<span class="meta-string">&lt;#(NSOperationQueue *)#&gt;</span> completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123;   </span></div><div class="line">&#125;];</div><div class="line">```  </div><div class="line">&gt;&gt;<span class="number">2.</span>代理形式 - 一般用在大文件下载   </div><div class="line"></div><div class="line">&gt;&gt;```objectivec</div><div class="line"><span class="comment">// 1.URL</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://localhost:8080/MJServer/login?username=123&amp;pwd=123"</span>];</div><div class="line"><span class="comment">// 2.请求</span></div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line"><span class="comment">// 3.下载(创建完conn对象后，会自动发起一个异步请求)</span></div><div class="line">[<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</div></pre></td></tr></table></figure></blockquote><ul><li>方案三：NSURLSession</li></ul><blockquote><p>1.使用步骤  </p><ul><li>获得NSURLSession对象</li><li>利用NSURLSession对象创建对应的任务（Task）</li><li>开始任务（[task resume]）</li></ul><p>2.获得NSURLSession对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSURLSession</span> sharedSession]</div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *cfg = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cfg delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div></pre></td></tr></table></figure><p>3.任务类型  </p><p><strong>NSURLSessionDataTask</strong>  </p><blockquote><p>用途：用于非文件下载的GET\POST请求</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span>.session dataTaskWithURL:url];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span>.session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</div><div class="line"><span class="comment">//download something ...   </span></div><div class="line">&#125;];</div></pre></td></tr></table></figure><p><strong>NSURLSessionDownloadTask</strong></p><blockquote><p>用途：用于文件下载（小文件、大文件）</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [<span class="keyword">self</span>.session downloadTaskWithRequest:request];</div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [<span class="keyword">self</span>.session downloadTaskWithURL:url];</div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [<span class="keyword">self</span>.session downloadTaskWithURL:url completionHandler:^(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="comment">//download something ...</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure><p>4、下载大文件</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *cfg = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">    <span class="comment">// 1.得到session对象</span></div><div class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cfg delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div><div class="line">    <span class="comment">// 2.创建一个下载task</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://localhost:8080/MJServer/resources/test.mp4"</span>];</div><div class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithURL:url];</div><div class="line">    <span class="comment">// 3.开始任务</span></div><div class="line">    [task resume];</div><div class="line">    <span class="comment">// 如果给下载任务设置了completionHandler这个block，也实现了下载的代理方法，优先执行block</span></div><div class="line"><span class="meta">#pragma mark - NSURLSessionDownloadDelegate</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  下载完毕后调用</div><div class="line"> *</div><div class="line"> *  @param location     临时文件的路径（下载好的文件）</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</div><div class="line">&#123;</div><div class="line">    <span class="comment">// location : 临时文件的路径（下载好的文件）</span></div><div class="line">    <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="comment">// response.suggestedFilename ： 建议使用的文件名，一般跟服务器端的文件名一致 </span></div><div class="line">    <span class="built_in">NSString</span> *file = [caches stringByAppendingPathComponent:downloadTask.response.suggestedFilename];</div><div class="line">    <span class="comment">// 将临时文件剪切或者复制Caches文件夹</span></div><div class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="comment">// AtPath : 剪切前的文件路径</span></div><div class="line">    <span class="comment">// ToPath : 剪切后的文件路径</span></div><div class="line">    [mgr moveItemAtPath:location.path toPath:file error:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  恢复下载时调用</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</div><div class="line">&#123;</div><div class="line">   <span class="comment">// ....</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  每当下载完（写完）一部分时就会调用（可能会被调用多次）</div><div class="line"> *</div><div class="line"> *  @param bytesWritten              这次调用写了多少</div><div class="line"> *  @param totalBytesWritten         累计写了多少长度到沙盒中了</div><div class="line"> *  @param totalBytesExpectedToWrite 文件的总长度</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> progress = (<span class="keyword">double</span>)totalBytesWritten / totalBytesExpectedToWrite;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载进度---%f"</span>, progress);</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote></blockquote><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>文件上传的步骤<br>1.设置请求头  </p><blockquote><p>目的：告诉服务器请求体里面的内容并非普通的参数，而是包含了文件参数</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[request setValue:<span class="string">@"multipart/form-data; boundary=heima"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div></pre></td></tr></table></figure><p>2.设置请求体</p><blockquote><p>作用：存放参数（文件参数和非文件参数）  </p></blockquote><p>非文件参数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[body appendData:HMEncode(<span class="string">@"--heima\r\n"</span>)];</div><div class="line">[body appendData:HMEncode(<span class="string">@"Content-Disposition: form-data; name=\"username\"\r\n"</span>)];</div><div class="line">[body appendData:HMEncode(<span class="string">@"\r\n"</span>)];</div><div class="line">[body appendData:HMEncode(<span class="string">@"张三"</span>)];</div><div class="line">[body appendData:HMEncode(<span class="string">@"\r\n"</span>)];</div></pre></td></tr></table></figure><p>文件参数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[body appendData:HMEncode(<span class="string">@"--heima\r\n"</span>)];</div><div class="line">[body appendData:HMEncode(<span class="string">@"Content-Disposition: form-data; name=\"file\"; filename=\"test123.png\"\r\n"</span>)];</div><div class="line">[body appendData:HMEncode(<span class="string">@"Content-Type: image/png\r\n"</span>)];</div><div class="line">[body appendData:HMEncode(<span class="string">@"\r\n"</span>)];</div><div class="line">[body appendData:imageData];</div><div class="line">[body appendData:HMEncode(<span class="string">@"\r\n"</span>)];</div></pre></td></tr></table></figure><p>结束标记 ：参数结束的标记</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[body appendData:HMEncode(<span class="string">@"--heima--\r\n"</span>)];</div></pre></td></tr></table></figure></blockquote><h3 id="文件的MIMEType"><a href="#文件的MIMEType" class="headerlink" title="文件的MIMEType"></a>文件的MIMEType</h3><blockquote><p>如何获得文件的MIMEType  </p><p>1.百度搜索  </p><p>2.查找服务器下面的某个xml文件<br>apache-tomcat-6.0.41\conf\web.xml</p><p>3.加载文件时通过Reponse获得</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)MIMEType:(<span class="built_in">NSURL</span> *)url</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1.创建一个请求</span></div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line">    <span class="comment">// 2.发送请求（返回响应）</span></div><div class="line">    <span class="built_in">NSURLResponse</span> *response = <span class="literal">nil</span>;</div><div class="line">    [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">// 3.获得MIMEType</span></div><div class="line">    <span class="keyword">return</span> response.MIMEType;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.通过C语言函数  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSString</span> *)mimeTypeForFileAtPath:(<span class="built_in">NSString</span> *)path</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> alloc] init] fileExistsAtPath:path]) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">CFStringRef</span>  UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (<span class="built_in">CFStringRef</span>)[path pathExtension], <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">CFStringRef</span> MIMEType = UTTypeCopyPreferredTagWithClass (UTI, kUTTagClassMIMEType);</div><div class="line">    <span class="built_in">CFRelease</span>(UTI);</div><div class="line"><span class="keyword">if</span> (!MIMEType) &#123;</div><div class="line"><span class="keyword">return</span> <span class="string">@"application/octet-stream"</span>;</div><div class="line">&#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSMakeCollectable</span>(MIMEType);</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h3 id="文件解压缩"><a href="#文件解压缩" class="headerlink" title="文件解压缩"></a>文件解压缩</h3><blockquote><p>1.技术方案  </p><blockquote><p>1).第三方框架：<a href="https://github.com/ZipArchive/ZipArchive" target="_blank" rel="external">SSZipArchive</a><br>2).依赖的动态库：libz.dylib  </p></blockquote><p>2.压缩</p><blockquote><p>1).第一个方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> zipFile ：产生的zip文件的最终路径</div><div class="line"> directory ： 需要进行的压缩的文件夹路径</div><div class="line"> */</div><div class="line">[SSZipArchive createZipFileAtPath:zipFile withContentsOfDirectory:directory];</div></pre></td></tr></table></figure><p>2.第二个方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> zipFile ：产生的zip文件的最终路径</div><div class="line"> files ： 这是一个数组，数组里面存放的是需要压缩的文件的路径</div><div class="line"> files = @[@"/Users/apple/Destop/1.png", @"/Users/apple/Destop/3.txt"]</div><div class="line"> */</div><div class="line">[SSZipArchive createZipFileAtPath:zipFile withFilesAtPaths:files];</div></pre></td></tr></table></figure></blockquote><p>3.解压缩</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> zipFile ：需要解压的zip文件的路径</div><div class="line"> dest ： 解压到什么地方</div><div class="line"> */</div><div class="line">[SSZipArchive unzipFileAtPath:zipFile toDestination:dest];</div></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件下载&quot;&gt;&lt;a href=&quot;#文件下载&quot; class=&quot;headerlink&quot; title=&quot;文件下载&quot;&gt;&lt;/a&gt;文件下载&lt;/h3&gt;&lt;h4 id=&quot;如果文件比较小，下载方式会比较多&quot;&gt;&lt;a href=&quot;#如果文件比较小，下载方式会比较多&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://yoursite.com/2017/10/20/%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/10/20/网络/</id>
    <published>2017-10-20T14:10:19.000Z</published>
    <updated>2017-10-20T17:05:46.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="一个HTTP请求的基本要素"><a href="#一个HTTP请求的基本要素" class="headerlink" title="一个HTTP请求的基本要素"></a>一个HTTP请求的基本要素</h4><blockquote><p>1.请求URL：客户端通过哪个路径找到服务器</p><p>2.请求参数：客户端发送给服务器的数据</p><blockquote><p>比如登录时需要发送的用户名和密码</p></blockquote><p>3.返回结果：服务器返回给客户端的数据</p><blockquote><p>一般是JSON数据或者XML数据</p></blockquote></blockquote><h4 id="基本的HTTP请求的步骤（移动客户端）"><a href="#基本的HTTP请求的步骤（移动客户端）" class="headerlink" title="基本的HTTP请求的步骤（移动客户端）"></a>基本的HTTP请求的步骤（移动客户端）</h4><blockquote><p>1.拼接”请求URL” + “?” + “请求参数”</p><blockquote><p>请求参数的格式：参数名=参数值<br>多个请求参数之间用&amp;隔开：参数名1=参数值1&amp;参数名2=参数值2<br>比如：<a href="http://localhost:8080/MJServer/login?username=123&amp;pwd=456" target="_blank" rel="external">http://localhost:8080/MJServer/login?username=123&amp;pwd=456</a>  </p></blockquote><p>2.发送请求</p><p>3.解析服务器返回的数据</p></blockquote><h4 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h4><blockquote><p>1.利用NSJSONSerialization类解析</p><blockquote><p>JSON数据（NSData） –&gt; Foundation-OC对象（NSDictionary、NSArray、NSString、NSNumber）</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)JSONObjectWithData:(<span class="built_in">NSData</span> *)data options:(<span class="built_in">NSJSONReadingOptions</span>)opt error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure><p>2.JSON解析规律</p><blockquote><p>{ } –&gt; NSDictionary @{ }<br>[ ] –&gt; NSArray @[ ]<br>“ “ –&gt; NSString @” “<br>10 –&gt; NSNumber @10</p></blockquote></blockquote><h4 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h4><blockquote><p>1.发布异步请求01–block回调  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span>*) request</div><div class="line">    queue:(<span class="built_in">NSOperationQueue</span>*) queue</div><div class="line">    completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>* response, <span class="built_in">NSData</span>* data, <span class="built_in">NSError</span>* connectionError)) handler</div></pre></td></tr></table></figure><blockquote><p><strong>request</strong> : 需要发送的请求<br><strong>queue</strong> : 一般用主队列，存放handler这个任务<br><strong>handler</strong> : 当请求完毕后，会自动调用这个block  </p></blockquote><p>2.利用NSURLConnection发送请求的基本步骤</p><blockquote><p>1.创建URL</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://4234324/5345345"</span>];</div></pre></td></tr></table></figure><p>2.创建request</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div></pre></td></tr></table></figure><p>3.发送请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:queue completionHandler:</div><div class="line"> ^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</div><div class="line">     <span class="comment">// 处理服务器返回的数据</span></div><div class="line"> &#125;];</div></pre></td></tr></table></figure></blockquote></blockquote><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><blockquote><p>1.语法  </p><blockquote><p>1)文档声明  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div></pre></td></tr></table></figure><p>2)元素<br>3)属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;videos&gt;</div><div class="line">    &lt;video name=&quot;小黄人 第01部&quot; length=&quot;10&quot;/&gt;</div><div class="line">    &lt;video name=&quot;小黄人 第01部&quot; length=&quot;10&quot;/&gt;</div><div class="line">&lt;/videos&gt;</div></pre></td></tr></table></figure><blockquote><p>videos和video是元素（节点）<br>name和length叫做元素的属性<br>video元素是videos元素的子元素</p></blockquote></blockquote><p>2.解析</p><blockquote><p>1) SAX解析：逐个元素往下解析，适合大文件</p><blockquote><p>NSXMLParser</p></blockquote><p>DOM解析：一口气将整个XML文档加载进内存，适合小文件，使用最简单  </p><blockquote><p>GDataXML</p></blockquote></blockquote></blockquote><h4 id="HTTP的通信过程"><a href="#HTTP的通信过程" class="headerlink" title="HTTP的通信过程"></a>HTTP的通信过程</h4><blockquote><p>1.请求</p><blockquote><p>1)请求行 : 请求方法、请求路径、HTTP协议的版本  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /MJServer/resources/images/1.jpg HTTP/1.1</div></pre></td></tr></table></figure><p>2)请求头 : 客户端的一些描述信息</p><blockquote><p>User-Agent : 客户端的环境（软件环境）</p></blockquote><p>3)请求体 : POST请求才有这个东西</p><blockquote><p>请求参数，发给服务器的数据</p></blockquote></blockquote><p>2.响应</p><blockquote><p>1)状态行（响应行）: HTTP协议的版本、响应状态码、响应状态描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div></pre></td></tr></table></figure><p>2).响应头：服务器的一些描述信息  </p><blockquote><p>Content-Type : 服务器返回给客户端的内容类型<br>Content-Length : 服务器返回给客户端的内容的长度（比如文件的大小）</p></blockquote><p>3).实体内容（响应体）</p><blockquote><p>服务器返回给客户端具体的数据，比如文件数据</p></blockquote></blockquote></blockquote><h4 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h4><blockquote><p>1.GET</p><blockquote><p>1)特点</p><blockquote><p>所有请求参数都拼接在url后面</p></blockquote><p>2)缺点</p><blockquote><p>在url中暴露了所有的请求数据，不太安全<br>url的长度有限制，不能发送太多的参数</p></blockquote><p>3)使用场合</p><blockquote><p>如果仅仅是向服务器索要数据，一般用GET请求</p></blockquote><p>4)如何发送一个GET请求</p><blockquote><p>默认就是GET请求</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.URL</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com"</span>];</div><div class="line"><span class="comment">// 2.请求</span></div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line"><span class="comment">// 3.发送请求</span></div><div class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></blockquote></blockquote><p>2.POST</p><blockquote><p>1)特点</p><blockquote><p>把所有请求参数放在请求体（HTTPBody）中<br>理论上讲，发给服务器的数据的大小是没有限制</p></blockquote><p>2)使用场合</p><blockquote><p>除开向服务器索要数据以外的请求，都可以用POST请求<br>如果发给服务器的数据是一些隐私、敏感的数据，绝对要用POST请求</p></blockquote><p>3)如何发送一个POST请求</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.创建一个URL ： 请求路径</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://localhost:8080/MJServer/login"</span>];</div><div class="line"><span class="comment">// 2.创建一个请求</span></div><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</div><div class="line"><span class="comment">// 设置请求方法</span></div><div class="line">request.HTTPMethod = <span class="string">@"POST"</span>;</div><div class="line"><span class="comment">// 设置请求体 : 请求参数</span></div><div class="line"><span class="built_in">NSString</span> *param = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"username=%@&amp;pwd=%@"</span>, usernameText, pwdText];</div><div class="line"><span class="comment">// NSString --&gt; NSData</span></div><div class="line">request.HTTPBody = [param dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div></pre></td></tr></table></figure></blockquote></blockquote></blockquote><h4 id="NSMutableURLRequest的常用方法"><a href="#NSMutableURLRequest的常用方法" class="headerlink" title="NSMutableURLRequest的常用方法"></a>NSMutableURLRequest的常用方法</h4><blockquote><p>设置超时 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">request.timeoutInterval = <span class="number">5</span>; <span class="comment">// NSURLRequest是不能设置超时的，因为这个对象是不可变的</span></div></pre></td></tr></table></figure></blockquote><h4 id="URL转码"><a href="#URL转码" class="headerlink" title="URL转码"></a>URL转码</h4><blockquote><p>URL中不能包含中文，得对中文进行转码(加上一堆的%)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *urlStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"http://localhost/login?username=喝喝&amp;pwd=123"</span>];</div><div class="line">urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"><span class="comment">// urlStr == @"http://localhost/login?username=%E5%96%9D%E5%96%9D&amp;pwd=123"</span></div></pre></td></tr></table></figure></blockquote><h4 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h4><blockquote><p>1.网络数据加密  </p><blockquote><p>1)加密对象：隐私数据，比如密码、银行信息<br>2)加密方案</p><blockquote><p>提交隐私数据，必须用POST请求<br>使用加密算法对隐私数据进行加密，比如MD5</p></blockquote><p>3) 加密增强：为了加大破解的难度</p><blockquote><p>对明文进行2次MD5 ： MD5(MD5($pass))<br>先对明文撒盐，再进行MD5 ： MD5($pass.$salt)</p></blockquote></blockquote><p>2.本地存储加密</p><blockquote><p>1)加密对象：重要的数据，比如游戏数据</p></blockquote><p>3.代码安全问题</p><blockquote><p>1)现在已经有工具和技术能反编译出源代码：逆向工程</p><blockquote><p>反编译出来的都是纯C语言的，可读性不高<br>最起码能知道源代码里面用的是哪些框架</p></blockquote><p>2)参考书籍：《iOS逆向工程》<br>3)解决方案：发布之前对代码进行混淆</p><blockquote><p>混淆之前</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HMPerson</span> :<span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line">- (<span class="keyword">void</span>)eat;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>混淆之后</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> :<span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)a;</div><div class="line">- (<span class="keyword">void</span>)b;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></blockquote></blockquote></blockquote><h4 id="监测网络状态"><a href="#监测网络状态" class="headerlink" title="监测网络状态"></a>监测网络状态</h4><blockquote><p>1.主动监测监测网络状态</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 是否WIFI</span></div><div class="line">+ (<span class="built_in">BOOL</span>)isEnableWIFI &#123;</div><div class="line">    <span class="keyword">return</span> ([[Reachability reachabilityForLocalWiFi] currentReachabilityStatus] != NotReachable);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 是否4G</span></div><div class="line">+ (<span class="built_in">BOOL</span>)isEnable3G &#123;</div><div class="line">    <span class="keyword">return</span> ([[Reachability reachabilityForInternetConnection] currentReachabilityStatus] != NotReachable);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.监控网络状态</p><blockquote><p>1)监听通知</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkStateChange) name:kReachabilityChangedNotification object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure><p>2)开始监听网络状态</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获得Reachability对象</span></div><div class="line"><span class="keyword">self</span>.reachability = [Reachability reachabilityForInternetConnection];</div><div class="line"><span class="comment">// 开始监控网络</span></div><div class="line">[<span class="keyword">self</span>.reachability startNotifier];</div></pre></td></tr></table></figure><p>3)移除监听</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.reachability stopNotifier];</div><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h3&gt;&lt;h4 id=&quot;一个HTTP请求的基本要素&quot;&gt;&lt;a href=&quot;#一个HTTP请求的基本要素&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试逻辑题</title>
    <link href="http://yoursite.com/2017/10/20/%E9%9D%A2%E8%AF%95%E9%80%BB%E8%BE%91%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/20/面试逻辑题/</id>
    <published>2017-10-20T14:10:02.000Z</published>
    <updated>2017-11-12T13:23:41.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑题"><a href="#逻辑题" class="headerlink" title="逻辑题"></a>逻辑题</h2><p>1、假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水？  </p><blockquote><p>由满6向空5倒，剩1升，把这1升倒5里，然后6剩满，倒5里面，由于5里面有1升水，因此6只能向5倒4升水，然后将6剩余的2升，倒入空的5里面，再灌满6向5里倒3升，剩余3升。</p></blockquote><p>2、周雯的妈妈是豫林水泥厂的化验员。一天，周雯来到化验室做作业。做完后想出去玩。”等等，妈妈还要考你一个题目，”她接着说，”你看这6只做化验用的玻璃杯，前面3只盛满了水，后面3只是空的。你能只移动1只玻璃杯，就便盛满水的杯子和空杯子间隔起来吗?”爱动脑筋的周雯，是学校里有名的”小机灵”，她只想了一会儿就做到了。请你想想看，”小机灵”是怎样做的?</p><blockquote><p>设杯子编号为ABCDEF，ABC为满，DEF为空，把B中的水倒进E中即可。</p></blockquote><p>3、三个小伙子同时爱上了一个姑娘，为了决定他们谁能娶这个姑娘，他们决定用枪进行一次决斗。小李的命中率是30％，小黄比他好些，命中率是50％，最出色的枪手是小林，他从不失误，命中率是100％。由于这个显而易见的事实，为公平起见，他们决定按这样的顺序：小李先开枪，小黄第二，小林最后。然后这样循环，直到他们只剩下一个人。那么这三个人中谁活下来的机会最大呢？他们都应该采取什么样的策略？</p><blockquote><p>我们把他们三个叫做30、50和100吧 50一定会杀100，因为100肯定优先杀50。所以50最优策略是杀100，而100最优是杀50.30最想看到的结果是100死了，而自己又杀了50，但他又不敢先杀50，因为万一50死了，自己肯定被100杀。所以30最优是也杀100，然后再杀50。 所以行动顺序肯定是这样的，30第一动杀100,50第二动杀100,100第三动杀50，然后30第四动杀100,100第五动杀30 存活机率： 100获胜：第一、第二、第四均失败，概率为<code>0.7*0.5*0.7=0.245</code> 50获胜：两种情况，第一种：第一动失败，第二动成功，而后30杀50失败，50杀30成功(这里可能出现30和50反复杀的情况，是一个等比数列)，概率为<code>0.7*0.5*0.7*S</code>，而S是个首项为0.5，公比为<code>0.7*0.5</code>的等比数列的前N项和，经过计算S=0.77，所以50获胜概率为0.188 第二种：30杀了100,50和30反复杀，最后50赢，计算方法类似，概率为0.231 50获胜总概率为0.419 30获胜：三种情况，第一种简单些：第一、二动失败，100杀了50，然后30杀了100(因为此时不杀100必然被100杀)，所以这种概率是<code>0.7*0.5*0.3=0.105</code> 第二种情况和50获胜第一种情况类似：第一动失败，二动成功，然后30和50反复杀，最后30获胜，也是个等比数列，经过计算S=0.46，这种概率是0.162 第三种情况和50获胜第二种情况类似：计算后，概率是0.069 30总概率是0.336 通过验算我们发现3个人获胜的概率和是1，说明计算正确。而且可以得出30获胜的简便算法，就是用1减去100和50的获胜概率~</p></blockquote><p>4、一间囚房里关押着两个犯人。每天监狱都会为这间囚房提供一罐汤，让这两个犯人自己来分。起初，这两个人经常会发生争执，因为他们总是有人认为对方的汤比自己的多。后来他们找到了一个两全其美的办法：一个人分汤，让另一个人先选。于是争端就这么解决了。可是，现在这间囚房里又加进来一个新犯人，现在是三个人来分汤。必须寻找一个新的方法来维持他们之间的和平。该怎么办呢？按：心理问题，不是逻辑问题</p><blockquote><p>让甲分汤，分好后由乙和丙按任意顺序给自己挑汤，剩余一碗留给甲。这样乙和丙两人的总和肯定是他们两人可拿到的最大。然后将他们两人的汤混合之后再按两人的方法再次分汤。</p></blockquote><p>5、在一张长方形的桌面上放了n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖。</p><blockquote><p>要想让新放的硬币不与原先的硬币重叠，两个硬币的圆心距必须大于直径。也就是说，对于桌面上任意一点，到最近的圆心的距离都小于2，所以，整个桌面可以用n个半径为2的硬币覆盖。<br>把桌面和硬币的尺度都缩小一倍，那么，长、宽各是原桌面一半的小桌面，就可以用n个半径为1的硬币覆盖。那么，把原来的桌子分割成相等的4块小桌子，那么每块小桌子都可以用n个半径为1的硬币覆盖，因此，整个桌面就可以用4n个半径为1的硬币覆盖。</p></blockquote><p>6、一个球、一把长度大约是球的直径2/3长度的直尺，你怎样测出球的半径？方法很多，看看谁的比较巧妙</p><blockquote><p>切线(把球放在水平面上，直尺垂直于水平面上，直尺垂直于水平面，靠近球体，接触点到水平面的距离为半径，即接触点的读数就是半径) </p></blockquote><p>7、五个大小相同的一元人民币硬币。要求两两接触，应该怎么摆？</p><blockquote><p>底下放一个1，然后2 3放在1上面，另外的4 5竖起来放在1的上面<br><img src="http://oui2ar2u7.bkt.clouddn.com/222208423311115.jpg" alt=""></p></blockquote><p>8、猜牌问题S先生、P先生、Q先生他们知道桌子的抽屉里有16张扑克牌：红桃A、Q、4，黑桃J、8、4、2、7、3，草花K、Q、5、4、6，方块A、5。约翰教授从这16张牌中挑出一张牌来，并把这张牌的点数告诉P先生，把这张牌的花色告诉Q先生。这时，约翰教授问P先生和Q先生：你们能从已知的点数或花色中推知这张牌是什么牌吗？于是，S先生听到如下的对话：P先生：我不知道这张牌。Q先生：我知道你不知道这张牌。P先生：现在我知道这张牌了。Q先生：我也知道了。听罢以上的对话，S先生想了一想之后，就正确地推出这张牌是什么牌。请问：这张牌是什么牌？</p><blockquote><p>方块5<br>分析：从”Q先生：我知道你不知道这张牌。”这句话可以把黑桃以及草花排除，因为两种花色中有独有的点数，如果是这两种花色的话，Q先生不可能知道P先生不知道这张牌，然后”P先生：现在我知道这张牌了”这句话可以知道这点数在剩余的两种花色中是独有的从而排除掉红桃A 和方块A ，从”Q先生：我也知道了。”可以确定之前的排除之后这种花色中只剩下一种点数，进而推出方块5</p></blockquote><p>9、一个教授逻辑学的教授，有三个学生，而且三个学生均非常聪明！一天教授给他们出了一个题，教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个！（每个人可以看见另两个数，但看不见自己的）教授问第一个学生：你能猜出自己的数吗？回答：不能，问第二个，不能，第三个，不能，再问第一个，不能，第二个，不能，第三个：我猜出来了，是144！教授很满意的笑了。请问您能猜出另外两个人的数吗？</p><blockquote><p>经过第一轮，说明任何两个数都是不同的。第二轮，前两个人没有猜出，说明任何一个数都不是其它数的两倍。现在有了以下几个条件：1.每个数大于0；2.两两不等；3.任意一个数不是其他数的两倍。每个数字可能是另两个之和或之差，第三个人能猜出144，必然根据前面三个条件排除了其中的一种可能。假设：是两个数之差，即x－y＝144。这时1（x，y&gt;0）和2（x！＝y）都满足，所以要否定x＋y必然要使3不满足，即x＋y＝2y，解得x＝y，不成立（不然第一轮就可猜出），所以不是两数之差。因此是两数之和，即x＋y＝144。同理，这时1，2都满足，必然要使3不满足，即x－y＝2y，两方程联立，可得x＝108，y＝36。<br>这两轮猜的顺序其实分别为这样：第一轮（一号，二号），第二轮（三号，一号，二号）。这样分大家在每轮结束时获得的信息是相同的（即前面的三个条件）。<br>那么就假设我们是C，来看看C是怎么做出来的：C看到的是A的36和B的108，因为条件，两个数的和是第三个，那么自己要么是72要么是144（猜到这个是因为72的话，108就是36和72的和，144的话就是108和36的和。这样子这句话看不懂的举手）:<br>假设自己（C）是72的话，那么B在第二回合的时候就可以看出来，下面是如果C是72，B的思路：这种情况下，B看到的就是A的36和C的72，那么他就可以猜自己，是36或者是108（猜到这个是因为36的话，36加36等于72，108的话就是36和108的和）：<br>如果假设自己（B）头上是36，那么，C在第一回合的时候就可以看出来，下面是如果B是36，C的思路：这种情况下，C看到的就是A的36和B的36，那么他就可以猜自己，是72或者是0（这个不再解释了）：<br>如果假设自己（C）头上是0，那么，A在第一回合的时候就可以看出来，下面是如果C是0，A的思路：这种情况下，A看到的就是B的36和C的0，那么他就可以猜自己，是36或者是36（这个不再解释了），那他可以一口报出自己头上的36。（然后是逆推逆推逆推），现在A在第一回合没报出自己的36，C（在B的想象中）就可以知道自己头上不是0，如果其他和B的想法一样（指B头上是36），那么C在第一回合就可以报出自己的72。现在C在第一回合没报出自己的36，B（在C的想象中）就可以知道自己头上不是36，如果其他和C的想法一样（指C头上是72），那么B在第二回合就可以报出自己的108。现在B在第二回合没报出自己的108，C就可以知道自己头上不是72，那么C头上的唯一可能就是144了。</p></blockquote><p>10、某城市发生了一起汽车撞人逃跑事件，该城市只有两种颜色的车,蓝15%绿85%，事发时有一个人在现场看见了，他指证是蓝车，但是根据专家在现场分析,当时那种条件能看正确的可能性是80%那么,肇事的车是蓝车的概率到底是多少?</p><blockquote><p><code>15%*80%/(85％×20％＋15%*80%)</code></p></blockquote><p>11、有一人有240公斤水，他想运往干旱地区赚钱。他每次最多携带60公斤，并且每前进一公里须耗水1公斤（均匀耗水）。假设水的价格在出发地为0，以后，与运输路程成正比，（即在10公里处为10元/公斤，在20公里处为20元/公斤……），又假设他必须安全返回，请问，他最多可赚多少钱？</p><blockquote><p>f(x)=(60-2x)*x,当x=15时，有最大值450。<br>450×4，另外，需要证明的是，每次运60公斤水是最优的。</p></blockquote><p>12、现在共有100匹马跟100块石头，马分3种，大型马；中型马跟小型马。其中一匹大马一次可以驮3块石头，中型马可以驮2块，而小型马2头可以驮一块石头。问需要多少匹大马，中型马跟小型马？（问题的关键是刚好必须是用完100匹马）</p><blockquote><p>6种结果，分别设大型马为x匹，中型y匹，小型z匹，于是有：1.x+y+z=100; 2.3x+2y+z/2=100，可以得到5x+3y=100，知y必为5的倍数，且x&lt;20。</p></blockquote><p>13、1=5，2=15，3=215，4=2145那么5=?</p><blockquote><p>因为1=5，所以5=1．</p></blockquote><p>14、有2n个人排队进电影院，票价是50美分。在这2n个人当中，其中n个人只有50美分，另外n个人有1美元（纸票子）。愚蠢的电影院开始卖票时1分钱也没有。问：有多少种排队方法使得每当一个拥有1美元买票时，电影院都有50美分找钱  注：1美元=100美分拥有1美元的人，拥有的是纸币，没法破成2个50美分</p><blockquote><p>本题可用递归算法，但时间复杂度为2的n次方，也可以用动态规划法，时间复杂度为n的平方，实现起来相对要简单得多，但最方便的就是直接运用公式：排队的种数=(2n)!/[n!(n+1)!]。<br>如果不考虑电影院能否找钱，那么一共有(2n)!/[n!n!]种排队方法（即从2n个人中取出n个人的组合数），对于每一种排队方法，如果他会导致电影院无法找钱，则称为不合格的，这种的排队方法有(2n)!/[(n-1)!(n+1)!]（从2n个人中取出n-1个人的组合数）种，所以合格的排队种数就是(2n)!/[n!n!]- (2n)!/[(n-1)!(n+1)!] =(2n)!/[n!(n+1)!]。至于为什么不合格数是(2n)!/[(n-1)!(n+1)!]，说起来太复杂，这里就不讲了。</p></blockquote><p>15、一个人花8块钱买了一只鸡，9块钱卖掉了，然后他觉得不划算，花10块钱又买回来了，11块卖给另外一个人。问他赚了多少?</p><blockquote><p>2元</p></blockquote><p>16、有一种体育竞赛共含M个项目，有运动员A，B，C参加，在每一项目中，第一,第二,第三名分别的X，Y，Z分，其中X,Y,Z为正整数且X&gt;Y&gt;Z。最后A得22分，B与C均得9分，B在百米赛中取得第一。求M的值，并问在跳高中谁得第二名。</p><blockquote><p>因为ABC三人得分共40分,三名得分都为正整数且不等,所以前三名得分最少为6分,40=5<em>8=4</em>10=2<em>20=1</em>20,不难得出项目数只能是5.即M=5.<br>A得分为22分,共5项,所以每项第一名得分只能是5,故A应得4个一名一个二名.22=5*4+2,第二名得1分,又B百米得第一,所以A只能得这个第二.<br>B的5项共9分,其中百米第一5分,其它4项全是1分,9=5+1=1+1+1.即B除百米第一外全是第三,跳高第二必定是C所得.  </p></blockquote><p>17、前提：<br>1、 有五栋五种颜色的房子<br>2 、每一位房子的主人国籍都不同<br>3、 这五个人每人只喝一种饮料，只抽一种牌子的香烟，只养一种宠物<br>4 、没有人有相同的宠物，抽相同牌子的香烟，喝相同的饮料<br>提示：<br>１、英国人住在红房子里<br>２、瑞典人养了一条狗<br>３、丹麦人喝茶<br>４、绿房子在白房子左边<br>５、 绿房子主人喝咖啡<br>６、抽ＰＡＬＬ　ＭＡＬＬ烟的人养了一只鸟<br>７、黄房子主人抽ＤＵＮＨＩＬＬ烟<br>８、住在中间那间房子的人喝牛奶<br>９、挪威人住第一间房子<br>１０、抽混合烟的人住在养猫人的旁边<br>１１、养马人住在抽ＤＵＮＨＩＬＬ烟的人旁边<br>１２、抽ＢＬＵＥ　ＭＡＳＴＥＲ烟的人喝啤酒<br>１３、德国人抽ＰＲＩＮＣＥ烟<br>１４、挪威人住在蓝房子旁边<br>１５、抽混合烟的人的邻居喝矿泉水<br>问题是：谁养鱼？？？  </p><blockquote><p>第一间是黄房子，挪威人住，喝矿泉水，抽DUNHILL香烟，养猫；第二间是蓝房子，丹麦人住，喝茶，抽混合烟，养马；第三间是红房子，英国人住，喝牛奶，抽PALL MALL烟，养鸟；第四间是绿房子，德国人住，喝咖啡，抽PRINCE烟，养猫、马、鸟、狗以外的宠物；第五间是白房子，瑞典人住，喝啤酒，抽BLUE MASTER烟，养狗。</p></blockquote><p>18、5个人来自不同地方，住不同房子，养不同动物，吸不同牌子香烟，喝不同饮料，喜欢不同食物。根据以下线索确定谁是养猫的人。<br>1． 红房子在蓝房子的右边，白房子的左边（不一定紧邻）<br>2． 黄房子的主人来自香港，而且他的房子不在最左边。<br>3． 爱吃比萨的人住在爱喝矿泉水的人的隔壁。<br>4． 来自北京的人爱喝茅台，住在来自上海的人的隔壁。<br>5． 吸希尔顿香烟的人住在养马人的右边隔壁。<br>6． 爱喝啤酒的人也爱吃鸡。<br>7． 绿房子的人养狗。<br>8． 爱吃面条的人住在养蛇人的隔壁。<br>9． 来自天津的人的邻居（紧邻）一个爱吃牛肉，另一个来自成都。<br>10．养鱼的人住在最右边的房子里。<br>11．吸万宝路香烟的人住在吸希尔顿香烟的人和吸“555”香烟的人的中间（紧邻）<br>12．红房子的人爱喝茶。<br>13．爱喝葡萄酒的人住在爱吃豆腐的人的右边隔壁。<br>14．吸红塔山香烟的人既不住在吸健牌香烟的人的隔壁，也不与来自上海的人相邻。<br>15．来自上海的人住在左数第二间房子里。<br>16．爱喝矿泉水的人住在最中间的房子里。<br>17．爱吃面条的人也爱喝葡萄酒。<br>18．吸“555”香烟的人比吸希尔顿香烟的人住的靠右  </p><blockquote><p>第一间是兰房子，住北京人，养马，抽健牌香烟，喝茅台，吃豆腐；第二间是绿房子，住上海人，养狗，抽希尔顿，喝葡萄酒，吃面条第三间是黄房子，住香港人，养蛇，抽万宝路，喝矿泉水，吃牛肉第四间是红房子，住天津人，抽555，喝茶，吃比萨；第五间是白房子，住成都人，养鱼，抽红塔山，喝啤酒，吃鸡。</p></blockquote><p>19、斗地主附残局<br>地主手中牌2、K、Q、J、10、9、8、8、6、6、5、5、3、3、3、3、7、7、7、7<br>长工甲手中牌大王、小王、2、A、K、Q、J、10、Q、J、10、9、8、5、5、4、4<br>长工乙手中牌2、2、A、A、A、K、K、Q、J、10、9、9、8、6、6、4、4<br>三家都是明手，互知底牌。要求是：在三家都不打错牌的情况下，地主必须要么输要么赢。问：哪方会赢？  </p><blockquote><p>地主必输<br>1、地主最优势的就是先出对5，如果是其他方式出牌，很简单的必输。（自己研究）<br>2、地主出“对5”后，甲不要，乙必须出对K。地主不能要。（因为要了后，甲的牌比地主牌都大，一目了然地主会输）。那么乙接着出Q、J、10、9、8、顺子。地主必出K、Q、J、10、9，甲出A、K、Q、J、10，地主不能要（要了就输），甲继续出Q、J、10、9、8，地主还是不能要。此时看牌面：<br>3、地主：7777，3333，2,88,66，甲：大王，小王，2,  44，55，乙：AAA,9，22，66，44.甲走牌。<br>4、甲走2,，地主必炸，剩3333，2,88,66，甲乙都不要。那么此时地主怎么走也是输。<br>5、假如地主走2，甲用王吃掉，地主炸掉是输，不炸的话，甲拆开一对，走4，乙走9，乙赢。<br>假如地主打对6，甲不要，乙跟对2，地主不要（要了是输），乙接着走AAA带对4，就剩66,9，地主跟不跟都是输。 假如地主走单张，走一8，甲不要，乙跟9，地主跟2，甲王炸，地主输。<br>总之乙要先出对K，甲要牺牲自己，懂得拆对子，乙不能让地主出对6，那么地主必输。  </p></blockquote><p>20、一楼到十楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从一楼到十楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？  </p><blockquote><p>先拿下第一楼的钻石，然后在每一楼把手中的钻石与那一楼的钻石相比较，如果那一楼的钻石比手中的钻石大的话那就把手中的钻石换成那一层的钻石。</p></blockquote><p>21、U2合唱团在17分钟 内得赶到演唱会场，途中必需跨过一座桥，四个人从桥的同一端出发，你得帮助他们到达另一端，天色很暗，而他们只有一只手电筒。一次同时最多可以有两人一起 过桥，而过桥的时候必须持有手电筒，所以就得有人把手电筒带来带去，来回桥两端。手电筒是不能用丢的方式来传递的。四个人的步行速度各不同，若两人同行则 以较慢者的速度为准。Bono需花1分钟过桥，Edge需花2分钟过桥，Adam需花5分钟过桥，Larry需花10分钟过桥。他们要如何在17分钟内过 桥呢？</p><blockquote><p>2＋1先过 2<br>然后1回来送手电筒 1<br>5＋10再过 10<br>2回来送手电筒 2<br>2＋1过去 2<br>总共2＋1＋10＋2＋2＝17分钟  </p></blockquote><p>22、一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样）</p><blockquote><p>1/3<br>样本空间为（男男）（女女）（男女）（女男）<br>A＝（已知其中一个是女孩）＝）（女女）（男女）（女男）<br>B＝（另一个也是女孩）＝（女女）<br>于是P（B／A）＝P（AB）／P（A）＝（1／4）／（3／4）＝1／3  </p></blockquote><p>23、为什么下水道的盖子是圆的？</p><blockquote><p>不论什么角度，井盖都不会掉下去  </p></blockquote><p>24、有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</p><blockquote><p>140-&gt;70＋70 70-&gt;35＋35<br>35＋70＝105<br>105-&gt;50＋7 ＋ 55＋2<br>55＋35＝90  </p></blockquote><p>25、芯片测试：有2k块芯片，已知好芯片比坏芯片多．请设计算法从其中找出一片 好芯片，说明你所用的比较次数上限． 其中：好芯片和其它芯片比较时，能正确给出另一块芯片是好还是坏． 坏芯片和其它芯片比较时，会随机的给出好或是坏。</p><blockquote><p>把第一块芯片与其它逐一对比，看看其它芯片对第一块芯片给出的是好是坏，如果给出是好的过半，那么说明这是好芯片，完毕。如果给出的是坏的过半，说明第一块芯片是坏的，那么就要在那些在给出第一块芯片是坏的芯片中，重复上述步骤，直到找到好的芯片为止。</p></blockquote><p>26、12个球一个天平，现知道只有一个和其它的重量不同，问怎样称才能用三次就找到那个球。13个呢？（注意此题并未说明那个球的重量是轻是重）</p><blockquote><p>12个时可以找出那个是重还是轻，13个时只能找出是哪个球，轻重不知。<br>　　把球编为①②③④⑤⑥⑦⑧⑨⑩⑾⑿。（13个时编号为⒀）<br>　　第一次称：先把①②③④与⑤⑥⑦⑧放天平两边，<br>　　　　㈠如相等，说明特别球在剩下4个球中。<br>　　　　　　把①⑨与⑩⑾作第二次称量，<br>　　　　　　⒈如相等，说明⑿特别，把①与⑿作第三次称量即可判断是⑿是重还是轻<br>　　　　　　⒉如①⑨＜⑩⑾说明要么是⑩⑾中有一个重的，要么⑨是轻的。<br>　　　　　　　　把⑩与⑾作第三次称量，如相等说明⑨轻，不等可找出谁是重球。<br>　　　　　　⒊如①⑨＞⑩⑾说明要么是⑩⑾中有一个轻的，要么⑨是重的。<br>　　　　　　　　把⑩与⑾作第三次称量，如相等说明⑨重，不等可找出谁是轻球。<br>　　　　㈡如左边＜右边，说明左边有轻的或右边有重的<br>　　　　　　把①②⑤与③④⑥做第二次称量<br>　　　　　　⒈如相等，说明⑦⑧中有一个重，把①与⑦作第三次称量即可判断是⑦与⑧中谁是重球<br>　　　　　　⒉如①②⑤＜③④⑥说明要么是①②中有一个轻的，要么⑥是重的。<br>　　　　　　　　把①与②作第三次称量，如相等说明⑥重，不等可找出谁是轻球。<br>　　　　　　⒊如①②⑤＞③④⑥说明要么是⑤是重的，要么③④中有一个是轻的。<br>　　　　　　　　把③与④作第三次称量，如相等说明⑤重，不等可找出谁是轻球。<br>　　　　㈢如左边＞右边，参照㈡相反进行。<br>　　当13个球时，第㈠步以后如下进行。<br>　　　　把①⑨与⑩⑾作第二次称量，<br>　　　　⒈如相等，说明⑿⒀特别，把①与⑿作第三次称量即可判断是⑿还是⒀特别，但判断不了轻重了。<br>　　　　⒉不等的情况参见第㈠步的⒉⒊  </p></blockquote><p>27、100个人回答五道试题，有81人答对第一题，91人答对第二题，85人答对第三题，79人答对第四题，74人答对第五题，答对三道题或三道题以上的人算及格， 那么，在这100人中，至少有（ ）人及格。 </p><blockquote><p>首先求解原题。每道题的答错人数为（次序不重要）：26，21，19，15，9<br>第3分布层：答错3道题的最多人数为：（26+21+19+15+9）/3=30<br>第2分布层：答错2道题的最多人数为：（21+19+15+9）/2=32<br>第1分布层：答错1道题的最多人数为：（19+15+9）/1=43<br>Max_3=Min(30, 32, 43)=30。因此答案为：100-30=70。<br>其实，因为26小于30，所以在求出第一分布层后，就可以判断答案为70了。<br>要让及格的人数最少，就要做到两点：  </p><ol><li>不及格的人答对的题目尽量多，这样就减少了及格的人需要答对的题目的数量，也就只需要更少的及格的人  </li><li>每个及格的人答对的题目数尽量多，这样也能减少及格的人数<br>由1得每个人都至少做对两道题目<br>由2得要把剩余的210道题目分给其中的70人： 210/3 = 70，让这70人全部题目都做对，而其它30人只做对了两道题<br>也很容易给出一个具体的实现方案：<br>让70人答对全部五道题，11人仅答对第一、二道题，10人仅答对第二、三道题，5人答对第三、四道题，4人仅答对第四、五道题<br>显然稍有变动都会使及格的人数上升。所以最少及格人数就是70人！  </li></ol></blockquote><p>28、陈奕迅有首歌叫十年吕珊有首歌叫3650夜那现在问,十年可能有多少天?</p><blockquote><p>闰年的确定：如果年份末两位不是全0，比如1990，就是除以4，能除尽的是闰年。<br>如果末两位全是0，则要除以400，比如2000年，就是除400。所以2100年就不是闰年了，<br>这样十年可能包含1，2个闰年，3651或3652天。</p></blockquote><p>29、1，11，21，1211，111221，下一个数是什么？</p><blockquote><p>下行是对上一行的解释所以新的应该是3个1 2个2 1个1 ：312211</p></blockquote><p>30、烧一根不均匀的绳要用一个小时，如何用它来判断半个小时？烧一根不均匀的绳,从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢? （微软的笔试题） </p><blockquote><p>一、一根绳子从两头烧，烧完就是半个小时。<br>二、一根要一头烧，一根从两头烧，两头烧完的时候（30分），将剩下的一根另一端点着，烧尽就是45分钟。再从两头点燃第三根，烧尽就是1时15分。  </p></blockquote><p>31、共有三类药,分别重1g,2g,3g,放到若干个瓶子中,现在能确定每个瓶子中只有其<br>中一种药,且每瓶中的药片足够多,能只称一次就知道各个瓶子中都是盛的哪类药吗？<br>如果有4类药呢？5类呢？N类呢(N可数)？ </p><blockquote><p>如果是共有m个瓶子盛着n类药呢(m,n为正整数,药的质量各不相同但各种药的质量已知)<br>？你能只称一次就知道每瓶的药是什么吗？<br>注：当然是有代价的,称过的药我们就不用了<br>取1号瓶子1颗,2号瓶子5颗,3号瓶子10颗。一起称量重量。<br>1,2,3      总重量为 41<br>1,3,2      总重量为 36<br>2,1,3      总重量为 37<br>2,3,1      总重量为 27<br>3,2,1      总重量为 23<br>3,1,2      总重量为28<br>M类药同样处理,答题完毕。  </p></blockquote><p>32、假设在桌上有三个密封 的盒,一个盒中有2枚银币(1银币=10便士),一个盒中有2枚<br>镍币(1镍币=5便士),还有一个盒中有1枚银币和1枚镍币。这些盒子被标上10便士、 15便<br>士和20便士,但每个标签都是错误的。允许你从一个盒中拿出1枚硬币放在盒前,看到这枚<br>硬币,你能否说出每个盒内装的东西呢？  </p><blockquote><p>银币 20分,镍币10分, 混合币 15分。将三个盒子分别编号为1,2,3。<br>每个标签都错误的方法只有两个,2,3,1 或 3,1,2。<br>在标签为15分的盒子里面, 取出一个硬币。<br>如果是银币,则,15分的为银币盒子, 10分的为混合币盒子,15分为镍币。<br>如果是镍币,则,15分的为镍币盒子, 10分的为银币盒子, 10分的为银币。<br>答题完毕。  </p></blockquote><p>33、有一个大西瓜,用水果刀平整地切,总共切9刀,最多能切成多少份,最少能切成多少份 ? </p><blockquote><p>主要是过程,结果并不是最重要的<br>最少10块。<br>最多 2^9块,即512块。<br>答题完毕.  </p></blockquote><p>34、一个巨大的圆形水池,周围布满了老鼠洞。猫追老鼠到水池边,老鼠未来得及进洞就掉入水池里。猫继续沿水池边缘企图捉住老鼠(猫不入水)。已知V猫=4V鼠。问老鼠是<br>否有办法摆脱猫的追逐？  </p><blockquote><p>当老鼠在中心时候, 用时间 R/ T, 猫用 πR/ 4T.老鼠不能跑掉.<br>当老鼠不经过圆心时候, 假设圆心角为ɑ.<br>用时间<code>1/2(R*Rsinɑ)/ V</code>. 猫用时间 <code>(ɑ/ 360)*2πR/ 4V</code>. 因为ɑ小于180, 所以不能跑掉.<br>答题完毕.</p></blockquote><p>35、有三个桶,两个大的可装8斤的水,一个小的可装3斤的水,现在有16斤水装满了两 大桶就是8斤的桶,小桶空着,如何把这16斤水分给4个人,每人4斤。没有其他任何工具,4人自备容器,分出去的水不可再要回来。  </p><blockquote><p>假设两个8斤的大桶分别为A1、A2；3斤的小桶为B.4个人分别为C1、C2、C3、C4.一、用A2中的水把B倒满,将B中的水分给C1；再用A2中的水把B倒满,将A2中剩下的水分给C2.（即：A1：8斤、A2：0斤、B：3斤、C1：3斤、C2：2斤、C3：0斤、C4：0斤）二、把B中的水全部倒入A2中,用A1中的水把B倒满,然后把B中的水全部倒入A2中,再用A1中的水把B倒满,用B中的水把A2填满,将B中剩余的水分给C3.（即：A1：2斤、A2：8斤、B：0斤、C1：3斤、C2：2斤、C3：1斤、C4：0斤）三、把A1中的水全部倒入B中,用A2中的水把B填满,把B中的水全部倒入A1中,用A2中剩余的水把B填满,把B中的水再次全部倒入A1中,用A2中剩余的水把B填满,将A2剩余的水分给C4.（即：A1：6斤、A2：0斤、B：3斤、C1：3斤、C2：2斤、C3：1斤、C4：1斤）四、用B中的水把A1填满,将B剩余的水分给C1.（即：A1：8斤、A2：0斤、B：0斤、C1：4斤、C2：2斤、C3：1斤、C4：1斤）五、用A1中的水把B倒满,将B中的水分给C3,用A1中剩余的水把B填满,将B中的水分给C4,将A1中剩余的水分给C2.（即：A1：0斤、A2：0斤、B：0斤、C1：4斤、C2：4斤、C3：4斤、C4：4斤）</p></blockquote><p>36、从前有一位老钟表匠, 为一个教堂装一只大钟。他年老眼花,把长短针装配错了, 短针走的速度反而是长针的12倍。装配的时候是上午6点,他把短针指在“6 ”上,长针指<br>在“12”上。老钟表匠装好就回家去了。人们看这钟一会儿7点,过了不一会儿就8点了, 都很奇怪,立刻去找老钟表匠。等老钟表匠赶到,已经是 下午7点多钟。他掏出怀表来一<br>对,钟准确无误,疑心人们有意捉弄他,一生气就回去了。这钟还是8点、9点地跑,人们 再去找钟表匠。老钟表匠第二天早晨8点 多赶来用表一对,仍旧准确无误。 请你想一想,<br>老钟表匠第一次对表的时候是7点几分？第二次对表又是8点几分？  </p><blockquote><p>在6点,两针成为一直线,这是老钟表匠装配的时间。从六点开始,每增加1 小时5+5/11分<br>,两针再成为一直线。7点之后,两针成为一直线的时间是7点5+5/11分；8点以后,两针成<br>为一直线的时间是8点10+10/11分。<br>答题完毕.</p></blockquote><p>37、今有2匹马、3头牛和4只羊,它们各自的总价都不满10000文钱(古时的货币单位)<br>。如果2匹马加上1头牛,或者3 头牛加上1只羊,或者4只羊加上1匹马,那么它们各自的总<br>价都正好是10000文钱了。问：马、牛、羊的单价各是多少文钱？  </p><blockquote><p>设马的单价是x,牛的单价是y,羊的单价是z<br>2x+y=10000……(1)<br>3y+z=10000……(2)<br>4z+x=10000……(3)<br>(1)<em> 4+(2)</em> 2+(3)* 2=&gt;<br>10(x+y+z)=80000<br>x+y+z=8000<br>或解出<br>x=3600<br>y=2800<br>z=1600<br>答题完毕.  </p></blockquote><p>38、一天,harlan的 店里来了一位顾客,挑了25元的货,顾客拿出100元,harlan没零<br>钱找不开,就到隔壁飞白的店里把这100元换成零钱,回来给顾客找了75元零钱。 过一会<br>,飞白来找harlan,说刚才的是假钱,harlan马上给飞白换了张真钱,问harlan赔了多少<br>钱？  </p><blockquote><p>100元.<br>答题完毕.</p></blockquote><p>39、猴子爬绳：一根无质量绳子穿过天花板上一个无摩擦力的定滑轮，在其一端悬挂着一只10磅重的砝码，绳子的另一端有只猴子，同砝码正好取得平衡。当猴子开始向上爬时，砝码将如何动作呢?</p><blockquote><p>砝码向下降.<br>无外力作用, 联合体重心不变.   </p><p>分析：是不是可以化简，把事情看成是一个上移的砝码和一个静止的砝码关系？<br>如果上移意味着轻质化，失重化，那么，这等同于把秤砣往里拨动。因此秤盘那一边的东西就会下沉。因而猴子向上的速度会大于它自己实际的速度。甚至在某一个平衡破裂点上，猴子不需要往上爬就会自然上升。<br>想一想翘翘板，两个孩子的一个，如果一个往中心移动（失重化）那么结果是一直在上面了。不可能再发生平衡过程了。<br>如果我们把上移看作是一种轻化过程。那么我们可以把两个平衡的称物中的一个，等价地看作其中一个是有孔的沙袋。它不断地漏出沙子来。那么结果就是有洞的那个变得越来越轻。因此天平会向着不动的那个方向倾斜。<br>绳子所面对的两个同重量的物体的相对关系就是这样。<br>反过来，如果上移不等于轻质化，失重化，那么上移和下移都不会引起另一端的砝码的任何变化。<br>因为它们的相对关系和以前一样。<br>如果上移意味着轻质化，失重化，那么猴子往下移的时候，等于把秤砣往外移动，结果是另外一边的东西上升。<br>因此，我认为，（在这些牛津大学的数学家们的思考面前，）<br>在平衡两点中，只要有一个点发生对平衡条件的变化，就会引起失衡。<br>无论是在软绳中，还是在刚体杠杆行为中。<br>不由得感觉，这不是数学趣题，应该是物理趣题。  </p></blockquote><p>40、两个空心球,大小及重量相同,但材料不同。一个是金,一个是铅。空心球表面图 有相同颜色的油漆。现在要求在不破坏表面油漆的条件下用简易方法指出哪个是金的,哪<br>个是铅的。  </p><blockquote><p>相同得力原地旋转两个球, 两球重心到内壁中心距离不同, 线速度不同.转得快得是金球.<br>答题完毕.</p></blockquote><p>41、有23枚硬币在桌上,10枚正面朝上。假设别人蒙住你的眼睛,而你的手又摸不出硬<br>币的 反正面。让你用最好的方法把这些硬币分成两堆,每堆正面朝上的硬币个数相同。  </p><blockquote><p>选13个为一堆, 选10个为一堆.然后将10个硬币全部翻面.<br>答题完毕.</p></blockquote><p>42、三个村庄A、B、C和三个城镇A、B、C坐落在如图所示的环形山内。<br>由于历史原因,只有同名的村与镇之间才有来往。为方便交通,他们<br>准备修铁路。问题是：如何在这个环形山内修三条铁路连通A村与A镇,<br>B村与B镇,C村与C镇。而这些铁路相互不能相交。(挖山洞、修立交<br>桥都不算,绝对是平面问题)。想出答案再想想这个题说明什么问题。  </p><blockquote><p>如下图:<br><img src="http://oui2ar2u7.bkt.clouddn.com/201710202244.png" alt=""><br>答题完毕. </p></blockquote><p>44、屋里三盏灯,屋外三个开关,一个开关仅控制一盏灯,屋外看不到屋里<br>怎样只进屋一次,就知道哪个开关控制哪盏灯? 四盏呢~  </p><blockquote><p>三个灯: 打开两个灯, 过一会关闭一个. 进去看亮着的, 不亮但是发热的,不亮也不发热的<br>.区别出来.<br>四个灯: 打开两个灯, 过一会关闭一个, 然后打开一个新的灯, 不亮但是发热的, 亮但是<br>不发热的, 亮而且发热的, 不亮也不发热的. 区别出来.<br>答题完毕. </p></blockquote><p>44、2+7-2+7全部有火柴根组成,移动其中任何一根,答案要求为30 </p><blockquote><p>说明：因为书写问题作如下解释,2是由横折横三根组成,7是由横折两根组成<br>将最后一个加号变成, 217, 将第一个加号变成247.<br>答题完毕.  </p></blockquote><p>45、5名海盗抢得了窖藏的100块金子,并打算瓜分这些战利品。这是一些讲民主的海盗 (当然是他们自己特有的民主),他们的习惯  是按下面的方式进行分配：最厉害的一名海盗提出分配方案,然后所有的海盗(包  括提出方案者本人)就此方案进行表决。如果50%或更多的海盗赞同此方案,此方  案就获得通过并据此分配战利品。否则提出方案的海盗将被扔到海里,然后下一名<br>最厉害的海盗又重复上述过程。<br>所有的海盗都乐于看到他们的一位同伙被扔进海里,不过,如果让他们选择的话,他们还是宁可得一笔现金。他们当然也不愿意自己被扔到海里。所有的海盗都是有理性的,而且知道其他的海盗也是有理性的。此外,没有两名海盗是同等厉害的——这些海盗按照完全由上到下的等级排好了座次,并且每个人都清楚自己和其他所有人的等级。这些金块不能再分,也不允许几名海盗共有金块,因为任何海盗都不相信他的同伙会遵守关于共享金块的安排。这是一伙每人都只为自己打算的海盗。<br>最凶的一名海盗应当提出什么样的分配方案才能使他获得最多的金子呢？    </p><blockquote><p>首先从5号海盗开始,因为他是最安全的,没有被扔下大海的风险,因此他的策略也最为简<br>单,即最好前面的人全都死光光,那么他就可以独得这100枚金币了。接下来看4号,他的<br>生存机会完全取决于前面还有人存活着,因为如果1号到3号的海盗全都喂了鲨鱼,那么在<br>只剩4号与5号的情况下,不管4号提出怎样的分配方案,5号一定都会投反对票来让4号去喂<br>鲨鱼,以独吞全部的金币。哪怕4号为了保命而讨好5号,提出(0,100)这样的方案让5号<br>独占金币,但是5号还有可能觉得留着4号有危险,而投票反对以让其喂鲨鱼。因此理性的<br>4号是不应该冒这样的风险,把存活的希望寄托在5号的随机选择上的,他惟有支持3号才能<br>绝对保证自身的性命。 再来看3号,他经过上述的逻辑推理之后,就会提出(100,0,0)<br>这样的分配方案,因为他知道4号哪怕一无所获,也还是会无条件的支持他而投赞成票的,<br>那么再加上自己的1票就可以使他稳获这100金币了。 但是,2号也经过推理得知了3号的分<br>配方案,那么他就会提出(98,0,1,1)的方案。因为这个方案相对于3号的分配方案,<br>4号和5号至少可以获得1枚金币,理性的4号和5号自然会觉得此方案对他们来说更有利而支<br>持2号,不希望2号出局而由3号来进行分配。这样,2号就可以屁颠屁颠的拿走98枚金币了<br>。 不幸的是,1号海盗更不是省油的灯,经过一番推理之后也洞悉了2号的分配方案。他将<br>采取的策略是放弃2号,而给3号1枚金币,同时给4号或5号2枚金币,即提出(97,0,1,<br>2,0)或(97,0,1,0,2)的分配方案。由于1号的分配方案对于3号与4号或5号来说,<br>相比2号的方案可以获得更多的利益,那么他们将会投票支持1号,再加上1号自身的1票,<br>97枚金币就可轻松落入1号的腰包了<br>答题完毕. </p></blockquote><p>46、他们中谁的存活机率最大？<br>5个囚犯,分别按1-5号在装有100颗绿豆的麻袋抓绿豆,规定每人至少抓一颗,而抓得最多<br>和最少的人将被处死,而且,他们之间不能交流,但在抓的时候,可以摸出剩下的豆子数。问他们中谁的存活几率最大？提示：  　　　　　　<br>1,他们都是很聪明的人　  　　　　　<br>2,他们的原则是先求保命,再去多杀人　  　　　　　<br>3,100颗不必都分完　  　　　　　<br>4,若有重复的情况,则也算最大或最小,一并处死    </p><blockquote><p>每个人拿的个数必须大于等于2,否则就是死<br>所以,1号最多敢拿50-2*4=42颗,但这也是死,因为2号就拿41颗,剩下17颗,1号也是死。<br>所以1号必须让拿了N颗后,再让2号拿后,还剩很多。那么我们把100颗分为5份。<br>如果1号拿21颗,2号就拿20颗,剩下59颗,肯定有一个人拿的少于20颗,所以1号拿21颗死<br>定。<br>再看1号拿20颗,2号拿21颗的话,剩下也是59颗,可以是20+20+19,2号死定。<br>那么,看2号拿20颗,剩下60颗,3号如果拿21颗,剩下39颗,可以是20+19,3号死定。<br>所以,接着看3号拿20颗,剩下40颗,那么,4号怎么拿也是死！而且和5号一起死！要不就<br>全部一起死(都拿20颗)<br>3号当然怕同归于尽啊,因为4号5号心想怎么也是个死,不如弄死全部。<br>所以看3号拿19颗,剩下41颗,可以是20+20,20+19。20+21,不管怎么,3号都死定了。<br>所以,3号只敢拿20颗。因为可以活不成也弄个全体一起死.<br>那么,4号也同样怕全部20颗的情况,所以,而21颗不能拿,所以,他拿19颗。<br>剩下61颗,可以是20+20+19,20+20+20,20+20+21,他怎么也是个死！<br>所以,4号没得选择,只能拿20颗。至少可以弄得个全部拿20颗一起同归于尽.<br>同理！5号也只能拿20颗！<br>这样下去,1-5号都拿20颗,同归于尽！<br>因为:任何一个人,拿21个以上或者19个以下(包括)就是单独死或者只死几个.<br>答题完毕. </p></blockquote><p>47、有5只猴子在海边发现 一堆桃子,决定第二天来平分.第二天清晨,第一只猴子最早来<br>到,它左分右分分不开,就朝海里扔了一只,恰好可以分成5份,它拿上自己的一份走了.第 2<br>,3,4,5只猴子也遇到同样的问题,采用了同样的方法,都是扔掉一只后,恰好可以分成5份.问<br>这堆桃子至少有多少只？  </p><blockquote><p>5 <em> 5 </em> 5 <em> 5 </em> 5 + 1= 726<br>答题完毕. </p></blockquote><p>48、话说某天一艘海盗船被天下砸下来的一头牛给击中了,5个倒霉的家伙只好逃难到一<br>个孤岛,发现岛上孤零零的,幸好有有棵椰子树,还有一只猴子!<br>大家把椰子全部采摘下来放在一起,但是天已经很晚了,所以就睡觉先.<br>晚上某个家伙悄悄的起床,悄悄的将椰子分成5份,结果发现多一个椰子,顺手就给了幸运的<br>猴子,然后又悄悄的藏了一份,然后把剩下的椰子混在一起放回原处,最后还是悄悄滴回去睡<br>觉了.<br>过了会儿,另一个家伙也悄悄的起床,悄悄的将剩下的椰子分成5份,结果发现多一个椰子,顺<br>手就又给了幸运的猴子,然后又悄悄滴藏了一份,把剩下的椰子混在一起放回原处,最后还是<br>悄悄滴回去睡觉了.<br>又过了一会 …<br>…<br>又过了一会 …<br>总之5个家伙都起床过,都做了一样的事情<br>早上大家都起床,各自心怀鬼胎的分椰子了,这个猴子还真不是一般的幸运,因为这次把椰子<br>分成5分后居然还是多一个椰子,只好又给它了.<br>问题来了,这堆椰子最少有多少个?    </p><blockquote><p>5 <em> 5 </em> 5 <em> 5 </em> 5 + 1= 726<br>答题完毕. </p></blockquote><p>49、小明和小强都是张老师的学生,张老师的生日是M月N日,<br>2人都知道张老师的生日是下列10组中的一天,<br>张老师把M值告诉了小明,把N值告诉了小强,<br>张老师问他们知道他的生日是那一天吗？<br>3月4日 3月5日 3月8日<br>6月4日 6月7日<br>9月1日 9月5日<br>12月1日 12月2日 12月8日<br>小明说：如果我不知道的话,小强肯定也不知道<br>小强说：本来我也不知道,但是现在我知道了<br>小明说：哦,那我也知道了<br>请根据以上对话推断出张老师的生日是哪一天    </p><blockquote><p>答案应该是9月1日。<br>1)首先分析这10组日期,经观察不难发现,只有6月7日和12月2日这两组日期的<br>日数是唯一的。由此可知,如果小强得知的N是7或者2,那么他必定知道了老师的<br>生日。<br>2)再分析“小明说：如果我不知道的话,小强肯定也不知道”,而该10组日期的<br>月数分别为3,6,9,12,而且都相应月的日期都有两组以上,所以小明得知M后<br>是不可能知道老师生日的。<br>3)进一步分析“小明说：如果我不知道的话,小强肯定也不知道”,结合第2步<br>结论,可知小强得知N后也绝不可能知道。<br>4)结合第3和第1步,可以推断：所有6月和12月的日期都不是老师的生日,因为<br>如果小明得知的M是6,而若小强的N==7,则小强就知道了老师的生日。(由第<br>1步已经推出),同理,如果小明的M==12,若小强的N==2,则小强同样可以知道老师的生<br>日。即：M不等于6和9。现在只剩下“3月4日 3月5日 3月8日 9月1日<br>9月5日”五组日期。而小强知道了,所以N不等于5(有3月5日和9月5日),此时,<br>小强的N∈(1,4,8)注：此时N虽然有三种可能,但对于小强只要知道其中的<br>一种,就得出结论。所以有“小强说：本来我也不知道,但是现在我知道了”,<br>对于我们则还需要继续推理<br>至此,剩下的可能是“3月4日 3月8日 9月1日”<br>5)分析“小明说：哦,那我也知道了”,说明M==9,N==1,(N==5已经被排除,3月份的<br>有两组)<br>答题完毕. </p></blockquote><p>50、一逻辑学家误入某部 落,被囚于牢狱,酋长欲意放行,他对逻辑学家说：“今有两<br>门,一为自由,一为死亡,你可任意开启一门。现从两个战士中选择一人负责解答你所提<br>的任何一个问 题(Y/N),其中一个天性诚实,一人说谎成性,今后生死任你选择。”逻<br>辑学家沉思片刻,即向一战士发问,然后开门从容离去。逻辑学家应如何发问？  </p><blockquote><p>你来自哪个门? 然后向所指向得门走.<br>答题完毕. </p></blockquote><p>51、说从前啊,有一个富 人,他有30个孩子,其中15个是已故的前妻所生,其余15个是继室<br>所生,这后一个妇人很想让她自己所生的最年长的儿子继承财产,于是,有一天,他就向他 说<br>:”亲爱的丈夫啊,你就要老了,我们应该定下来谁将是你的继承人,让我们把我们的30个孩子<br>排成一个圆圈,从他们中的一个数起,每逢到10就让那个孩子 站出去,直到最后剩下哪个孩<br>子,哪个孩子就继承你的财产吧!”富人一想,我靠,这个题意相当有内涵了,不错,仿佛很公平<br>,就这么办吧~不过,当剔选过程不 断进行下去的时候,这个富人傻眼了,他发现前14个被剔<br>除的孩子都是前妻生的,而且下一个要被剔除的还是前妻生的,富人马上大手一挥,停,现在<br>从这个孩子 倒回去数, 继室,就是这个歹毒的后妈一想,倒数就倒数,我15个儿子还斗不过<br>你一个啊~她立即同意了富人的动议,你猜,到底谁做了继承人呢~  </p><blockquote><p>10+11+12+13+14+15+16+17+18+19+20+21+22+23= 198<br>198/ 30= 6余18.<br>小孩子站在18号位置即可.<br>答题完毕. </p></blockquote><p>52、“有一牧场,已知养牛27头,6天把草吃尽；养牛23头,9天把草吃尽。如果养牛21<br>头,那么几天能把牧场上的草吃尽呢？并且牧场上的草是不断生长的。”</p><blockquote><p>把一头牛一天所吃的牧草看作1,那么就有：<br>(1)27头牛6天所吃的牧草为：27×6＝162<br>(这162包括牧场原有的草和6天新长的草。)<br>(2)23头牛9天所吃的牧草为：23×9＝207<br>(这207包括牧场原有的草和9天新长的草。)<br>(3)1天新长的草为：(207－162)÷(9－6)＝15<br>(4)牧场上原有的草为：27×6－15×6＝72<br>(5)每天新长的草足够15头牛吃,21头牛减去15头,剩下6头吃原牧场的草：<br>72÷(21－15)＝72÷6＝12(天)<br>答题完毕. </p></blockquote><p>53、一个商人骑一头驴要穿越1000公里长的沙漠,去卖3000根胡萝卜。已知驴一次性可驮<br>1000根胡萝卜,但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？  </p><blockquote><p>假设出沙漠时有1000根萝卜,那么在出沙漠之前一定不只1000根,那么至少要驮两次才会<br>出沙漠,那样从出发地到沙漠边缘都会有往返的里程,那所走的路程将大于3000公里,故<br>最后能卖出萝卜的数量一定是小于1000根的。<br>那么在走到某一个位置的时候萝卜的总数会恰好是1000根。<br>因为驴每次最多驮1000,那么为了最大的利用驴,第一次卸下的地点应该是使萝卜的数量<br>为2000的地点。<br>因为一开始有3000萝卜,驴必须要驮三次,设驴走X公里第一次卸下萝卜<br>则：5X=1000(吃萝卜的数量,也等于所行走的公里数)<br>X=200,也就是说第一次只走200公里<br>验算：驴驮1000根走200公里时剩800根,卸下600根,返回出发地<br>前两次就囤积了1200根,第三次不用返回则剩800根,则总共是2000根萝卜了。<br>第二次驴只需要驮两次,设驴走Y公里第二次卸下萝卜<br>则：3Y=1000, Y=333.3<br>验算：驴驮1000根走333.3公里时剩667根,卸下334根,返回第一次卸萝卜地点<br>第二次在途中会吃掉334根萝卜,到第二次卸萝卜地点是加上卸下的334根,刚好是1000根<br>。<br>而此时总共走了：200+333.3=533.3公里,而剩下的466.7公里只需要吃466根萝卜<br>所以可以卖萝卜的数量就是1000-466=534.<br>答题完毕.</p></blockquote><p>54、10箱黄金,每箱100块,每块一两，有贪官,把某一箱的每块都磨去一钱，请称一次找到不足量的那个箱子。</p><blockquote><p>编号为1到10箱, 每箱取跟编号相同数目的黄金, 称量. 少多少钱,就是多少编号的箱子不足.<br>答题完毕.</p></blockquote><p>55、你让工人为你工作7天,给工人的回报是一根金条。金条平分成相连的7段,你必<br>须 在每天结束时都付费,如果只许你两次把金条弄断,你如何给你的工人付费？    </p><blockquote><p>分为, 1,2,4 三段.<br>第一天, 1个环给工人<br>第二天, 2个环给工人, 拿回一个环<br>第三天, 1个环给工人<br>第四天, 4个环给工人, 拿回1个环,2个环<br>第五天, 一个环给工人<br>第六天, 2个环给工人,拿回1个环<br>第七天, 1个环给工人.<br>答题完毕. </p></blockquote><p>56、有十瓶药,每瓶里都装有100片药(仿佛现在装一百片的少了,都是十片二十片的,<br>不管,咱们就这么来了),其中有八瓶里的药每片重10克,另有两瓶里的药每片重9克。用<br>一个蛮精确的小秤,只称一次,如何找出份量较轻的那两个药瓶？  </p><blockquote><p>编号1至10, 1号取10片, 2号取20片,以此类推.<br>称量所有取出药片, 缺少多少, 就是哪两个瓶子分量较轻.<br>答题完毕. </p></blockquote><p>57、一个经理有三个女儿, 三个女儿的年龄加起来等于13,三个女儿的年龄乘起来等于<br>经理自己的年龄,有一个下属已知道经理的年龄,但仍不能确定经理三个女儿的年龄,这<br>时经理说只有 一个女儿的头发是黑的,然后这个下属就知道了经理三个女儿的年龄。请问<br>三个女儿的年龄分别是多少？为什么？  </p><blockquote><p>显然3个女儿的年龄都不为0,要不爸爸就为0岁了,因此女儿的年龄都大于等于1岁。这样<br>可以得下面的情况：1 <em> 1 </em> 11=11,1 <em> 2 ** 10=20,1 </em> 3 <em> 9=27,1 </em> 4 <em> 8=32,1 </em> 5 <em> 7=35,{1 </em> 6 <em> 6=36},{2 </em> 2 <em> 9=36},2 </em> 3 <em> 8=48,2 </em> 4 <em> 7=56,2 </em> 5 <em> 6=60,3 </em> 3 <em> 7=63,3 </em> 4 <em> 6=72,3 </em> 5 <em> 5=75,4 </em> 4 <em> 5=80因为下属已知道经理的年龄,但仍不能确定经理三个女儿的年龄,说明经理是36岁<br>(因为{1 </em> 6 <em> 6=36},{2 </em> 2 * 9=36}),所以3个女儿的年龄只有2种情况,经理又说只有一个女儿的头发是黑的,说明只有一个女儿是比较大的,其他的都比较小,头发还没有长成黑 色的,所以3个女儿的年龄分别为2,2,9！<br>答题完毕.</p></blockquote><p>58、有三个人去住旅馆,住 三间房,每一间房10元,于是他们一共付给老板30,第二<br>天,老板觉得三间房只需要25元就够了于是叫小弟退回5元给三位客人,谁知小弟贪心,只<br>退 回每人1元,自己偷偷拿了2元,这样一来便等于那三位客人每人各花了九元,于是三个人<br>一共花了27,再加上小弟独吞了不2元,总共是29。可是当初他们三个人一共付出30元那<br>么还有$1呢？  </p><blockquote><p>小弟独吞的3元已经计量在28元成本中.退回钱数为3*9=27.<br>1= 28-27.<br>答题完毕.</p></blockquote><p>59、有两位盲人,他们都各自买了两对黑袜和两对白袜,八对袜了的布质、大小完全相<br>同,而每对袜了都有一张商标纸连着。两位盲人不小心将八对袜了混在一起。他们每<br>人怎样才能取回黑袜和白袜各两对呢？  </p><blockquote><p>把每双袜子的商标撕开,然后每人拿每双的一只<br>答题完毕.</p></blockquote><p>60、有一辆火车以每小时 15公里的速度离开洛杉矶直奔纽约,另一辆火车以每小时20公<br>里的速度从纽约开往洛杉矶。如果有一只鸟,以30公里每小时的速度和两辆火车同时启动<br>,从洛 杉矶出发,碰到另一辆车后返回,依次在两辆火车来回飞行,直到两辆火车相遇,<br>请问,这只小鸟飞行了多长距离？  </p><blockquote><p>S1= (15+ 20)t<br>S2= 30t<br>得到S2= 6/7 S1.<br>小鸟飞行两地距离的6/7.<br>答题完毕. </p></blockquote><p>61、你有两个罐子,50个红色弹球,50个蓝色弹球,随机选出一个罐子,随机选取出一<br>个弹球放入罐子,怎么给红色弹球最大的选中机会？在你的计划中,得到红球的准确几率<br>是多少？  </p><blockquote><p>一个罐子放一个红球,另一个罐子放49个红球和50个蓝球,概率接近75%<br>答题完毕.</p></blockquote><p>62、你有四个装药丸的罐子,每个药丸都有一定的重量,被污染的药丸是没被污染的重<br>量＋1.只称量一次,如何判断哪个罐子的药被污染了？  </p><blockquote><p>1号罐取一个药片, 2号罐取两个药片,3号罐取3个药片, 4号罐取4个药片.<br>称量总重量, 比正常重量重几, 就是几号罐子被污染了.<br>答题完毕.</p></blockquote><p>63、对一批编号为1～100,全部开关朝上(开)的灯进行以下*作：凡是1的倍数反方向拨<br>一次开关；2的倍数反方向又拨一次开关；3的倍数反方向又拨一次开关……问：最后为关<br>熄状态的灯的编号。  </p><blockquote><p>（1）最初这100个全部开关朝上的灯是亮的.每个灯操作次数如果是奇数,则是关熄状态的灯；每个灯操作次数如果是偶数,则是亮的状态的灯.<br>（2）“凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；3的倍数反方向又拨一次开关…… ”最后每个灯操作次数不是偶数就是奇数.<br>（3）1的平方数是1；,2的平方数是4；3的平方数是9；4的平方数是16；——10的平方数是100.<br>（4）1、4、9、16、25、36、49、64、81、100这10个数的约数个数是奇数,其它90个数约数个数是偶数,所以编号为完全平方数的灯操作次数为奇数次.而其它编号为非完全平方数的灯操作次数为偶数次.<br>（5）最后为关熄状态的灯的编号是1、4、9、16、25、36、49、64、81、100.也就是编号为完全平方数的灯.  </p></blockquote><p>64、想象你在镜子前,请问,为什么镜子中的影像可以颠倒左右,却不能颠倒上下？<br>因为镜子和你平行. </p><blockquote><p>如果镜子与人不平行, 就可以颠倒上下.<br>答题完毕.</p></blockquote><p>65、一群人开舞会,每人头 上都戴着一顶帽子。帽子只有黑白两种,黑的至少有一顶。<br>每个人都能看到其它人帽子的颜色,却看不到自己的。主持人先让大家看看别人头上戴的<br>是什幺帽子,然 后关灯,如果有人认为自己戴的是黑帽子,就打自己一个耳光。第一次关<br>灯,没有声音。于是再开灯,大家再看一遍,关灯时仍然鸦雀无声。一直到第三次关灯,<br>才 有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？  </p><blockquote><p>应该是三个人：<br>1,若是两个人,设A、B是黑帽子,第二次关灯就会有人打耳光。原因是A看到B第一次没打<br>耳光,就知道B也一定看到了有带黑帽子的人,可A除了知道B带黑帽子外,其他人都是白帽<br>子,就可推出他自己是带黑帽子的人！同理B也是这么想的,这样第二次熄灯会有两个耳光<br>的声音。<br>2,如果是三个人,A,B,C. A第一次没打耳光,因为他看到B,C都是带黑帽子的；而且假设<br>自己带的是白帽子,这样只有BC戴的是黑帽子；按照只有两个人带黑帽子的推论,第二次<br>应该有人打耳光；可第二次却没有。。。于是他知道B和C一定看到了除BC之外的其他人带<br>了黑帽子,于是他知道BC看到的那个人一定是他,所以第三次有三个人打了自己一个耳光<br>！<br>答题完毕. </p></blockquote><p>66、两个圆环,半径分别是1和2,小圆在大圆内部绕大圆圆周一周,问小圆自身转了几<br>周？如果在大圆的外部,小圆自身转几周呢？  </p><blockquote><p>小圆周长2π, 大圆周长4π.<br>小圆饶大圆内部一周, 小圆转2圈.<br>在大圆外部, 小圆转2圈.<br>答题完毕. </p></blockquote><p>67、 1元钱一瓶汽水,喝完后两个空瓶换一瓶汽水,问：你有20元钱,最多可以喝到几<br>瓶汽水？    </p><blockquote><p>找人借一个瓶子.20元买汽水, 20个瓶子换10汽水, 10空瓶换5汽水,5空瓶加上借来的空瓶换三瓶汽水, 三瓶子换1汽水,剩余1瓶子, 1空瓶加上剩余空瓶换1汽水, 剩余1空瓶.还给别人20+ 10+5+3+1+1 = 40瓶. 或, 两个空瓶换一瓶汽水.得出汽水(不含瓶)成本等于空瓶成本, 为5毛. 20块等于40个5毛.所以40瓶.<br>答题完毕. </p></blockquote><p>68、有3顶红帽子,4顶黑 帽子,5顶白帽子。让10个人从矮到高站成一队,给他们每个<br>人头上戴一顶帽子。每个人都看不见自己戴的帽子的颜色,却只能看见站在前面那些人的<br>帽子颜色。 (所以最后一个人可以看见前面9个人头上帽子的颜色,而最前面那个人谁的<br>帽子都看不见。现在从最后那个人开始,问他是不是知道自己戴的帽子颜色,如果他回 答<br>说不知道,就继续问他前面那个人。假设最前面那个人一定会知道自己戴的是黑帽子。为<br>什么？  </p><blockquote><p>一共3红4黑5白,第十个人不知道的话,可推出前9个人的所有可能情况:<br>红 黑 白<br>3 3 3<br>3 2 4<br>3 1 5<br>2 3 4<br>2 2 5<br>1 3 5<br>如果第九个人不知道的话,可推出前8个人的所有可能情况：<br>红 黑 白<br>1 2 5<br>1 3 4<br>2 1 5<br>2 2 4<br>2 3 3<br>3 1 4<br>3 2 3<br>由此类推可知,当推倒第六个人时,会发现他已经肯定知道他自己戴的是什么颜色的帽子<br>了．<br>答题完毕.</p></blockquote><p>69、假设排列着100个乒乓球,由两个人轮流拿球装入口袋,能拿到第100个乒乓球的人为胜利者。条件是：每次拿球者至少要拿1个,但最多不能超过5个,问：如果你是最先拿<br>球的人,你该拿几个？以后怎么拿就能保证你能得到第100个乒乓球？  </p><blockquote><p>拿出4个, 然后按照6的倍数和另外一人分别拿球. 即<br>另外一人拿1个, 我拿5个<br>另外一人拿2个, 我拿4个<br>另外一人拿3个, 我拿3个<br>另外一人拿4个, 我拿2个<br>另外一人拿5个, 我拿1个.<br>最终100个在我手上.<br>答题完毕.</p></blockquote><p>70、卢姆教授说：“有一次 我目击了两只山羊的一场殊死决斗,结果引出了一个有趣的 数学问题。我的一位邻居有一只山羊,重54磅,它已有好几个季度在附近山区称王称霸。<br>后来某个好事 之徒引进了一只新的山羊,比它还要重出3磅。开始时,它们相安无事,彼 此和谐相处。可是有一天,较轻的那只山羊站在陡峭的山路顶上,向它的竞争对手猛扑过<br> 去,那对手站在土丘上迎接挑战,而挑战者显然拥有居高临下的优势。不幸的是,由于猛 烈碰撞,两只山羊都一命呜呼了。<br>现在要讲一讲本题的奇妙之处。对饲养山羊颇有研究,还写过书的乔治．阿伯克龙比说道 ：“通过反复实验,我发现,动量相当于一个自20英尺高处坠落下来 的30磅重物的一次撞<br>击,正好可以打碎山羊的脑壳,致它死命。”如果他说得不错,那么这两只山羊至少要有多大的逼近速度,才能相互撞破脑壳？你能算出来吗？     </p><blockquote><p>自由落体20英尺,速度为20英尺/ 秒<br>20 <em> 30= (54+57) </em> V<br>V=50/111 英尺/秒<br>解答完毕.</p></blockquote><p>71、据说有人给酒肆的老板娘出了一个难题：此人明明知道店里只有两个舀酒的勺子, 分别能舀7两和11两酒,却硬要老板娘卖给他2两酒。聪明的老板娘毫不含糊,用这两个勺<br>子在酒缸里舀酒,并倒来倒去,居然量出了2两酒,聪明的你能做到吗？  </p><blockquote><p>7两倒入11两, 再用7两倒入11两装满, 7两中剩余3两, 倒出11两, 将3两倒入11两, 用7两两次倒入11两装满, 7两中剩余6两, 将11两倒出, 将6两倒入, 然后用7两倒入11两, 剩余2两. 于是得到.<br>答题完毕.</p></blockquote><p>72、已知： 每个飞机只有一个油箱, 飞机之间可以相互加油(注意是相互,没有加油机) 一箱油可供一架飞机绕地球飞半圈,问题：为使至少一架飞机绕地球一圈回到起飞时的飞机场,至少需要出动几架飞机？(所有飞机从同一机场起飞,而且必须安全 返回机场,不允许中途降落,中间没有飞机场) </p><blockquote><p>需要4飞机.<br>假设需要三架飞机,编号为1,2,3.三架同时起飞, 飞到1/8 圈处, 1号飞机,给2号,3号,飞机各加上1/8 圈的油, 刚好飞回基 地,此时1号,2号满油,继续前飞;飞到2/8 圈时候,2号飞机给1号飞机加油1/8圈油量,刚好飞回基地, 3号飞机满油,继续向前飞行, 到达6/8处无油;此时重复2号和三号飞机的送油.3号飞机反方向飞行到1/6圈时, 加油1/6圈给给2号飞机,2号飞机向前飞行X圈, 则3号飞机可向前继续送油, 1/6 –2X 圈. 此时3号刚好飞回, 2号满油.当X= 1/6-2X时候获得最大. X =1/18. 1/6 + 1/18= 2/ 9.少于1/4. 所以不能完成.类比推,当为4架时, 恰好满足条件.<br>答题完毕.</p></blockquote><p>73、在9个点上画10条直线,要求每条直线上至少有三个点？ </p><blockquote><p>排列如下所示.X代表点, O代表空格.<br>X   O   X<br>O   X   O<br>X   X   X<br>O   X   O<br>X   O   X<br>得到10条.<br>答题完毕. </p></blockquote><p>74、一个岔路口分别通向诚实国和说谎国。来了两个人,已知一个是诚实国的,另一个是说谎国的。诚实国永远说实话,说谎国永远说谎话。现在你要去说谎国,但不知道应该走哪条路,需要问这两个人。请问应该怎么问？</p><blockquote><p>我要到你的国家去,请问怎么走?然后走向路人所指方向的相反方向.<br>答题完毕.</p></blockquote><p>75、在一天的24小时之中,时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？  </p><blockquote><p>两次, 24点和12点.<br>使用角速度, 讨论分针重合时针时候, 秒针位置.<br>答题完毕.</p></blockquote><p>76、A告诉B他生日的月份,告诉C他生日的日期<br>B说：“如果我不知道A的生日,那C肯定也不知道.”<br>C说：”本来我不知道,现在我知道了.“<br>B说：”哦,那我也知道了.“<br>A的生日可能是：<br>11月4日 11月5日 11月8日 1月4日 1月22日 3月1日 3月5日 7月1日 7月2日 7月8日<br>请问A的生日是几月几日?  </p><blockquote><p>11月4日 11月5日 11月8日<br>1月4日 1月22日<br>3月1日 3月5日<br>7月1日 7月2日 7月8日<br>1月与7月首先排除因为<br>B说：“如果我不知道A的生日,那C肯定也不知道.”<br>可见,如果是1月或者7月,那么日期可能是1月22日、7月2日<br>此时,知道日期的C是可以知道A的生日的.（因为22日与2日没有和其他日期重合）<br>剩余可选日期为<br>11月4日 11月5日 11月8日<br>3月1日 3月5日<br>C说：“本来我不知道,现在我知道了.”<br>排除5日,假如是5日,C应该依然不能确定准确的生日.<br>故剩余日期为<br>11月4日 11月8日<br>3月1日<br>B说：“哦,那我也知道了.”<br>同理排除11月,假如是11月,则B应该依然不能确定准确生日.<br>综上所述为3月1日.  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逻辑题&quot;&gt;&lt;a href=&quot;#逻辑题&quot; class=&quot;headerlink&quot; title=&quot;逻辑题&quot;&gt;&lt;/a&gt;逻辑题&lt;/h2&gt;&lt;p&gt;1、假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水？  &lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单的数据加密</title>
    <link href="http://yoursite.com/2017/10/20/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2017/10/20/简单的数据加密/</id>
    <published>2017-10-20T14:09:41.000Z</published>
    <updated>2017-10-20T14:14:10.609Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单的数据加密"><a href="#简单的数据加密" class="headerlink" title="简单的数据加密"></a>简单的数据加密</h4><p>.H  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">Hash</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *md5String;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *sha1String;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *sha256String;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *sha512String;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)hmacSHA1StringWithKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">NSString</span> *)hmacSHA256StringWithKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="built_in">NSString</span> *)hmacSHA512StringWithKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>.M</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"NSString+hash.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;CommonCrypto/CommonDigest.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;CommonCrypto/CommonHMAC.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Hash</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)md5String</div><div class="line">&#123;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *string = <span class="keyword">self</span>.UTF8String;</div><div class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)strlen(string);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[CC_MD5_DIGEST_LENGTH];</div><div class="line">CC_MD5(string, length, bytes);</div><div class="line"><span class="keyword">return</span> [<span class="keyword">self</span> stringFromBytes:bytes length:CC_MD5_DIGEST_LENGTH];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)sha1String</div><div class="line">&#123;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *string = <span class="keyword">self</span>.UTF8String;</div><div class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)strlen(string);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[CC_SHA1_DIGEST_LENGTH];</div><div class="line">CC_SHA1(string, length, bytes);</div><div class="line"><span class="keyword">return</span> [<span class="keyword">self</span> stringFromBytes:bytes length:CC_SHA1_DIGEST_LENGTH];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)sha256String</div><div class="line">&#123;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *string = <span class="keyword">self</span>.UTF8String;</div><div class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)strlen(string);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[CC_SHA256_DIGEST_LENGTH];</div><div class="line">CC_SHA256(string, length, bytes);</div><div class="line"><span class="keyword">return</span> [<span class="keyword">self</span> stringFromBytes:bytes length:CC_SHA256_DIGEST_LENGTH];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)sha512String</div><div class="line">&#123;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *string = <span class="keyword">self</span>.UTF8String;</div><div class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)strlen(string);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[CC_SHA512_DIGEST_LENGTH];</div><div class="line">CC_SHA512(string, length, bytes);</div><div class="line"><span class="keyword">return</span> [<span class="keyword">self</span> stringFromBytes:bytes length:CC_SHA512_DIGEST_LENGTH];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)hmacSHA1StringWithKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line"><span class="built_in">NSData</span> *keyData = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"><span class="built_in">NSData</span> *messageData = [<span class="keyword">self</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"><span class="built_in">NSMutableData</span> *mutableData = [<span class="built_in">NSMutableData</span> dataWithLength:CC_SHA1_DIGEST_LENGTH];</div><div class="line">CCHmac(kCCHmacAlgSHA1, keyData.bytes, keyData.length, messageData.bytes, messageData.length, mutableData.mutableBytes);</div><div class="line"><span class="keyword">return</span> [<span class="keyword">self</span> stringFromBytes:(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)mutableData.bytes length:mutableData.length];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)hmacSHA256StringWithKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line"><span class="built_in">NSData</span> *keyData = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"><span class="built_in">NSData</span> *messageData = [<span class="keyword">self</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"><span class="built_in">NSMutableData</span> *mutableData = [<span class="built_in">NSMutableData</span> dataWithLength:CC_SHA256_DIGEST_LENGTH];</div><div class="line">CCHmac(kCCHmacAlgSHA256, keyData.bytes, keyData.length, messageData.bytes, messageData.length, mutableData.mutableBytes);</div><div class="line"><span class="keyword">return</span> [<span class="keyword">self</span> stringFromBytes:(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)mutableData.bytes length:mutableData.length];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)hmacSHA512StringWithKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line"><span class="built_in">NSData</span> *keyData = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"><span class="built_in">NSData</span> *messageData = [<span class="keyword">self</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"><span class="built_in">NSMutableData</span> *mutableData = [<span class="built_in">NSMutableData</span> dataWithLength:CC_SHA512_DIGEST_LENGTH];</div><div class="line">CCHmac(kCCHmacAlgSHA512, keyData.bytes, keyData.length, messageData.bytes, messageData.length, mutableData.mutableBytes);</div><div class="line"><span class="keyword">return</span> [<span class="keyword">self</span> stringFromBytes:(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)mutableData.bytes length:mutableData.length];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Helpers</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)stringFromBytes:(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)bytes length:(<span class="keyword">int</span>)length</div><div class="line">&#123;</div><div class="line"><span class="built_in">NSMutableString</span> *mutableString = <span class="string">@""</span>.mutableCopy;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</div><div class="line">[mutableString appendFormat:<span class="string">@"%02x"</span>, bytes[i]];</div><div class="line"><span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithString:mutableString];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简单的数据加密&quot;&gt;&lt;a href=&quot;#简单的数据加密&quot; class=&quot;headerlink&quot; title=&quot;简单的数据加密&quot;&gt;&lt;/a&gt;简单的数据加密&lt;/h4&gt;&lt;p&gt;.H  &lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程互斥锁</title>
    <link href="http://yoursite.com/2017/10/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/20/多线程互斥锁/</id>
    <published>2017-10-20T14:09:13.000Z</published>
    <updated>2017-10-20T17:11:20.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题："><a href="#在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：" class="headerlink" title="在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题："></a>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：</h3><h4 id="一、-synchronized-id-anObject-最简单的方法"><a href="#一、-synchronized-id-anObject-最简单的方法" class="headerlink" title="一、@synchronized(id anObject),(最简单的方法)"></a>一、@synchronized(id anObject),(最简单的方法)</h4><blockquote><p>会自动对参数对象加锁，保证临界区内的代码线程安全</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) </div><div class="line">&#123; </div><div class="line">   <span class="comment">// 这段代码对其他 @synchronized(self) 都是互斥的 </span></div><div class="line">   <span class="comment">// self 指向同一个对象 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h4 id="二、NSLock"><a href="#二、NSLock" class="headerlink" title="二、NSLock"></a>二、NSLock</h4><blockquote><p>NSLock对象实现了NSLocking protocol，包含几个方法：  </p><ul><li>lock，加锁</li><li>unlock，解锁</li><li>tryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO</li><li>lockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO  </li></ul><p>比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLock</span> *theLock = [[<span class="built_in">NSLock</span> alloc] init]; </div><div class="line"><span class="keyword">if</span> ([theLock lock]) </div><div class="line">&#123; </div><div class="line">   <span class="comment">//do something here </span></div><div class="line">   [theLock unlock]; </div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h4 id="三、NSRecursiveLock，递归锁"><a href="#三、NSRecursiveLock，递归锁" class="headerlink" title="三、NSRecursiveLock，递归锁"></a>三、NSRecursiveLock，递归锁</h4><blockquote><p>NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSRecursiveLock</span> *theLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init]; </div><div class="line"><span class="keyword">void</span> MyRecursiveFunction(<span class="keyword">int</span> value) </div><div class="line">&#123; </div><div class="line">   [theLock lock]; </div><div class="line">   <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</div><div class="line">       --value</div><div class="line">       MyRecursiveFunction(value); </div><div class="line">    &#125; </div><div class="line">    [theLock unlock]; </div><div class="line">&#125; </div><div class="line">MyRecursiveFunction(<span class="number">5</span>);</div></pre></td></tr></table></figure></blockquote><h4 id="四、NSConditionLock，条件锁"><a href="#四、NSConditionLock，条件锁" class="headerlink" title="四、NSConditionLock，条件锁"></a>四、NSConditionLock，条件锁</h4><blockquote><p>NSConditionLock，条件锁，可以设置条件</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//公共部分 </span></div><div class="line"><span class="keyword">id</span> condLock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:NO_DATA]; </div><div class="line"><span class="comment">//线程一，生产者 </span></div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123; </div><div class="line">  [condLock lockWhenCondition:NO_DATA]; </div><div class="line">  <span class="comment">//生产数据 </span></div><div class="line">  [condLock unlockWithCondition:HAS_DATA]; </div><div class="line">&#125; </div><div class="line">  <span class="comment">//线程二，消费者 </span></div><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) </div><div class="line">&#123; </div><div class="line">  [condLock lockWhenCondition:HAS_DATA]; </div><div class="line">  <span class="comment">//消费 </span></div><div class="line">  [condLock unlockWithCondition:NO_DATA];</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><h4 id="五、NSDistributedLock，分布锁"><a href="#五、NSDistributedLock，分布锁" class="headerlink" title="五、NSDistributedLock，分布锁"></a>五、NSDistributedLock，分布锁</h4><blockquote><p>NSDistributedLock，分布锁，文件方式实现，可以跨进程  </p><ul><li>用tryLock方法获取锁。</li><li>用unlock方法释放锁。  </li></ul><p>如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。<br>程序A：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">  lock = [[<span class="built_in">NSDistributedLock</span> alloc] initWithPath:<span class="string">@"/Users/mac/Desktop/earning__"</span>];</div><div class="line">  [lock breakLock];</div><div class="line">  [lock tryLock];</div><div class="line">  sleep(<span class="number">10</span>);</div><div class="line">  [lock unlock];</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"appA: OK"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>程序B：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">   lock = [[<span class="built_in">NSDistributedLock</span> alloc] initWithPath:<span class="string">@"/Users/mac/Desktop/earning__"</span>];</div><div class="line">   <span class="keyword">while</span> (![lock tryLock]) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"appB: waiting"</span>);</div><div class="line">     sleep(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   [lock unlock];</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"appB: OK"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><p>先运行程序A,然后立即运行程序B,根据打印你可以清楚的发现，当程序A刚运行的时候，程序B一直处于等待中，当大概10秒过后，程序B便打印出了appB:OK的输出，以上便实现了两上不同程序之间的互斥。/Users/mac/Desktop/earning__是一个文件或文件夹的地址，如果该文件或文件夹不存在，那么在tryLock返回YES时，会自动创建该文件/文件夹。在结束的时候该文件/文件夹会被清除，所以在选择的该路径的时候，应该选择一个不存在的路径，以防止误删了文件。</p></blockquote></blockquote><h4 id="六、条件信号量dispatch-semaphore-t"><a href="#六、条件信号量dispatch-semaphore-t" class="headerlink" title="六、条件信号量dispatch_semaphore_t"></a>六、条件信号量dispatch_semaphore_t</h4><blockquote><p><code>dispatch_semaphore_t</code>:GCD中信号量，也可以解决资源抢占问题,支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，直到信号量大于0开始执行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"MYDispatchSemaphoreViewController.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYDispatchSemaphoreViewController</span> ()</span></div><div class="line">&#123;</div><div class="line">    dispatch_semaphore_t semaphore;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MYDispatchSemaphoreViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view.</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  创建一个信号量为1的信号</div><div class="line">     *</div><div class="line">     */</div><div class="line">    semaphore = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">- (<span class="keyword">void</span>)getIamgeName:(<span class="built_in">NSMutableArray</span> *)imageNames&#123;</div><div class="line">    <span class="built_in">NSString</span> *imageName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  semaphore：等待信号</div><div class="line">     DISPATCH_TIME_FOREVER：等待时间</div><div class="line">     wait之后信号量-1，为0</div><div class="line">     */</div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="keyword">if</span> (imageNames.count&gt;<span class="number">0</span>) &#123;</div><div class="line">        imageName = [imageNames lastObject];</div><div class="line">        [imageNames removeObject:imageName];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  发送一个信号通知，这时候信号量+1，为1</div><div class="line">     */</div><div class="line">    dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：&quot;&gt;&lt;a href=&quot;#在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：&quot; class=&quot;headerlink&quot; title=&quot;在iOS中有几种方法来解决多线程访问同一个内存地址的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题二</title>
    <link href="http://yoursite.com/2017/10/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/10/19/面试题二/</id>
    <published>2017-10-19T13:10:15.000Z</published>
    <updated>2017-10-21T13:39:00.694Z</updated>
    
    <content type="html"><![CDATA[<p>1.OC的理解与特性    </p><blockquote><ul><li>OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言。  </li><li>Objective-C具有相当多的动态特性，表现为三方面：动态类型（Dynamic typing）、动态绑定（Dynamic binding）和动态加载（Dynamic loading）。动态——必须到运行时（run time）才会做的一些事情。  <ul><li>动态类型：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单来说就是id类型。事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛。静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。  </li><li>动态绑定：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对应的属性和响应消息也被完全确定。  </li><li>动态加载：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retina设备上加载@2x的图片，而在老一些的普通苹设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类。</li></ul></li></ul></blockquote><p>2.简述内存管理基本原则  </p><blockquote><ul><li>之前：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建或引用一个对象的时候，需要向她发送alloc、copy、retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（MRC）。  </li><li>目前：iOS 5.0之后引用自动管理机制——自动引用计数（ARC），管理机制与手动机制一样，只是不再需要调用retain、release、autorelease；它编译时的特性，当你使用ARC时，在适当位置插入release和autorelease；它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。  </li><li>如果使用alloc、copy(mutableCopy)或者retian一个对象时,你就有义务,向它发送一条release或者autorelease消息。其他方法创建的对象,不需要由你来管理内存。（MRC）  </li><li>向一个对象发送一条autorelease消息,这个对象并不会立即销毁, 而是将这个对象放入了自动释放池,待池子释放时,它会向池中每一个对象发送 一条release消息,以此来释放对象. （MRC）  </li><li>向一个对象发送release消息,并不意味着这个对象被销毁了,而是当这个对象的引用计数为0时,系统才会调用dealloc方法,释放该对象和对象本身它所拥有的实例。（MRC） </li></ul><p><strong>其他注意事项 :</strong></p><ul><li>如果一个对象有一个strong类型的指针指向着，这个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil。如果一个指针被指向nil，那么它原来指向的对象就被释放了。当一个视图控制器被释放时，它内部的全局指针会被指向nil。用法：不管全局变量还是局部变量用strong描述就行。  </li><li>局部变量：出了作用域，指针会被置为nil。  </li><li>方法内部创建对象，外部使用需要添加_autorelease;  </li><li>连线的时候，用_weak描述。  </li><li>代理使用unsafe_unretained就相当于assign；  </li><li>block中为了避免循环引用问题，使用_weak描述；  </li><li>声明属性时，不要以new开头。如果非要以new开头命名属性的名字，需要自己定制get方法名，如<code>@property(getter=theString) NSString * newString;</code>   </li><li>如果要使用自动释放池，用@autoreleasepool{}  </li><li>ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成COre Foundation中的变量需要交换管理权；  </li><li>在非ARC工程中采用ARC去编译某些类：-fobjc-arc。  </li><li>在ARC下的工程采用非ARC去编译某些类：-fno-objc-arc。</li></ul></blockquote><p>3.如何理解MVC设计模式  </p><blockquote><p>MVC是一种架构模式，M表示MOdel，V表示视图View，C表示控制器Controller： </p><ul><li>Model负责存储、定义、操作数据；  </li><li>View用来展示书给用户，和用户进行操作交互；  </li><li>Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，MOdel也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，MOdel发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。  </li></ul></blockquote><p>4.如何理解MVVM设计模式  </p><blockquote><ul><li>ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。  </li><li>View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。  </li><li>如需了解更多，请查看<a href="https://www.teehanlax.com/blog/model-view-viewmodel-for-ios/" target="_blank" rel="external">这篇文章</a>。  </li></ul></blockquote><p>5.Objective-C 中是否支持垃圾回收机制？  </p><blockquote><ul><li>OC是支持垃圾回收机制的(Garbage collection简称GC),但是apple的移动终端中,是不支持GC的,Mac桌面系统开发中是支持的.  </li><li>移动终端开发是支持ARC（Automatic Reference Counting的简称）,ARC是在IOS5之后推出的新技术,它与GC的机制是不同的。我们在编写代码时, 不需要向对象发送release或者autorelease方法,也不可以调用delloc方法,编译器会在合适的位置自动给用户生成release消息(autorelease),ARC的特点是自动引用技术简化了内存管理的难度.  </li></ul></blockquote><p>6.协议的基本概念和协议中方法默认为什么类型  </p><blockquote><ul><li>OC中的协议是一个方法列表,且多少有点相关。它的特点是可以被任何类使用(实现),但它并不是类(这里我们需要注意),自身不会实现这样方法, 而是又其他人来实现协议经常用来实现委托对象(委托设计模式)。如果一个类采用了一个协议,那么它必须实现协议中必须需要实现的方法,在协议中的方法默认是必须实现(@required),添加关键字@optional,表明一旦采用该协议,这些“可选”的方法是可以选择不实现的。</li></ul></blockquote><p>7.简述类目category优点和缺点  </p><blockquote><p>优点： </p><ul><li>不需要通过增加子类而增加现有类的行为(方法),且类目中的方法与原始类方法基本没有区别;  </li><li>通过类目可以将庞大一个类的方法进行划分,从而便于代码的日后的维护、更新以及提高代码的阅读性;</li></ul><p>缺点：  </p><ul><li>无法向类目添加实例变量,如果需要添加实例变量,只能通过定义子类的方式;</li><li>类目中的方法与原始类以及父类方法相比具有更高优先级,如果覆盖父类的方法,可能导致super消息的断裂。因此,最好不要覆盖原始类中的方法。  </li></ul></blockquote><p>8.类别的作用  </p><blockquote><ul><li>给系统原有类添加方法，不能扩展属性。如果类别中方法的名字跟系统的方法名一样，在调用的时候类别中的方法优先级更高；  </li><li><p>分散类的实现如：<br><code>+ (NSIndexPath *)indexPathForRow:(NSInteger)row inSection:(NSInteger)section</code><br>原本属于NSIndexPath的方法，但因为这个方法经常使用的表的时候调用、跟表的关系特别密切，因此把这个方法一类别的形式、声明在UITableView.h中。</p></li><li><p>声明私有方法，某一个方法只实现，不声明，相当于私有方法。  </p></li><li>类别不能声明变量，类别不可以直接添加属性。property描述setter方法，就不会报错。</li></ul></blockquote><p>9.循环引用的产生原因，以及解决方法  </p><blockquote><ul><li><p>产生原因：如下图所示，对象A和对象B相互引用了对方作为自己的成员变量，只有自己销毁的时候才能将成员变量的引用计数减1。对象A的销毁依赖于对象B的销毁，同时对象B销毁也依赖与对象A的销毁，从而形成循环引用，此时，即使外界没有任何指针访问它，它也无法释放。<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458636240331049.png" alt=""><br>多个对象间依然会存在循环引用问题，形成一个环，在编程中，形成的环越大越不容易察觉，如下图所示：<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458636212752528.png" alt=""><br>解决方法：</p></li><li><p>事先知道存在循环引用的地方，在合理的位置主动断开一个引用，是对象回收；  </p></li><li>使用<a href="https://www.tuicool.com/articles/NVNrMv7" target="_blank" rel="external">弱引用</a>的方法。  </li></ul></blockquote><p>10.键路径(keyPath)、键值编码（KVC）和键值观察（KVO） </p><blockquote><p>键路径</p><ul><li>在一个给定的实体中,同一个属性的所有值具有相同的数据类型。</li><li>键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。 - 键路径是一个由用点作分隔符的键组成的字符串,用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的,接下来每个键的值也是相对于其前面的性质。</li><li>键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径,您可以指定对象图中的一个任意深度的路径,使其指向相关对象的特定属性。 </li></ul><p>键值编码KVC </p><ul><li>键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码；</li><li>KVC的缺点：一旦使用 KVC 你的编译器无法检查出错误,即不会对设置的键、键路径进行错误检查,且执行效率要低于合成存取器方法和自定的 setter 和 getter 方法。因为使用 KVC 键值编码,它必须先解析字符串,然后在设置或者访问对象的实例变量。 </li></ul><p>键值观察KVO</p><ul><li>键值观察机制是一种能使得对象获取到其他对象属性变化的通知 ，极大的简化了代码。</li><li>实现 KVO 键值观察模式,被观察的对象必须使用 KVC 键值编码来修 改它的实例变量,这样才能被观察者观察到。因此,KVC是KVO的基础。<br>Demo(自定义的一个button)  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"highlighted"</span> options:<span class="number">0</span> context:<span class="literal">nil</span>]; </div><div class="line"><span class="meta">#pragma mark KVO </span></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"highlighted"</span>] ) &#123; </div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay]; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</p></blockquote><p>11.KVC机制通过key找到value的原理。  </p><blockquote><ul><li>当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过下面几种不同的方式解析这个调用。</li><li>首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。</li><li>补充：KVC查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。</li><li>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。</li></ul></blockquote><p>12.在 Objective-C 中如何实现 KVO  </p><blockquote><ul><li>注册观察者(注意：观察者和被观察者不会被保留也不会被释放)</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure><ul><li>接收变更通知  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure><ul><li>移除对象的观察者身份  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure><ul><li>KVO中谁要监听谁注册，然后对响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性名都是通过NSString来查找，编译器不会检错和补全，全部取决于自己。  </li></ul></blockquote><p>13.代理的作用  </p><blockquote><ul><li>代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性。</li><li>改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</li><li>另外一点，代理可以理解为java中的回调监听机制的一种类似。</li><li>代理的属性常是assign的原因：防止循环引用,以至对象无法得到正确的释放。  </li></ul></blockquote><p>14.NSNotification、Block、Delegate和KVO的区别。  </p><blockquote><ul><li>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；</li><li>效率：Delegate比NSNOtification高；</li><li>Delegate和Block一般是一对一的通信；</li><li>Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；</li><li>Block：Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；</li></ul></blockquote><p>15.Objective-C中可修改和不可以修改类型  </p><blockquote><ul><li>可修改不可修改的集合类，就是可动态添加修改和不可动态添加修改。</li><li>比如NSArray和NSMutableArray,前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间  </li></ul></blockquote><p>16.当我们调用一个静态方法时,需要对对象进行 release 吗?  </p><blockquote><ul><li>不需要,静态方法(类方法)创建一个对象时,对象已被放入自动释放池。在自动释放池被释放时,很有可能被销毁。  </li></ul></blockquote><p>17.当我们释放我们的对象时,为什么需要调用[super dealloc]方法,它的位置又是如何的呢?  </p><blockquote><ul><li>因为子类的某些实例是继承自父类的,因此需要调用[super dealloc]方法, 来释放父类拥有的实例,其实也就是子类本身的。一般来说我们优先释放子类拥 有的实例,最后释放父类所拥有的实例</li></ul></blockquote><p>18.对谓词的认识</p><blockquote><p>Cocoa 中提供了一个NSPredicate的类,该类主要用于指定过滤器的条件, 每一个对象通过谓词进行筛选,判断条件是否匹配。<a href="http://www.cocoachina.com/ios/20160111/14926.html" target="_blank" rel="external">iOS中的谓词（NSPredicate）使用</a>  </p></blockquote><p>19.static、self、super关键字的作用  </p><blockquote><ul><li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值.</li><li>在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问.</li><li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明.</li><li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝.</li><li>self:当前消息的接收者。</li><li>super:向父类发送消息。</li></ul></blockquote><p>20.#include与#import的区别，#import 与@class 的区别  </p><blockquote><ul><li><code>#include</code> 和<code>#impor</code>t其效果相同,都是查询类中定义的行为(方法);</li><li><code>#import</code>不会引起交叉编译,确保头文件只会被导入一次；</li><li><code>@class</code> 的表明,只定 义了类的名称,而具体类的行为是未知的,一般用于.h 文件；</li><li><code>@class</code> 比<code>#import</code>编译效率更高。</li><li>此外<code>@class</code>和<code>#import</code>的主要区别在于解决引用死锁的问题。</li></ul></blockquote><p>21.@public、@protected、@private 它们的含义与作用  </p><blockquote><ul><li>@public:对象的实例变量的作用域在任意地方都可以被访问 ;</li><li>@protected:对象的实例变量作用域在本类和子类都可以被访问 ;</li><li>@private:实例变量的作用域只能在本类(自身)中访问 .</li></ul></blockquote><p>22.解释 id 类型</p><blockquote><ul><li>任意类型对象，程序运行时才决定对象的类型。</li></ul></blockquote><p>23.switch 语句 if 语句区别与联系  </p><blockquote><ul><li>均表示条件的判断,switch语句表达式只能处理的是整型、字符型和枚举类型,而选择流程语句则没有这样的限制。但switch语句比选择流程控制语句效率更高。</li></ul></blockquote><p>24.isMemberOfClass 和 isKindOfClass 联系与区别  </p><blockquote><ul><li>联系：两者都能检测一个对象是否是某个类的成员</li><li>区别：isKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员 ,而isMemberOfClass 只能做到第一点。</li><li>举例：如 ClassA派 生 自NSObject 类 , ClassA *a = [ClassA alloc] init];,[a isKindOfClass:[NSObject class]] 可以检查出 a 是否是 NSObject派生类 的成员,但 isMemberOfClass 做不到。  </li></ul></blockquote><p>25.iOS 开发中数据持久性有哪几种?  </p><blockquote><p>数据存储的核心都是写文件。</p><ul><li>属性列表：只有NSString、NSArray、NSDictionary、NSData可writeToFile；存储依旧是plist文件。plist文件可以存储的7种数据类型：array、dictionary、string、bool、data、date、number。</li><li>对象序列化（对象归档）：对象序列化通过序列化的形式，键值关系存储到本地，转化成二进制流。通过runtime实现自动化归档/解档，实现NSCoding协议必须实现的两个方法：<br>1.编码（对象序列化）：把不能直接存储到plist文件中得到数据，转化为二进制数据，NSData，可以存储到本地；<br>2.解码（对象反序列化）：把二进制数据转化为本来的类型。  </li><li>SQLite 数据库：大量有规律的数据使用数据库。</li><li>CoreData ：通过管理对象进行增、删、查、改操作的。它不是一个数据库，不仅可以使用SQLite数据库来保持数据，也可以使用其他的方式来存储数据。如：XML。 </li></ul><p>CoreData的介绍： </p><ul><li>CoreData是面向对象的API，CoreData是iOS中非常重要的一项技术，几乎在所有编写的程序中，CoreData都作为数据存储的基础。</li><li>CoreData是苹果官方提供的一套框架，用来解决与对象声明周期管理、对象关系管理和持久化等方面相关的问题。</li><li>大多数情况下，我们引用CoreData作为持久化数据的解决方案，并利用它作为持久化数据映射为内存对象。提供的是对象-关系映射功能，也就是说，CoreData可以将Objective-C对象转换成数据，保存到SQL中，然后将保存后的数据还原成OC对象。  </li></ul><p>CoreData的特征：</p><ul><li>通过CoreData管理应用程序的数据模型，可以极大程度减少需要编写的代码数量。</li><li>将对象数据存储在SQLite数据库已获得性能优化。</li><li>提供NSFetchResultsController类用于管理表视图的数据，即将Core Data的持久化存储在表视图中，并对这些数据进行管理：增删查改。</li><li>管理undo/redo操纵；</li><li>检查托管对象的属性值是否正确。</li></ul></blockquote><p>26.Core Data的6成员对象</p><blockquote><ul><li>NSManageObject:被管理的数据记录Managed Object Model是描述应用程序的数据模型，这个模型包含实体（Entity）、特性（Property）、读取请求（Fetch Request）等。</li><li>NSManageObjectContext：管理对象上下文，持久性存储模型对象，参与数据对象进行各种操作的全过程，并监测数据对象的变化，以提供对undo/redo的支持及更新绑定到数据的UI。</li><li>NSPersistentStoreCoordinator:连接数据库的Persistent Store Coordinator相当于数据文件管理器，处理底层的对数据文件的读取和写入，一般我们与这个没有交集。</li><li>NSManagedObjectModel：被管理的数据模型、数据结构。</li><li>NSFetchRequest：数据请求；</li><li>NSEntityDescription：表格实体结构，还需知道.xcdatamodel文件编译后为.momd或者.mom文件。</li></ul></blockquote><p>27.Core Data的功能  </p><blockquote><ul><li>对于KVC和KVO完整且自动化的支持，除了为属性整合KVO和KVC访问方法外，还整合了适当的集合访问方法来处理多值关系；</li><li>自动验证属性（property）值；</li><li>支持跟踪修改和撤销操作；</li><li>关系维护，Core Data管理数据的关系传播，包括维护对象间的一致性；</li><li>在内存上和界面上分组、过滤、组织数据；</li><li>自动支持对象存储在外部数据仓库的功能；</li><li>创建复杂请求：无需动手写SQL语句，在获取请求（fetch request）中关联NSPredicate。NSPreadicate支持基本功能、相关子查询和其他高级的SQL特性。它支持正确的Unicode编码、区域感知查询、排序和正则表达式；</li><li>延迟操作：Core Data使用懒加载（lazy loading）方式减少内存负载，还支持部分实体化延迟加载和复制对象的数据共享机制；</li><li>合并策略：Core Data内置版本跟踪和乐观锁（optimistic locking）来支持多用户写入冲突的解决，其中，乐观锁就是对数据冲突进行检测，若冲突就返回冲突的信息；</li><li>数据迁移：Core Data的Schema Migration工具可以简化应对数据库结构变化的任务，在某些情况允许你执行高效率的数据库原地迁移工作；</li><li>可选择针对程序Controller层的集成，来支持UI的显示同步Core Data在IPhone OS之上，提供NSFetchedResultsController对象来做相关工作，在Mac OS X上我们用Cocoa提供的绑定（Binding）机制来完成的。  </li></ul></blockquote><p>28.对象可以被copy的条件  </p><blockquote><ul><li>只有实现了NSCopying和NSMutableCopying协议的类的对象才能被拷贝,分为不可变拷贝和可变拷贝,具体区别<a href="http://www.jianshu.com/p/f84803356cbb" target="_blank" rel="external">戳这里</a></li><li>NSCopying协议方法为：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</div><div class="line">  MyObject *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone: zone] init];</div><div class="line">  <span class="keyword">copy</span>.username = [<span class="keyword">self</span>.username copyWithZone:zone];</div><div class="line">  <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><p>29.自动释放池工作原理  </p><blockquote><ul><li>自动释放池是NSAutorelease类的一个实例,当向一个对象发送autorelease消息时,该对象会自动入池,待池销毁时,将会向池中所有对象发送一条release消息,释放对象。</li><li>[pool release]、 [pool drain]表示的是池本身不会销毁,而是池子中的临时对象都被发送release,从而将对象销毁。  </li></ul></blockquote><p>30.在某个方法中 <strong>self.name = _name</strong>，<strong>name = _name</strong> 它们有区别吗，为什么?</p><blockquote><ul><li>前者是存在内存管理的setter方法赋值,它会对<code>_name</code>对象进行保留或者拷贝操作</li><li>后者是普通赋值</li><li>一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写Setter方法来执行某些额外的工作。比如说，外部传一个模型过来，那么我会直接重写Setter方法，当模型传过来时，也就是意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI。  </li></ul></blockquote><p>31.解释self = [super init]方法  </p><blockquote><ul><li>容错处理,当父类初始化失败,会返回一个nil,表示初始化失败。由于继承的关系,子类是需要拥有父类的实例和行为,因此,我们必须先初始化父类,然后再初始化子类</li></ul></blockquote><p>32.定义属性时，什么时候用 assign、retain、copy 以及它们的之间的区别。  </p><blockquote><ul><li>assign:普通赋值,一般常用于基本数据类型,常见委托设计模式, 以此来防止循环引用。(我们称之为弱引用).</li><li>retain:保留计数,获得到了对象的所有权,引用计数在原有基础上加1.</li><li>copy:一般认为,是在内存中重新开辟了一个新的内存空间,用来 存储新的对象,和原来的对象是两个不同的地址,引用计数分别为1。但是当copy对象为不可变对象时,那么copy 的作用相当于retain。因为,这样可以节约内存空间</li></ul></blockquote><p>33.堆和栈的区别</p><blockquote><ul><li>栈区(stack)由编译器自动分配释放 ,存放方法(函数)的参数值, 局部变量的值等，栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的。</li><li>堆区(heap)一般由程序员分配释放, 若程序员不释放,程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活。</li><li>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出.</li><li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li><li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</li><li>全局区(静态区)(static),全局变量和静态变量的存储是放在一块 的,初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放。</li><li>文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。</li><li>程序代码区—存放函数体的二进制代码</li></ul></blockquote><p>34.怎样使用performSelector传入3个以上参数，其中一个为结构体。</p><blockquote><p>因为系统提供的performSelector的API中，并没有提供三个参数。因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型,我们只能通过对象放入结构作为属性来传过去了.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector;</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object;</div><div class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object1 withObject:(<span class="keyword">id</span>)object2;</div></pre></td></tr></table></figure><p>具体实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> HYBStruct &#123;</div><div class="line"><span class="keyword">int</span> a;</div><div class="line"><span class="keyword">int</span> b;</div><div class="line">&#125; *my_struct;</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HYBObject</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) my_struct arg3;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *arg1;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *arg2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HYBObject</span></span></div><div class="line"><span class="comment">// 在堆上分配的内存，我们要手动释放掉</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">free(<span class="keyword">self</span>.arg3);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">my_struct str = (my_struct)(malloc(<span class="keyword">sizeof</span>(my_struct)));</div><div class="line">str-&gt;a = <span class="number">1</span>;</div><div class="line">str-&gt;b = <span class="number">2</span>;</div><div class="line">HYBObject * obj = [[HYBObject alloc] init];</div><div class="line">obj.arg1 = <span class="string">@"arg1"</span>;</div><div class="line">obj.arg2 = <span class="string">@"arg2"</span>;</div><div class="line">obj.arg3 = str; </div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(call:) withObject:obj];</div><div class="line"><span class="comment">// 在回调时得到正确的数据的</span></div><div class="line">-(<span class="keyword">void</span>)call:(HYBObject *)obj &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d %d"</span>, obj.arg3-&gt;a, obj.arg3-&gt;b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote><p>35.UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</p><blockquote><p>这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：</p><ul><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li><li>UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode</li><li>UIInitializationRunLoopMode：run loop启动时，会切换到该mode</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合  </li></ul><p><strong>苹果公开提供的Mode有两个：</strong></p><ul><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）  </li><li>在编程中：如果我们把一个NSTimer对象NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。</li></ul></blockquote><p>36.对于单元格重用的理解  </p><blockquote><ul><li>当屏幕上滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，若有，就直接用，没有就重新创建一个。  </li></ul></blockquote><p>37.解决cell重用的问题</p><blockquote><ul><li>UITableView通过重用单元格来达到节省内存的目的，通过为每个单元格指定一个重用标示（reuseidentifier），即指定了单元格的种类，以及当单元格滚出屏幕时，允许恢复单元格以便复用。对于不同种类的单元格使用不同的ID，对于简单的表格，一个标示符就够了。</li><li>如一个TableView中有10个单元格，但屏幕最多显示4个，实际上iPhone只为其分配4个单元格的内存，没有分配10个，当滚动单元格时，屏幕内显示的单元格重复使用这4个内存。实际上分配的cell的个数为屏幕最大显示数，当有新的cell进入屏幕时，会随机调用已经滚出屏幕的Cell所占的内存，这就是Cell的重用。</li><li>对于多变的自定义Cell，这种重用机制会导致内容出错，为解决这种出错的方法，把原来的<code>UITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:defineString];</code>修改为：<code>UITableViewCell *cell = [tableview cellForRowAtIndexPath:indexPath];</code>,这样就解决掉cell重用机制导致的问题。</li></ul></blockquote><p>37.有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？  </p><blockquote><ul><li>对于这四个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务a */</span> &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务b */</span> &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务c */</span> &#125;); </div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="comment">/*任务d */</span> &#125;); </div><div class="line">dispatch_group_notify(group,dispatch_get_main_queue(), ^&#123;</div><div class="line"><span class="comment">// 在a、b、c、d异步执行完成后，会回调这里</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>当然，我们还可以使用非常老套的方法来处理，通过四个变量来标识a、b、c、d四个任务是否完成，然后在runloop中让其等待，当完成时才退出runloop。但是这样做会让后面的代码得不到执行，直到Run loop执行完毕。</li><li>解释：要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了。  </li></ul></blockquote><p>38.使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码。  </p><blockquote><ul><li>代码紧凑，传值、回调都很方便，省去了写代理的很多代码。</li><li>NSTimer封装成的block，<a href="http://www.jianshu.com/p/1dbd7a228a22" target="_blank" rel="external">具体实现</a>。</li><li>实现方法：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES callback:^() &#123;</div><div class="line">  weakSelf.secondsLabel.text = ...</div><div class="line">&#125;</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure></blockquote><p>39.一个view已经初始化完毕，view上面添加了n个button，除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改button的值。  </p><blockquote><p>有2种方法解决：</p><ul><li>第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可。</li><li>第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找。  </li></ul></blockquote><p>40.线程与进程的区别和联系?  </p><blockquote><ul><li>一个程序至少要有进程,一个进程至少要有一个线程。</li><li>进程:资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li><li>线程:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。</li><li>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</li><li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li><li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。  </li></ul></blockquote><p>41.多线程编程  </p><blockquote><ul><li>NSThread:当需要进行一些耗时操作时会把耗时的操作放到线程中。线程同步：多个线程同时访问一个数据会出问题，NSlock、线程同步块、@synchronized(self){}。</li><li>NSOperationQueue操作队列（不需考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation、BSBlockOperation、自定义Operation。创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到操作队列中时，默认会调用main方法。</li><li>GCD（`Grand Central Dispatch）宏大的中央调度，串行队列、并发队列、主线程队列；</li><li>同步和异步：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个。</li><li>串行和并行：串行是多个任务按一定顺序执行，并行是多个任务同时执行；</li><li>代码是在分线程执行，在主线程队列中刷新UI。  </li></ul><p><strong>多线程编程是防止主线程堵塞、增加运行效率的最佳方法。</strong>  </p><ul><li>Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法；</li><li>一个NSOperationQueue操作队列，相当于一个线程管理器，而非一个线程，因为你可以设置这个线程管理器内可以并行运行的线程数量等。</li><li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。</li><li>iPhoneOS下的主线程的堆栈大小是1M。第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力。  </li></ul></blockquote><p>42.定时器与线程的区别</p><blockquote><ul><li>定时器;可以执行多次，默认在主线程中。</li><li>线程：只能执行一次。</li></ul></blockquote><p>43.Apple设备尺寸和编程尺寸  </p><blockquote><p><img src="http://oui2ar2u7.bkt.clouddn.com/1458634713310033.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/1458634609615814.png" alt=""><br><img src="http://oui2ar2u7.bkt.clouddn.com/1458634677550676.png" alt="">  </p></blockquote><p>44.TCP和UDP的区别于联系  </p><blockquote><ul><li>TCP为传输控制层协议，为面向连接、可靠的、点到点的通信；</li><li>UDP为用户数据报协议，非连接的不可靠的点到多点的通信；</li><li>TCP侧重可靠传输，UDP侧重快速传输。  </li></ul></blockquote><p>45.TCP连接的三次握手  </p><blockquote><ul><li>第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN+RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次状态。  </li></ul></blockquote><p>46.Scoket连接和HTTP连接的区别  </p><blockquote><ul><li>HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</li><li>HTTP连接：短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPhone主要使用类NSURLConnection。</li><li>Socket连接：长连接，客户端跟服务器端直接使用Socket进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8K（理解为一个数据包大小）</li></ul></blockquote><p>47.HTTP协议的特点，关于HTTP请求GET和POST的区别  </p><blockquote><p>GET和POST的区别：</p><ul><li>HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。HTTP是一个属于应用层面向对象的协议，HTTP有两类报文：请求报文和响应报文。</li><li>HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。</li><li>HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。</li><li>GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有参数都拼接在地址后面），不适合传输大量数据（长度有限制，为1024个字节）。</li><li>GET提交、请求的数据会附在URL之后，即把数据放置在HTTP协议头中。以？分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母或数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。</li><li>POST请求：参数在请求数据区放着，相对GET请求更安全，并且数据大小没有限制。把提交的数据放置在HTTP包的包体中.</li><li>GET提交的数据会在地址栏显示出来，而POST提交，地址栏不会改变。  </li></ul><p><strong>传输数据的大小：</strong></p><ul><li>GET提交时，传输数据就会受到URL长度限制，POST由于不是通过URL传值，理论上书不受限。  </li></ul><p><strong>安全性：</strong></p><ul><li>POST的安全性要比GET的安全性高；</li><li>通过GET提交数据，用户名和密码将明文出现在URL上，比如登陆界面有可能被浏览器缓存。</li><li>HTTPS：安全超文本传输协议（Secure Hypertext Transfer Protocol），它是一个安全通信通道，基于HTTP开发，用于客户计算机和服务器之间交换信息，使用安全套结字层（SSI）进行信息交换，即HTTP的安全版。  </li></ul></blockquote><p>48.ASIHttpRequest、AFNetWorking之间的区别  </p><blockquote><ul><li>ASIHttpRequest功能强大，主要是在MRC下实现的，是对系统CFNetwork API进行了封装，支持HTTP协议的CFHTTP，配置比较复杂，并且ASIHttpRequest框架默认不会帮你监听网络改变，如果需要让ASIHttpRequest帮你监听网络状态改变，并且手动开始这个功能。</li><li>AFNetWorking构建于NSURLConnection、NSOperation以及其他熟悉的Foundation技术之上。拥有良好的架构，丰富的API及模块构建方式，使用起来非常轻松。它基于NSOperation封装的，AFURLConnectionOperation子类。</li><li>ASIHttpRequest是直接操作对象ASIHttpRequest是一个实现了NSCoding协议的NSOperation子类；AFNetWorking直接操作对象的AFHttpClient，是一个实现NSCoding和NSCopying协议的NSObject子类。</li><li>同步请求：ASIHttpRequest直接通过调用一个startSynchronous方法；AFNetWorking默认没有封装同步请求，如果开发者需要使用同步请求，则需要重写getPath:paraments:success:failures方法，对于AFHttpRequestOperation进行同步处理。</li><li>性能对比：AFNetworking请求优于ASIHttpRequest；  </li></ul></blockquote><p>49.XML数据解析方式各有什么不同，JSON解析有哪些框架？  </p><blockquote><ul><li>XML数据解析的两种解析方式：DOM解析和SAX解析；</li><li>DOM解析必须完成DOM树的构造，在处理规模较大的XML文档时就很耗内存，占用资源较多，读入整个XML文档并构建一个驻留内存的树结构（节点树），通过遍历树结构可以检索任意XML节点，读取它的属性和值，通常情况下，可以借助XPath查询XML节点；</li><li>SAX与DOM不同，它是事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或者一条指令时，程序就产生一个事件进行相应的处理，一边读取XML文档一边处理，不必等整个文档加载完才采取措施，当在读取解析过程中遇到需要处理的对象，会发出通知进行处理。因此，SAX相对于DOM来说更适合操作大的XML文档。</li><li>JSON解析：性能比较好的主要是第三方的JSONKIT和iOS自带的JSON解析类，其中自带的JSON解析性能最高，但只能用于iOS5之后。</li></ul></blockquote><p>50.如何进行真机调试？  </p><blockquote><p>1.首先需要用钥匙串创建一个钥匙（key）；<br>2.将钥匙串上传到官网，获取iOS Development证书；<br>3.创建App ID即我们应用程序中的Boundle ID；<br>4.添加Device ID即UDID；<br>5.通过勾选前面所创建的证书：App ID、Device ID；<br>6.生成mobileprovision文件；<br>7.先决条件：申请开发者账号 99美刀  </p></blockquote><p>51.APP发布的上架流程  </p><blockquote><p>1.登录<a href="https://itunesconnect.apple.com/login" target="_blank" rel="external">应用发布网站</a>添加应用信息；<br>2.下载安装发布证书；<br>3.选择发布证书，使用Archive编译发布包，用Xcode将代码（发布包）上传到服务器；<br>4.等待审核通过;<br>5.生成IPA：菜单栏-&gt;Product-&gt;Archive.    </p></blockquote><p>52.SVN的使用  </p><blockquote><ul><li>SVN=版本控制+备份服务器，可以把SVN当成备份服务器，并且可以帮助你记住每次上服务器的档案内容，并自动赋予每次变更的版本；</li><li>SVN的版本控制：所有上传版本都会帮您记录下来，也有版本分支及合并等功能。SVN可以让不同的开发者存取同样的档案，并且利用SVN Server作为档案同步的机制，即您有档案更新时，无需将档案寄送给您的开发成员。SVN的存放档案方式是采用差异备份的方式，即会备份到不同的地方，节省硬盘空间，也可以对非文字文件进行差异备份。</li><li>SVN的重要性：备份工作档案的重要性、版本控管的重要性、伙伴间的数据同步的重要性、备份不同版本是很耗费硬盘空间的；</li><li>防止冲突：<br>1.防止代码冲突：不要多人同时修改同一文件，例如：A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改；<br>2.服务器上的项目文件Xcodeproj，仅让一个人管理提交，其他人只更新，防止文件发生冲突。  </li></ul></blockquote><p>53.如何进行网络消息推送  </p><blockquote><ul><li>一种是Apple自己提供的通知服务（APNS服务器）、一种是用第三方推送机制。</li><li>首先应用发送通知，系统弹出提示框询问用户是否允许，当用户允许后向苹果服务器(APNS)请求deviceToken，并由苹果服务器发送给自己的应用，自己的应用将DeviceToken发送自己的服务器，自己服务器想要发送网络推送时将deviceToken以及想要推送的信息发送给苹果服务器，苹果服务器将信息发送给应用。</li><li>推送信息内容，总容量不超过256个字节；</li><li>iOS SDK本身提供的APNS服务器推送，它可以直接推送给目标用户并根据您的方式弹出提示。<br>优点：不论应用是否开启，都会发送到手机端；<br>缺点：消息推送机制是苹果服务端控制，个别时候可能会有延迟，因为苹果服务器也有队列来处理所有的消息请求；  </li><li>第三方推送机制，普遍使用Socket机制来实现，几乎可以达到即时的发送到目标用户手机端，适用于即时通讯类应用。<br>优点：实时的，取决于心跳包的节奏；<br>缺点：iOS系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这种推送机制不可用.  </li></ul></blockquote><p>54.网络七层协议  </p><blockquote><ul><li>应用层：<br>1.用户接口、应用程序；<br>2.Application典型设备：网关；<br>3.典型协议、标准和应用：TELNET、FTP、HTTP. </li><li>表示层：<br>1.数据表示、压缩和加密presentation.<br>2.典型设备：网关.<br>3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG.<br>4.表示层相当于一个东西的表示，表示的一些协议，比如图片、声音和视频MPEG。    </li><li>会话层：<br>1.会话的建立和结束；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：RPC、SQL、NFS、X WINDOWS、ASP.   </li><li>传输层：<br>1.主要功能：端到端控制Transport；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：TCP、UDP、SPX  </li><li>网络层：<br>1.主要功能：路由、寻址Network；<br>2.典型设备：路由器；<br>3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP；  </li><li>数据链路层：<br>1.主要功能：保证无差错的疏忽链路的data link；<br>2.典型设备：交换机、网桥、网卡；<br>3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；  </li><li>物理层：<br>1.主要功能：传输比特流Physical；<br>2.典型设备：集线器、中继器.<br>3.典型协议、标准和应用：V.35、EIA/TIA-232.   </li></ul></blockquote><p>55.对NSUserDefaults的理解  </p><blockquote><ul><li>NSUserDefaults：系统提供的一种存储数据的方式，主要用于保存少量的数据，默认存储到library下的Preferences文件夹。  </li></ul></blockquote><p>56.SDWebImage原理</p><blockquote><p>调用类别的方法：</p><ul><li>从内存中（字典）找图片（当这个图片在本次程序加载过），找到直接使用；</li><li>从沙盒中找，找到直接使用，缓存到内存。</li><li>从网络上获取，使用，缓存到内存，缓存到沙盒。   </li></ul></blockquote><p>57.OC中是否有二维数组，如何实现二维数组？  </p><blockquote><ul><li>OC中没有二维数组，可通过嵌套数组实现二维数组。</li></ul></blockquote><p>58.LayoutSubViews在什么时候被调用？  </p><blockquote><ul><li>当View本身的frame改变时，会调用这个方法。  </li></ul></blockquote><p>59.深拷贝和浅拷贝  </p><blockquote><ul><li>如果对象有个指针型成员变量指向内存中的某个资源，那么如何复制这个对象呢？你会只是复制指针的值传给副本的新对象吗？指针只是存储内存中资源地址的占位符。在复制操作中，如果只是将指针复制给新对象，那么底层的资源实际上仍然由两个实例在共享。<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458633865626354.png" alt="">  </li><li>浅复制：两个实例的指针仍指向内存中的同一资源，只复制指针值而不是实际资源；</li><li>深复制：不仅复制指针值，还复制指向指针所指向的资源。如下图：<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458633819176042.png" alt=""></li></ul></blockquote><p>60.单例模式理解与使用  </p><blockquote><ul><li>单例模式是一种常用设计模式，单例模式是一个类在系统中只有一个实例对象。通过全局的一个入口点对这个实例对象进行访问；</li><li>iOS中单例模式的实现方式一般分为两种：非ARC和ARC+GCD。</li></ul></blockquote><p>61.对沙盒的理解  </p><blockquote><ul><li>每个iOS应用都被限制在“沙盒”中，沙盒相当于一个加了仅主人可见权限的文件夹，及时在应用程序安装过程中，系统为每个单独的应用程序生成它的主目录和一些关键的子目录。苹果对沙盒有几条限制:<br>1.应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序的沙盒；<br>2.应用之间不能共享数据，沙盒里的文件不能被复制到其他应用程序的文件夹中，也不能把其他应用文件夹复制到沙盒中；<br>3.苹果禁止任何读写沙盒以外的文件，禁止应用程序将内容写到沙盒以外的文件夹中；<br>4.沙盒目录里有三个文件夹：Documents——存储；应用程序的数据文件，存储用户数据或其他定期备份的信息；Library下有两个文件夹，Caches存储应用程序再次启动所需的信息,Preferences包含应用程序的偏好设置文件，不可在这更改偏好设置；temp存放临时文件即应用程序再次启动不需要的文件。  </li><li>获取沙盒根目录的方法，有几种方法：用NSHomeDirectory获取。</li><li>获取Document路径: <code>NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)</code>.  </li></ul></blockquote><p>62.对瀑布流的理解  </p><blockquote><ul><li>首先图片的宽度都是一样的，1.将图片等比例压缩，让图片不变形；2.计算图片最低应该摆放的位置，哪一列低就放在哪；3.进行最优排列，在ScrollView的基础上添加两个tableView，然后将之前所计算的scrollView的高度通过tableView展示出来。</li><li>如何使用两个TableView产生联动：将两个tableView的滚动事件禁止掉，最外层scrollView滚动时将两个TableView跟着滚动，并且更改contentOffset，这样产生效果滚动的两个tableView。 </li></ul></blockquote><p>63.ViewController 的 loadView、viewDidLoad、viewDidUnload 分别是在什么时候调用的？  </p><blockquote><ul><li>viewDidLoad在view从nib文件初始化时调用，loadView在controller的view为nil时调用。</li><li>此方法在编程实现view时调用,view控制器默认会注册memory warning notification,当view controller的任何view没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release,如果是retain的IBOutlet view 属性则不要在这里release,IBOutlet会负责release 。   </li></ul></blockquote><p>64.关键字volatile有什么含意?并给出三个不同的例子：</p><blockquote><ul><li>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：<br>1.并行设备的硬件寄存器（如：状态寄存器）；<br>2.一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)；<br>3.多线程应用中被几个任务共享的变量</li></ul></blockquote><p>65.@synthesize、@dynamic的理解  </p><blockquote><ul><li>@synthesize是系统自动生成getter和setter属性声明;@synthesize的意思是，除非开发人员已经做了，否则由编译器生成相应的代码，以满足属性声明；</li><li>@dynamic是开发者自已提供相应的属性声明,@dynamic意思是由开发人员提供相应的代码：对于只读属性需要提供setter，对于读写属性需要提供 setter 和getter。查阅了一些资料确定@dynamic的意思是告诉编译器,属性的获取与赋值方法由用户自己实现, 不自动生成。  </li></ul></blockquote><p>66.frame和bounds有什么不同？</p><blockquote><ul><li>frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）</li><li>bounds指的是：该view在本身坐标系统中的位置和大小。（参照点是本身坐标系统）</li></ul></blockquote><p>67.view的touch事件有哪些？  </p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event; </div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div></pre></td></tr></table></figure></blockquote><p>68.自定义实现UITabbarController的原理  </p><blockquote><ul><li>运用字典，点击五个按钮的一个可以从字典里选择一个控制器对象，将其View显示到主控制器视图上。</li></ul></blockquote><p>69.iOS中的响应者链的工作原理  </p><blockquote><ul><li>每一个应用有一个响应者链，我们的视图结构是一个N叉树(一个视图可以有多个子视图，一个子视图同一时刻只有一个父视图),而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点。</li><li>当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追朔出一条链，那么对于这一个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发。</li><li>如需了解更多细节，请读<a href="http://www.tuicool.com/articles/6VFn2q" target="_blank" rel="external">这篇文章</a>。  </li></ul></blockquote><p>70.View和View之间传值方式  </p><blockquote><ul><li>对象的property属性传值；</li><li>方法参数传值；</li><li>NSUserDefault传值；</li><li>块传值。  </li></ul></blockquote><p>71.property属性的修饰符的作用  </p><blockquote><ul><li>getter=getName、setter=setName：设置setter与getter的方法名；</li><li>readwrite、readonly：设置可供访问级别；</li><li>assign：方法直接赋值，不进行任何retain操作，为了解决原类型与环循引用问题；</li><li>retain：其setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序；</li><li>copy：其setter方法进行copy操作，与retain处理流程一样，先对旧值release，再copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。</li><li>nonatomic：非原子性访问，不加同步， 多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。  </li></ul></blockquote><p>72.对于Run Loop的理解  </p><blockquote><ul><li>RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；</li><li>每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；</li><li>在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；</li><li>NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；</li><li>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。  </li></ul></blockquote><p>73.SQLite中常用的SQL语句</p><blockquote><ul><li>创建表：creat table 表名 (字段名 字段数据类型 是否为主键, 字段名 字段数据类型, 字段名 字段数据类型…)；</li><li>增: insert into 表名 (字段1, 字段2…) values (值1, 值2…)；</li><li>删: delete from 表名 where 字段 = 值；</li></ul></blockquote><p>74.XIB与Storyboards的优缺点  </p><blockquote><p>优点：  </p><ul><li>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。</li><li>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。 </li></ul><p>缺点：</p><ul><li>XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。</li><li>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</li></ul></blockquote><p>75.将字符串“2015-04-10”格式化日期转为NSDate类型  </p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *timeStr = <span class="string">@"2015-04-10"</span>;</div><div class="line"><span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">formatter.dateFormat = <span class="string">@"yyyy-MM-dd"</span>;</div><div class="line">formatter.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</div><div class="line"><span class="built_in">NSDate</span> *date = [formatter dateFromString:timeStr];</div><div class="line"><span class="comment">// 2015-04-09 16:00:00 +0000</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, date);</div></pre></td></tr></table></figure></blockquote><p>76.队列和多线程的使用原理  </p><blockquote><p>在iOS中队列分为以下几种  </p><ul><li>串行队列：队列中的任务只会顺序执行;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_queue_create(&quot;...&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure><ul><li>并行队列： 队列中的任务通常会并发执行；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_queue_create(&quot;......&quot;,DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure><ul><li>全局队列：是系统的，直接拿过来（GET）用就可以；与并行队列类似；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</div></pre></td></tr></table></figure><ul><li>主队列：每一个应用程序对应唯一主队列，直接GET即可；在多线程开发中，使用主队列更新UI；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t q = dispatch_get_main_queue();</div></pre></td></tr></table></figure><p>更多细节见下图：<br><img src="http://oui2ar2u7.bkt.clouddn.com/1458633174180748.png" alt="">   </p></blockquote><p>77.内存的使用和优化的注意事项  </p><blockquote><ul><li>重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用；</li><li>尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能；</li><li>不要使用太复杂的XIB/Storyboard：载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多；</li><li>选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。</li><li>gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</li><li>延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。</li><li>数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。</li><li>处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉</li><li>重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。</li><li>避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要;</li><li>使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存;</li><li>正确选择图片加载方式：详情阅读细读<a href="http://www.cnblogs.com/jiayongqiang/p/5339583.html" target="_blank" rel="external">UIImage加载方式</a></li></ul></blockquote><p>78.UIViewController的完整生命周期</p><blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-[ViewController initWithNibName:bundle:]；</div><div class="line">-[ViewController init]；</div><div class="line">-[ViewController loadView]；</div><div class="line">-[ViewController viewDidLoad]；</div><div class="line">-[ViewController viewWillDisappear:]；</div><div class="line">-[ViewController viewWillAppear:]；</div><div class="line">-[ViewController viewDidAppear:]；</div><div class="line">-[ViewController viewDidDisappear:]；</div></pre></td></tr></table></figure></blockquote><p>79.UIImageView添加圆角  </p><blockquote><ul><li>最直接的方法就是使用如下属性设置：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imgView.layer.cornerRadius = <span class="number">10</span>;</div><div class="line"><span class="comment">// 这一行代码是很消耗性能的</span></div><div class="line">imgView.clipsToBounds = <span class="literal">YES</span>;</div></pre></td></tr></table></figure><p><strong>这是离屏渲染（off-screen-rendering），消耗性能的</strong></p><ul><li>给UIImage添加生成圆角图片的扩展API：这是on-screen-rendering  </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageWithCornerRadius:(<span class="built_in">CGFloat</span>)radius &#123;</div><div class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="number">0.</span>f, <span class="number">0.</span>f, <span class="keyword">self</span>.size&#125;;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="built_in">UIScreen</span>.mainScreen.scale);</div><div class="line">    <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(),[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);</div><div class="line">   <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</div><div class="line">   [<span class="keyword">self</span> drawInRect:rect];</div><div class="line">   <span class="built_in">UIImage</span> * image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">   <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">   <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="强烈推荐要看一下-招聘一个靠谱的iOS"><a href="#强烈推荐要看一下-招聘一个靠谱的iOS" class="headerlink" title="强烈推荐要看一下 招聘一个靠谱的iOS"></a>强烈推荐要看一下 <a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">招聘一个靠谱的iOS</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.OC的理解与特性    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言
      
    
    </summary>
    
    
  </entry>
  
</feed>
